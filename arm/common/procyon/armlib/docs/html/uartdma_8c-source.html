<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: arch/at91/uartdma.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">arch</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">at91</a></div>
<h1>uartdma.c</h1><a href="uartdma_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uartdma.c \brief UART driver for AT91SAM7S with DMA. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uartdma.c'</span>
00005 <span class="comment">// Title        : UART driver for AT91SAM7S with DMA</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004-2006</span>
00007 <span class="comment">// Created      : 4/3/2004</span>
00008 <span class="comment">// Revised      : 10/24/2006</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel ARM AT91SAM7S Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="comment">// AT91SAM7S definitions</span>
00019 <span class="preprocessor">#include "at91sam7s64.h"</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00022 <span class="preprocessor">#include "processor.h"</span>
00023 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="uartdma_8h.html">uartdma.h</a>"</span>
00025 
00026 <span class="comment">// receive and transmit buffers</span>
<a name="l00027"></a><a class="code" href="uartdma_8c.html#a4">00027</a> cBuffer <a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[3];            <span class="comment">///&lt; uart receive buffers</span>
00028 <span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart0RxData[<a class="code" href="group__uartdma__at91.html#ga44">UART0_RX_BUFFER_SIZE</a>];
00029 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart1RxData[<a class="code" href="group__uartdma__at91.html#ga46">UART1_RX_BUFFER_SIZE</a>];
00030 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart2RxData[<a class="code" href="group__uartdma__at91.html#ga48">UART2_RX_BUFFER_SIZE</a>];
<a name="l00031"></a><a class="code" href="uartdma_8c.html#a8">00031</a> cBuffer <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[3];            <span class="comment">///&lt; uart transmit buffers</span>
00032 <span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart0TxData[<a class="code" href="group__uartdma__at91.html#ga43">UART0_TX_BUFFER_SIZE</a>];
00033 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart1TxData[<a class="code" href="group__uartdma__at91.html#ga45">UART1_TX_BUFFER_SIZE</a>];
00034 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Uart2TxData[<a class="code" href="group__uartdma__at91.html#ga47">UART2_TX_BUFFER_SIZE</a>];
00035 
00036 <span class="comment">// Global Pointer to USARTs</span>
00037 AT91S_USART* <span class="keyword">const</span> pUSART[3] = { AT91C_BASE_US0, AT91C_BASE_US0, AT91C_BASE_DBGU };
00038 <span class="preprocessor">#define pUSART0     ((AT91S_USART*)AT91C_BASE_US0)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define pUSART1     ((AT91S_USART*)AT91C_BASE_US1)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define pUSART2     ((AT91S_USART*)AT91C_BASE_DBGU)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define pPDC(dev)   ((AT91S_PDC*)((unsigned char*)(dev)+0x100))</span>
00042 <span class="preprocessor"></span>
00043 <span class="comment"></span>
00044 <span class="comment">//! enable and initialize the uart</span>
<a name="l00045"></a><a class="code" href="group__uart__at91.html#ga0">00045</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="group__uart__at91.html#ga0">uart0Init</a>(uint16_t bauddiv, uint32_t mode)
00046 {
00047     <span class="comment">// enable the clock of UART0</span>
00048     AT91C_BASE_PMC-&gt;PMC_PCER = (1&lt;&lt;AT91C_ID_US0);
00049     <span class="comment">// enable uart pins on PIO</span>
00050     *AT91C_PIOA_PDR = AT91C_PA5_RXD0 | AT91C_PA6_TXD0;
00051     <span class="comment">// select peripheral connection</span>
00052     *AT91C_PIOA_ASR = AT91C_PA5_RXD0 | AT91C_PA6_TXD0;
00053     <span class="comment">// enable I/O pullup to avoid spurious receive if RXD pin left unconnected</span>
00054     *AT91C_PIOA_PPUER = AT91C_PA5_RXD0;
00055     <span class="comment">// reset the UART</span>
00056     pUSART[0]-&gt;US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS |AT91C_US_TXDIS;
00057     <span class="comment">// set serial line mode</span>
00058     pUSART[0]-&gt;US_MR =  AT91C_US_USMODE_NORMAL |<span class="comment">// Normal Mode</span>
00059                         AT91C_US_CLKS_CLOCK |   <span class="comment">// Clock = MCK</span>
00060                         mode;                   <span class="comment">// user-defined data parameters</span>
00061     <span class="comment">// set the baud rate</span>
00062     pUSART[0]-&gt;US_BRGR = bauddiv;
00063     <span class="comment">// enable the uart</span>
00064     pUSART[0]-&gt;US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
00065     
00066     <span class="comment">// initialize buffers</span>
00067     <a class="code" href="group__uartdma__at91.html#ga3">uart0InitBuffers</a>();
00068     <span class="comment">// setup DMA controller for transmit</span>
00069     <a class="code" href="group__uartdma__at91.html#ga6">uartInitDmaTx</a>(0);
00070     <span class="comment">// setup DMA controller for receive</span>
00071     <span class="comment">//uartInitDmaRx(0);</span>
00072 
00073     <span class="comment">// attach interrupt handler</span>
00074     processorAicAttach(AT91C_ID_US0, (UART0_INTERRUPT_LEVEL|AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL), <a class="code" href="group__uartdma__at91.html#ga25">uart0Service</a>);
00075     <span class="comment">// enable receive interrupt</span>
00076     pUSART[0]-&gt;US_IER = AT91C_US_RXRDY;
00077 }
00078 
00079 <span class="keywordtype">void</span> uart1Init(uint16_t bauddiv, uint32_t mode)
00080 {
00081     <span class="comment">// enable the clock of UART1</span>
00082     AT91C_BASE_PMC-&gt;PMC_PCER = (1&lt;&lt;AT91C_ID_US1);
00083     <span class="comment">// enable uart pins on PIO</span>
00084     *AT91C_PIOA_PDR = AT91C_PA21_RXD1 | AT91C_PA22_TXD1;
00085     <span class="comment">// select peripheral connection</span>
00086     *AT91C_PIOA_ASR = AT91C_PA21_RXD1 | AT91C_PA22_TXD1;
00087     <span class="comment">// enable I/O pullup to avoid spurious receive if RXD pin left unconnected</span>
00088     *AT91C_PIOA_PPUER = AT91C_PA21_RXD1;
00089     <span class="comment">// reset the UART</span>
00090     pUSART[1]-&gt;US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS |AT91C_US_TXDIS;
00091     <span class="comment">// set serial line mode</span>
00092     pUSART[1]-&gt;US_MR =  AT91C_US_USMODE_NORMAL |<span class="comment">// Normal Mode</span>
00093                         AT91C_US_CLKS_CLOCK |   <span class="comment">// Clock = MCK</span>
00094                         mode;                   <span class="comment">// user-defined data parameters</span>
00095     <span class="comment">// set the baud rate</span>
00096     pUSART[1]-&gt;US_BRGR = bauddiv;
00097     <span class="comment">// enable the uart</span>
00098     pUSART[1]-&gt;US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
00099     
00100     <span class="comment">// initialize buffers</span>
00101     uart1InitBuffers();
00102     <span class="comment">// setup DMA controller for transmit</span>
00103     <a class="code" href="group__uartdma__at91.html#ga6">uartInitDmaTx</a>(1);
00104     <span class="comment">// setup DMA controller for receive</span>
00105     <span class="comment">//uartInitDmaRx(0);</span>
00106 
00107     <span class="comment">// attach interrupt handler</span>
00108     processorAicAttach(AT91C_ID_US1, (UART1_INTERRUPT_LEVEL|AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL), uart1Service);
00109     <span class="comment">// enable receive interrupt</span>
00110     pUSART[1]-&gt;US_IER = AT91C_US_RXRDY;
00111 }
00112 
00113 <span class="keywordtype">void</span> uart2Init(uint16_t bauddiv, uint32_t mode)
00114 {
00115     <span class="comment">// enable the clock of DBGU</span>
00116     AT91C_BASE_PMC-&gt;PMC_PCER = (1&lt;&lt;AT91C_ID_SYS);
00117     <span class="comment">// enable uart pins on PIO</span>
00118     *AT91C_PIOA_PDR = AT91C_PA9_DRXD | AT91C_PA10_DTXD;
00119     <span class="comment">// enable I/O pullup to avoid spurious receive if RXD pin left unconnected</span>
00120     *AT91C_PIOA_PPUER = AT91C_PA9_DRXD;
00121     <span class="comment">// reset the UART</span>
00122     pUSART[2]-&gt;US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS |AT91C_US_TXDIS;
00123     <span class="comment">// set serial line mode</span>
00124     pUSART[2]-&gt;US_MR =  AT91C_US_USMODE_NORMAL |    <span class="comment">// Normal Mode</span>
00125                         AT91C_US_CLKS_CLOCK |       <span class="comment">// Clock = MCK</span>
00126                         AT91C_US_CHRL_8_BITS |      <span class="comment">// 8-bit Data (no effect on DBGU)</span>
00127                         AT91C_US_PAR_NONE |         <span class="comment">// No Parity</span>
00128                         AT91C_US_NBSTOP_1_BIT;      <span class="comment">// 1 Stop Bit (no effect on DBGU)</span>
00129     <span class="comment">// set the baud rate</span>
00130     pUSART[2]-&gt;US_BRGR = bauddiv;
00131     <span class="comment">// enable the uart</span>
00132     pUSART[2]-&gt;US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
00133     
00134     <span class="comment">// initialize buffers</span>
00135     uart2InitBuffers();
00136     <span class="comment">// setup DMA controller for transmit</span>
00137     <a class="code" href="group__uartdma__at91.html#ga6">uartInitDmaTx</a>(2);
00138     <span class="comment">// setup DMA controller for receive</span>
00139     <span class="comment">//uartInitDmaRx(2);</span>
00140 
00141     <span class="comment">// attach interrupt handler</span>
00142     processorAicAttachSys(SYSPID_DBGU, uart2Service);
00143     <span class="comment">// enable receive interrupt</span>
00144     pUSART[2]-&gt;US_IER = AT91C_US_RXRDY;
00145 }
00146 
<a name="l00147"></a><a class="code" href="group__uartdma__at91.html#ga3">00147</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga3">uart0InitBuffers</a>(<span class="keywordtype">void</span>)
00148 {
00149     <span class="comment">// initialize the UART0 buffers</span>
00150     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[0], Uart0RxData, <a class="code" href="group__uartdma__at91.html#ga44">UART0_RX_BUFFER_SIZE</a>);
00151     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[0], Uart0TxData, <a class="code" href="group__uartdma__at91.html#ga43">UART0_TX_BUFFER_SIZE</a>);
00152 }
00153 
00154 <span class="keywordtype">void</span> uart1InitBuffers(<span class="keywordtype">void</span>)
00155 {
00156     <span class="comment">// initialize the UART0 buffers</span>
00157     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[1], Uart1RxData, <a class="code" href="group__uartdma__at91.html#ga46">UART1_RX_BUFFER_SIZE</a>);
00158     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[1], Uart1TxData, <a class="code" href="group__uartdma__at91.html#ga45">UART1_TX_BUFFER_SIZE</a>);
00159 }
00160 
00161 <span class="keywordtype">void</span> uart2InitBuffers(<span class="keywordtype">void</span>)
00162 {
00163     <span class="comment">// initialize the UART0 buffers</span>
00164     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[2], Uart2RxData, <a class="code" href="group__uartdma__at91.html#ga48">UART2_RX_BUFFER_SIZE</a>);
00165     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[2], Uart2TxData, <a class="code" href="group__uartdma__at91.html#ga47">UART2_TX_BUFFER_SIZE</a>);
00166 }
00167 
<a name="l00168"></a><a class="code" href="group__uartdma__at91.html#ga6">00168</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga6">uartInitDmaTx</a>(<span class="keywordtype">int</span> dev)
00169 {
00170     <span class="comment">// clear buffer</span>
00171     <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex = 0;
00172     <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].datalength = 0;
00173     <span class="comment">// setup DMA controller for transmit</span>
00174     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTDIS; <span class="comment">// disable Tx DMA</span>
00175     pPDC(pUSART[dev])-&gt;PDC_TPR = (<span class="keywordtype">unsigned</span> int)<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr;
00176     pPDC(pUSART[dev])-&gt;PDC_TCR = 0;
00177     pPDC(pUSART[dev])-&gt;PDC_TNPR = (<span class="keywordtype">unsigned</span> int)<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr;
00178     pPDC(pUSART[dev])-&gt;PDC_TNCR = 0;
00179     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTEN;  <span class="comment">// enable Tx DMA    </span>
00180 }
00181 
<a name="l00182"></a><a class="code" href="group__uartdma__at91.html#ga7">00182</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga7">uartInitDmaRx</a>(<span class="keywordtype">int</span> dev)
00183 {
00184     <span class="comment">// clear buffer</span>
00185     <a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[dev].dataindex = 0;
00186     <a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[dev].datalength = 0;
00187     <span class="comment">// setup DMA controller for receive</span>
00188     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_RXTDIS; <span class="comment">// disable Rx DMA</span>
00189     pPDC(pUSART[dev])-&gt;PDC_RPR = (<span class="keywordtype">unsigned</span> int)<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr;
00190     pPDC(pUSART[dev])-&gt;PDC_RCR = <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].size;
00191     pPDC(pUSART[dev])-&gt;PDC_RNPR = (<span class="keywordtype">unsigned</span> int)<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr;
00192     pPDC(pUSART[dev])-&gt;PDC_RNCR = 0;
00193     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_RXTEN;  <span class="comment">// enable Rx DMA</span>
00194 }
00195 
<a name="l00196"></a><a class="code" href="group__uartintr__at91.html#ga3">00196</a> cBuffer* <a class="code" href="group__uartdma__at91.html#ga8">uartGetRxBuffer</a>(<span class="keywordtype">int</span> dev)
00197 {
00198     <span class="comment">// return rx buffer pointer</span>
00199     <span class="keywordflow">return</span> &amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[dev];
00200 }
00201 
<a name="l00202"></a><a class="code" href="group__uartdma__at91.html#ga9">00202</a> <span class="keywordtype">int</span> <a class="code" href="group__uartdma__at91.html#ga9">uartSendByte</a>(<span class="keywordtype">int</span> dev, <span class="keywordtype">int</span> data)
00203 {
00204 <span class="preprocessor">    #if defined(UART_DMA_BLOCK_IF_BUSY)</span>
00205 <span class="preprocessor"></span>        <span class="comment">// block if DMA buffer has no room</span>
00206         <span class="keywordflow">while</span>( (pPDC(pUSART[dev])-&gt;PDC_TCR + pPDC(pUSART[dev])-&gt;PDC_TNCR) &gt;= <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].size);
00207 <span class="preprocessor">    #else</span>
00208 <span class="preprocessor"></span>        <span class="comment">// return failure if DMA buffer has no room</span>
00209         <span class="keywordflow">if</span>( (pPDC(pUSART[dev])-&gt;PDC_TCR + pPDC(pUSART[dev])-&gt;PDC_TNCR) &gt;= <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].size)
00210             <span class="keywordflow">return</span> -1;
00211 <span class="preprocessor">    #endif</span>
00212 <span class="preprocessor"></span>    <span class="comment">// is a circular buffer wrap necessary?</span>
00213     <span class="keywordflow">if</span>(<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex == <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].size)
00214     {
00215         <span class="comment">//rprintf("Wrapping\n");</span>
00216         <span class="comment">// do write pointer wrap</span>
00217         <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex = 0;
00218         <span class="comment">// add byte to dma buffer</span>
00219         <span class="comment">//rprintf("DMA WrPtr=%d\n", TxBufferWr);</span>
00220         <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr[<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex] = data;
00221         <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex++;
00222         <span class="comment">// switch to "next" DMA</span>
00223         pPDC(pUSART[dev])-&gt;PDC_TNPR = (<span class="keywordtype">unsigned</span> int)<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr;
00224         <span class="comment">// increment byte count on "next" DMA</span>
00225         pPDC(pUSART[dev])-&gt;PDC_TNCR++;
00226     }
00227     <span class="keywordflow">else</span>
00228     {
00229         <span class="comment">// no write pointer wrap</span>
00230         <span class="comment">// add byte to dma buffer</span>
00231         <span class="comment">//rprintf("DMA WrPtr=%d\n", TxBufferWr);</span>
00232         <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataptr[<a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex] = data;
00233         <a class="code" href="uartdma_8c.html#a8">UartTxBuffer</a>[dev].dataindex++;
00234         <span class="comment">// if "next" DMA is already busy...</span>
00235         <span class="keywordflow">if</span>(pPDC(pUSART[dev])-&gt;PDC_TNCR)
00236             pPDC(pUSART[dev])-&gt;PDC_TNCR++;  <span class="comment">// increment byte count on "next" DMA</span>
00237         <span class="keywordflow">else</span>
00238             pPDC(pUSART[dev])-&gt;PDC_TCR++;   <span class="comment">// else, increment byte count on "this" DMA</span>
00239     }
00240 
00241     <span class="keywordflow">return</span> data;
00242 }
00243 
<a name="l00244"></a><a class="code" href="group__uartdma__at91.html#ga13">00244</a> <span class="keywordtype">int</span> <a class="code" href="group__uartdma__at91.html#ga13">uartGetByte</a>(<span class="keywordtype">int</span> dev)
00245 {
00246     <span class="keywordflow">if</span>(<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[dev].datalength)        <span class="comment">// check if character is available</span>
00247         <span class="keywordflow">return</span> <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[dev]);  <span class="comment">// return character</span>
00248     <span class="keywordflow">return</span> -1;
00249 
00250 <span class="comment">/*  </span>
00251 <span class="comment">    int data;</span>
00252 <span class="comment"></span>
00253 <span class="comment">    // are any bytes available?</span>
00254 <span class="comment">    if( (pPDC(pUSART[dev])-&gt;PDC_RCR + pPDC(pUSART[dev])-&gt;PDC_RNCR) &gt;= UartRxBuffer[dev].size)</span>
00255 <span class="comment">        return -1;</span>
00256 <span class="comment"></span>
00257 <span class="comment">    // is a wrap necessary?</span>
00258 <span class="comment">    if(UartRxBuffer[dev].dataindex == UartRxBuffer[dev].size)</span>
00259 <span class="comment">    {</span>
00260 <span class="comment">        //rprintf("Wrapping\n");</span>
00261 <span class="comment">        // do pointer wrap</span>
00262 <span class="comment">        UartRxBuffer[dev].dataindex = 0;</span>
00263 <span class="comment">        // read byte from dma buffer</span>
00264 <span class="comment">        //rprintf("DMA RdPtr=%d  ", UartRxBuffer[dev].dataindex);</span>
00265 <span class="comment">        data = UartRxBuffer[dev].dataptr[UartTxBuffer[dev].dataindex];</span>
00266 <span class="comment">        UartRxBuffer[dev].dataindex++;</span>
00267 <span class="comment">        // switch to "next" DMA</span>
00268 <span class="comment">        //pUSART_PDC-&gt;PDC_RNPR = (unsigned int)RxBuffer;</span>
00269 <span class="comment">        // increment byte count on "next" DMA</span>
00270 <span class="comment">        pPDC(pUSART[dev])-&gt;PDC_RCR++;</span>
00271 <span class="comment">    }</span>
00272 <span class="comment">    else</span>
00273 <span class="comment">    {</span>
00274 <span class="comment">        // no pointer wrap</span>
00275 <span class="comment">        // read byte from dma buffer</span>
00276 <span class="comment">        //rprintf("DMA RdPtr=%d  ", UartRxBuffer[dev].dataindex);</span>
00277 <span class="comment">        data = UartRxBuffer[dev].dataptr[UartTxBuffer[dev].dataindex];</span>
00278 <span class="comment">        UartRxBuffer[dev].dataindex++;</span>
00279 <span class="comment">        // if "next" DMA is already busy...</span>
00280 <span class="comment">        pPDC(pUSART[dev])-&gt;PDC_RNPR = (unsigned int)UartRxBuffer[dev].dataptr;</span>
00281 <span class="comment">        if( ((pPDC(pUSART[dev])-&gt;PDC_RPR-(unsigned int)UartRxBuffer[dev].dataptr) + pPDC(pUSART[dev])-&gt;PDC_RCR) &lt; UartRxBuffer[dev].size)</span>
00282 <span class="comment">            pPDC(pUSART[dev])-&gt;PDC_RCR++;   // increment byte count on "this" DMA</span>
00283 <span class="comment">        else</span>
00284 <span class="comment">            pPDC(pUSART[dev])-&gt;PDC_RNCR++;  // else, increment byte count on "next" DMA</span>
00285 <span class="comment">    }</span>
00286 <span class="comment"></span>
00287 <span class="comment">    //rprintf("RPR =0x%x  ", pPDC(pUSART[dev])-&gt;PDC_RPR-(int)UartRxBuffer[dev].dataptr);</span>
00288 <span class="comment">    //rprintf("RCR =0x%x  ", pPDC(pUSART[dev])-&gt;PDC_RCR);</span>
00289 <span class="comment">    //rprintf("RNPR=0x%x  ", pPDC(pUSART[dev])-&gt;PDC_RNPR-(int)UartRxBuffer[dev].dataptr);</span>
00290 <span class="comment">    //rprintf("RNCR=0x%x\n", pPDC(pUSART[dev])-&gt;PDC_RNCR);</span>
00291 <span class="comment"></span>
00292 <span class="comment">    return data;</span>
00293 <span class="comment">*/</span>
00294 }
00295 
<a name="l00296"></a><a class="code" href="group__uartdma__at91.html#ga17">00296</a> <span class="keywordtype">int</span> <a class="code" href="group__uartdma__at91.html#ga17">uartSendBlock</a>(<span class="keywordtype">int</span> dev, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len)
00297 {
00298 <span class="preprocessor">    #if defined(UART_DMA_BLOCK_IF_BUSY)</span>
00299 <span class="preprocessor"></span>        <span class="comment">// block if DMA is not ready</span>
00300         <span class="keywordflow">while</span>( (pPDC(pUSART[dev])-&gt;PDC_TCR + pPDC(pUSART[dev])-&gt;PDC_TNCR) &gt; 0);
00301 <span class="preprocessor">    #else</span>
00302 <span class="preprocessor"></span>        <span class="comment">// return failure if DMA is not ready</span>
00303         <span class="keywordflow">if</span>( (pPDC(pUSART[dev])-&gt;PDC_TCR + pPDC(pUSART[dev])-&gt;PDC_TNCR) &gt; 0)
00304             <span class="keywordflow">return</span> -1;
00305 <span class="preprocessor">    #endif</span>
00306 <span class="preprocessor"></span>
00307     <span class="comment">// setup DMA block transfer</span>
00308     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTDIS; <span class="comment">// disable Tx DMA</span>
00309     pPDC(pUSART[dev])-&gt;PDC_TPR = (<span class="keywordtype">unsigned</span> int)data;<span class="comment">// set pointer to data buffer</span>
00310     pPDC(pUSART[dev])-&gt;PDC_TCR = len;               <span class="comment">// set number of bytes to transfer</span>
00311     pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTEN;  <span class="comment">// enable Tx DMA (starts DMA output)</span>
00312     <span class="comment">// return success</span>
00313     <span class="keywordflow">return</span> 0;
00314 }
00315 
<a name="l00316"></a><a class="code" href="group__uartdma__at91.html#ga21">00316</a> <span class="keywordtype">int</span> <a class="code" href="group__uartdma__at91.html#ga21">uartGetBlock</a>(<span class="keywordtype">int</span> dev, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len)
00317 {
00318 <span class="preprocessor">    #if defined(UART_DMA_BLOCK_IF_BUSY)</span>
00319 <span class="preprocessor"></span>        <span class="comment">// block if DMA is not ready</span>
00320         <span class="keywordflow">while</span>( (pPDC(pUSART[dev])-&gt;PDC_RCR + pPDC(pUSART[dev])-&gt;PDC_RNCR) &gt; 0);
00321 <span class="preprocessor">    #else</span>
00322 <span class="preprocessor"></span>        <span class="comment">// return failure if DMA is not ready</span>
00323         <span class="keywordflow">if</span>( (pPDC(pUSART[dev])-&gt;PDC_RCR + pPDC(pUSART[dev])-&gt;PDC_RNCR) &gt; 0)
00324             <span class="keywordflow">return</span> -1;
00325 <span class="preprocessor">    #endif</span>
00326 <span class="preprocessor"></span>
00327     <span class="keywordflow">if</span>(len)
00328     {
00329         <span class="comment">// setup new DMA block transfer</span>
00330         pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTDIS; <span class="comment">// disable Rx DMA</span>
00331         pPDC(pUSART[dev])-&gt;PDC_RPR = (<span class="keywordtype">unsigned</span> int)data;<span class="comment">// set pointer to data buffer</span>
00332         pPDC(pUSART[dev])-&gt;PDC_RCR = len;               <span class="comment">// set number of bytes to transfer</span>
00333         pPDC(pUSART[dev])-&gt;PDC_PTCR = AT91C_PDC_TXTEN;  <span class="comment">// enable Rx DMA (starts DMA input)</span>
00334         <span class="comment">// return success</span>
00335         <span class="keywordflow">return</span> len;
00336     }
00337     <span class="keywordflow">else</span>
00338     {
00339         <span class="comment">// return remaining byte count on current DMA transfer</span>
00340         <span class="keywordflow">return</span> pPDC(pUSART[dev])-&gt;PDC_TCR;
00341     }
00342 }
00343 
<a name="l00344"></a><a class="code" href="group__uartdma__at91.html#ga25">00344</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga25">uart0Service</a>(<span class="keywordtype">void</span>)
00345 {
00346     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> status;
00347 
00348     <span class="comment">// read the channel status register</span>
00349     status  = pUSART0-&gt;US_CSR;
00350     status &amp;= pUSART0-&gt;US_IMR;
00351 
00352     <span class="keywordflow">if</span>(status &amp; AT91C_US_RXRDY)
00353     {
00354         <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[0], pUSART0-&gt;US_RHR);
00355     }
00356 
00357     <span class="keywordflow">if</span>(status &amp; AT91C_US_TXRDY)
00358     {
00359     }
00360 
00361     <span class="comment">// reset error status bits</span>
00362     pUSART0-&gt;US_CR = AT91C_US_RSTSTA;
00363     <span class="comment">// clear AIC</span>
00364     AT91C_BASE_AIC-&gt;AIC_EOICR = 0;
00365 }
00366 
00367 <span class="keywordtype">void</span> uart1Service(<span class="keywordtype">void</span>)
00368 {
00369     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> status;
00370 
00371     <span class="comment">// read the channel status register</span>
00372     status  = pUSART1-&gt;US_CSR;
00373     status &amp;= pUSART1-&gt;US_IMR;
00374 
00375     <span class="keywordflow">if</span>(status &amp; AT91C_US_RXRDY)
00376     {
00377         <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[1], pUSART1-&gt;US_RHR);
00378     }
00379 
00380     <span class="keywordflow">if</span>(status &amp; AT91C_US_TXRDY)
00381     {
00382     }
00383 
00384     <span class="comment">// reset error status bits</span>
00385     pUSART1-&gt;US_CR = AT91C_US_RSTSTA;
00386     <span class="comment">// clear AIC</span>
00387     AT91C_BASE_AIC-&gt;AIC_EOICR = 0;
00388 }
00389 
00390 <span class="keywordtype">void</span> uart2Service(<span class="keywordtype">void</span>)
00391 {
00392     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> status;
00393 
00394     <span class="comment">// read the channel status register</span>
00395     status  = pUSART2-&gt;US_CSR;
00396     status &amp;= pUSART2-&gt;US_IMR;
00397 
00398     <span class="keywordflow">if</span>(status &amp; AT91C_US_RXRDY)
00399     {
00400         <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;<a class="code" href="uartdma_8c.html#a4">UartRxBuffer</a>[2], pUSART2-&gt;US_RHR);
00401     }
00402 
00403     <span class="keywordflow">if</span>(status &amp; AT91C_US_TXRDY)
00404     {
00405     }
00406 
00407     <span class="comment">// reset error status bits</span>
00408     pUSART2-&gt;US_CR = AT91C_US_RSTSTA;
00409     <span class="comment">// clear AIC</span>
00410     AT91C_BASE_AIC-&gt;AIC_EOICR = 0;
00411 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
