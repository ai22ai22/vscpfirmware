<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: fat.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>fat.c</h1><a href="fat_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file fat.c \brief FAT16/32 file system driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'fat.c'</span>
00005 <span class="comment">// Title        : FAT16/32 file system driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/07/2000</span>
00008 <span class="comment">// Revised      : 12/12/2000</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : ATmega103 (should work for Atmel AVR Series)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is based in part on work done by Jesper Hansen for his</span>
00014 <span class="comment">//      YAMPP MP3 player project.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00017 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00018 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00019 <span class="comment">//</span>
00020 <span class="comment">// This code is distributed under the GNU Public License</span>
00021 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00022 <span class="comment">//</span>
00023 <span class="comment">//*****************************************************************************</span>
00024 
00025 
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
00027 
00028 <span class="preprocessor">#include "device.h"</span>
00029 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="fat_8h.html">fat.h</a>"</span>
00033 <span class="preprocessor">#include "fatconf.h"</span>
00034 
00035 <span class="comment">// globals</span>
00036 <span class="comment">// buffers</span>
00037 <span class="comment">//unsigned char *SectorBuffer  =        (unsigned char *) FAT_SECTOR_BUFFER_ADDR;</span>
00038 <span class="comment">//unsigned char *FileNameBuffer =       (unsigned char *) FAT_FILENAME_BUFFER_ADDR;</span>
00039 <span class="comment">//unsigned char *PathNameBuffer =       (unsigned char *) FAT_PATHNAME_BUFFER_ADDR;</span>
00040 <span class="comment">//unsigned char *FatCacheBuffer =       (unsigned char *) FAT_CACHE_BUFFER_ADDR;</span>
00041 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> SectorBuffer[0x200];
00042 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> FileNameBuffer[0x100];
00043 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> PathNameBuffer[0x100];
00044 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> FatCacheBuffer[0x200];
00045 
00046 <span class="keyword">struct </span>fatFsInfo
00047 {
00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FirstDataSector;
00049     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> BytesPerSector;
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> SectorsPerCluster;
00051     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FirstFATSector;
00052     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> SectorsPerFat;
00053     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> RootDirStartCluster;
00054     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FatInCache;
00055     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FatMask;
00056     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Fat32Enabled;
00057     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NumberOfFats;
00058 
00059     DevDisk_t devdisk;
00060 <span class="comment">//};</span>
00061 } <a class="code" href="group__dhcp.html#ga41">GNUC_PACKED</a>;
00062 
00063 <span class="keyword">typedef</span> <span class="keyword">struct </span>FatFsInfo FatFsInfo_t;
00064 
00065 <span class="comment">// filesystem constants/metrics</span>
00066 <span class="keyword">struct </span>fatFsInfo FatFsInfo;
00067 
00068 <span class="comment">// operating variables</span>
00069 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> CurrentDirStartCluster;   <span class="comment">//&lt; current directory starting cluster</span>
00070 <span class="keyword">struct </span>FileInfo_s FileInfo;             <span class="comment">//&lt; file information for last file accessed</span>
00071 
00072 
00073 <span class="comment">/*************************************************************************/</span>
00074 <span class="comment">/*************************************************************************/</span>
00075 
00076 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatInit(DevDisk_t* devdisk)
00077 {
00078     <span class="comment">//bios parameter block</span>
00079     <span class="keyword">struct </span>bpb710 *bpb;
00080 
00081     <span class="comment">// initialize disk access interface</span>
00082     FatFsInfo.devdisk = *devdisk;
00083 
00084     rprintfProgStrM(<span class="stringliteral">"DevDisk pointers\r\n"</span>);
00085     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)devdisk-&gt;ReadSector);
00086     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)devdisk-&gt;WriteSector);
00087     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00088 
00089     FatFsInfo.FatInCache = 0;
00090 
00091     <span class="comment">// Read the BootSector</span>
00092     FatFsInfo.devdisk.ReadSector(0, 1, SectorBuffer);
00093     bpb = (<span class="keyword">struct </span>bpb710 *) ((<span class="keyword">struct </span>bootsector710 *) SectorBuffer)-&gt;bsBPB;
00094 
00095     <span class="comment">// setup global disk constants</span>
00096     <span class="keywordflow">if</span>(bpb-&gt;bpbFATsecs)
00097     {
00098         <span class="comment">// bpbFATsecs (16-bit) is non-zero and is therefore valid</span>
00099         FatFsInfo.SectorsPerFat = bpb-&gt;bpbFATsecs;
00100         <span class="comment">// this volume should be FAT16</span>
00101         <span class="comment">// first directory cluster is 2 by default (clusters range 2-&gt;big)</span>
00102         FatFsInfo.RootDirStartCluster = CLUST_FIRST;
00103         <span class="comment">// push data sector pointer to end of root directory area</span>
00104         <span class="comment">//FirstDataSector += (bpb-&gt;bpbRootDirEnts)/DIRENTRIES_PER_SECTOR;</span>
00105         FatFsInfo.Fat32Enabled = FALSE;
00106         <span class="comment">// set FAT mask for 16-bit</span>
00107         FatFsInfo.FatMask = FAT16_MASK;
00108     }
00109     <span class="keywordflow">else</span>
00110     {
00111         <span class="comment">// bpbFATsecs is zero, real value is in bpbBigFATsecs (32-bit)</span>
00112         FatFsInfo.SectorsPerFat = bpb-&gt;bpbBigFATsecs;
00113         <span class="comment">// this volume must be FAT32</span>
00114         <span class="comment">// bpbRootClust field exists in FAT32 bpb710, but not in lesser bpb's</span>
00115         FatFsInfo.RootDirStartCluster = bpb-&gt;bpbRootClust;
00116         <span class="comment">// push data sector pointer to end of root directory area</span>
00117         <span class="comment">// need this? FirstDataSector += (bpb-&gt;bpbRootDirEnts)/DIRENTRIES_PER_SECTOR;</span>
00118         FatFsInfo.Fat32Enabled = TRUE;
00119         <span class="comment">// set FAT mask for 32-bit</span>
00120         FatFsInfo.FatMask = FAT32_MASK;
00121     }
00122     FatFsInfo.SectorsPerCluster     = bpb-&gt;bpbSecPerClust;
00123     FatFsInfo.BytesPerSector        = bpb-&gt;bpbBytesPerSec;
00124     FatFsInfo.FirstFATSector        = bpb-&gt;bpbResSectors;
00125     FatFsInfo.NumberOfFats          = bpb-&gt;bpbFATs;
00126     FatFsInfo.FirstDataSector       = bpb-&gt;bpbResSectors + FatFsInfo.NumberOfFats * FatFsInfo.SectorsPerFat;
00127 
00128     <span class="comment">// set current directory to root (\)</span>
00129     CurrentDirStartCluster = FatFsInfo.RootDirStartCluster;
00130     PathNameBuffer[0] = <span class="charliteral">'\\'</span>;
00131     PathNameBuffer[1] = 0;
00132 
00133     <span class="comment">// do debug</span>
00134 <span class="preprocessor">#ifdef DEBUG_FAT</span>
00135 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"---------- Disk/Partition Information ----------\r\n"</span>);
00136     rprintfProgStrM(<span class="stringliteral">"Volume/Part Size: "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.devdisk.numsectors);       <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00137     rprintfProgStrM(<span class="stringliteral">"---------- FAT Volume Information --------------\r\n"</span>);
00138     rprintfProgStrM(<span class="stringliteral">"Reserved Sectors: "</span>);  <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(bpb-&gt;bpbResSectors);             <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00139     rprintfProgStrM(<span class="stringliteral">"FatSectors      : "</span>);  <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(bpb-&gt;bpbFATsecs);                <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00140     rprintfProgStrM(<span class="stringliteral">"BigFatSectors   : "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(bpb-&gt;bpbBigFATsecs);             <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00141     rprintfProgStrM(<span class="stringliteral">"Bytes/Sector    : "</span>);  <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(FatFsInfo.BytesPerSector);       <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00142     rprintfProgStrM(<span class="stringliteral">"First Fat Sector: "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.FirstFATSector);       <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00143     rprintfProgStrM(<span class="stringliteral">"Number of Fats  : "</span>);  <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(FatFsInfo.NumberOfFats);         <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00144     rprintfProgStrM(<span class="stringliteral">"Sectors/FAT     : "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.SectorsPerFat);        <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00145     rprintfProgStrM(<span class="stringliteral">"First Data Sect : "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.FirstDataSector);      <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00146     rprintfProgStrM(<span class="stringliteral">"Sectors/Cluster : "</span>);  <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(FatFsInfo.SectorsPerCluster);    <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00147     rprintfProgStrM(<span class="stringliteral">"RootDirStartClus: "</span>);  <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.RootDirStartCluster);  <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00148 <span class="preprocessor">#endif</span>
00149 <span class="preprocessor"></span>
00150     <span class="keywordflow">return</span> 0;   
00151 }
00152 
00153 <span class="comment"></span>
00154 <span class="comment">//////////////////////////////////////////////////////////////</span>
00155 <span class="comment"></span>
00156 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatGetDirEntry(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entry)
00157 {
00158     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00159     <span class="keyword">struct </span>direntry *de = 0;    <span class="comment">// avoid compiler warning by initializing</span>
00160     <span class="keyword">struct </span>winentry *we;
00161     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> haveLongNameEntry;
00162     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> gotEntry;
00163     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> b;
00164     <span class="keywordtype">int</span> i,index;
00165     <span class="keywordtype">char</span> *fnbPtr;
00166     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entrycount = 0;
00167 
00168     <span class="comment">// read dir data</span>
00169 
00170     sector = fatClusterToSector(CurrentDirStartCluster);
00171 
00172     haveLongNameEntry = 0;
00173     gotEntry = 0;
00174 
00175     index = 16; <span class="comment">// crank it up</span>
00176     
00177     <span class="comment">//while(entrycount &lt; entry) </span>
00178     <span class="keywordflow">while</span>(1)
00179     {
00180         <span class="keywordflow">if</span>(index == 16) <span class="comment">// time for next sector ?</span>
00181         {
00182             FatFsInfo.devdisk.ReadSector(sector++, 1, SectorBuffer);
00183             de = (<span class="keyword">struct </span>direntry *) SectorBuffer;
00184             index = 0;
00185         }
00186         
00187         <span class="comment">// check the status of this directory entry slot</span>
00188         <span class="keywordflow">if</span>(de-&gt;deName[0] == 0x00)
00189         {
00190             <span class="comment">// slot is empty and this is the end of directory</span>
00191             gotEntry = 0;
00192             <span class="keywordflow">break</span>;
00193         }
00194         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(de-&gt;deName[0] == 0xE5)
00195         {
00196             <span class="comment">// this is an empty slot</span>
00197             <span class="comment">// do nothing and move to the next one</span>
00198         }
00199         <span class="keywordflow">else</span>
00200         {
00201             <span class="comment">// this is a valid and occupied entry</span>
00202             <span class="comment">// is it a part of a long file/dir name?</span>
00203             <span class="keywordflow">if</span>(de-&gt;deAttributes == ATTR_LONG_FILENAME)
00204             {
00205                 <span class="comment">// we have a long name entry</span>
00206                 <span class="comment">// cast this directory entry as a "windows" (LFN: LongFileName) entry</span>
00207                 we = (<span class="keyword">struct </span>winentry *) de;
00208                 
00209                 b = WIN_ENTRY_CHARS*( (we-&gt;weCnt-1) &amp; 0x0f);        <span class="comment">// index into string</span>
00210                 fnbPtr = &amp;FileNameBuffer[b];
00211                 <span class="keywordflow">for</span> (i=0;i&lt;5;i++)   *fnbPtr++ = we-&gt;wePart1[i*2];   <span class="comment">// copy first part</span>
00212                 <span class="keywordflow">for</span> (i=0;i&lt;6;i++)   *fnbPtr++ = we-&gt;wePart2[i*2];   <span class="comment">// second part</span>
00213                 <span class="keywordflow">for</span> (i=0;i&lt;2;i++)   *fnbPtr++ = we-&gt;wePart3[i*2];   <span class="comment">// and third part</span>
00214                 <span class="keywordflow">if</span> (we-&gt;weCnt &amp; WIN_LAST) *fnbPtr = 0;              <span class="comment">// in case dirnamelength is multiple of 13, add termination</span>
00215                 if ((we-&gt;weCnt &amp; 0x0f) == 1) haveLongNameEntry = 1; <span class="comment">// flag that we have a complete long name entry set</span>
00216             }
00217             <span class="keywordflow">else</span>
00218             {
00219                 <span class="comment">// we have a short name entry</span>
00220                 
00221                 <span class="comment">// check if this is the short name entry corresponding</span>
00222                 <span class="comment">// to the end of a multi-part long name entry</span>
00223                 <span class="keywordflow">if</span>(haveLongNameEntry)
00224                 {
00225                     <span class="comment">// a long entry name has been collected</span>
00226                     <span class="keywordflow">if</span>(entrycount == entry)     
00227                     {
00228                         <span class="comment">// desired entry has been found, break out</span>
00229                         gotEntry = 1;
00230                         <span class="keywordflow">break</span>;
00231                     }
00232                     <span class="comment">// otherwise</span>
00233                     haveLongNameEntry = 0;  <span class="comment">// clear long name flag</span>
00234                     entrycount++;           <span class="comment">// increment entry counter      </span>
00235                 }
00236                 <span class="keywordflow">else</span>
00237                 {
00238                     <span class="comment">// entry is a short name (8.3 format) without a</span>
00239                     <span class="comment">// corresponding multi-part long name entry</span>
00240                     fnbPtr = FileNameBuffer;
00241                     <span class="keywordflow">for</span> (i=0;i&lt;8;i++)   *fnbPtr++ = de-&gt;deName[i];      <span class="comment">// copy name</span>
00242                     *fnbPtr++ = <span class="charliteral">'.'</span>;                                    <span class="comment">// insert '.'</span>
00243                     <span class="keywordflow">for</span> (i=0;i&lt;3;i++)   *fnbPtr++ = de-&gt;deExtension[i]; <span class="comment">// copy extension</span>
00244                     *fnbPtr = 0;                                        <span class="comment">// null-terminate</span>
00245 
00246                     <span class="keywordflow">if</span>(entrycount == entry)     
00247                     {
00248                         <span class="comment">// desired entry has been found, break out</span>
00249                         gotEntry = 1;
00250                         <span class="keywordflow">break</span>;
00251                     }
00252                     <span class="comment">// otherwise</span>
00253                     entrycount++;           <span class="comment">// increment entry counter      </span>
00254                 }
00255             }
00256         }
00257         <span class="comment">// next directory entry</span>
00258         de++;
00259         <span class="comment">// next index</span>
00260         index++;
00261     }
00262     
00263     <span class="comment">// we have a file/dir to return</span>
00264     <span class="comment">// store file/dir starting cluster (start of data)</span>
00265     FileInfo.StartCluster = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)de-&gt;deHighClust &lt;&lt; 16) + de-&gt;deStartCluster;
00266     <span class="comment">// store file/dir size</span>
00267     <span class="comment">// (note: size field for subdirectory entries is always zero)</span>
00268     FileInfo.Size = de-&gt;deFileSize;
00269     <span class="comment">// store file/dir attributes</span>
00270     FileInfo.Attr = de-&gt;deAttributes;
00271     <span class="comment">// store file/dir creation time</span>
00272     FileInfo.CreateTime = de-&gt;deCTime[0] | de-&gt;deCTime[1]&lt;&lt;8;
00273     <span class="comment">// store file/dir creation date</span>
00274     FileInfo.CreateTime = de-&gt;deCDate[0] | de-&gt;deCDate[1]&lt;&lt;8;
00275 
00276     <span class="keywordflow">return</span> gotEntry;
00277 }
00278 
00279 <span class="keywordtype">int</span> fatCreateFile(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* filename, FileInfo_t* fileInfo)
00280 {
00281     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00282     <span class="keyword">struct </span>direntry *de = 0;    <span class="comment">// avoid compiler warning by initializing</span>
00283     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
00284     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* strptr;
00285     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00286     
00287     <span class="comment">// find empty directory entry</span>
00288     sector = fatClusterToSector(CurrentDirStartCluster);
00289 
00290     index = DIRENTRIES_PER_SECTOR;
00291 
00292     <span class="keywordflow">while</span>(1)
00293     {
00294         <span class="keywordflow">if</span>(index == DIRENTRIES_PER_SECTOR)  <span class="comment">// time for next sector ?</span>
00295         {
00296             FatFsInfo.devdisk.ReadSector(sector++, 1, SectorBuffer);
00297             de = (<span class="keyword">struct </span>direntry *)SectorBuffer;
00298             index = 0;
00299         }
00300         
00301         <span class="comment">// check the status of this directory entry slot</span>
00302         <span class="keywordflow">if</span>(de-&gt;deName[0] == SLOT_EMPTY)
00303         {
00304             <span class="comment">// slot is empty and this is the end of the directory</span>
00305             <span class="comment">// need to make sure the next slot is written with a zero</span>
00306             <span class="keywordflow">break</span>;
00307         }
00308         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(de-&gt;deName[0] == SLOT_DELETED)
00309         {
00310             <span class="comment">// this is an empty slot, the entry was previously deleted</span>
00311             <span class="keywordflow">break</span>;
00312         }
00313         <span class="comment">// empty/unused directory entry not yet found</span>
00314         <span class="comment">// move to the next one</span>
00315         de++;
00316         index++;
00317     }
00318 
00319     <span class="comment">// populate directory entry</span>
00320     strptr = filename;
00321     <span class="comment">// parse and fill filename</span>
00322     <span class="keywordflow">for</span>(i=0; i&lt;8; i++)
00323     {
00324         <span class="keywordflow">if</span>( (*strptr != <span class="charliteral">'.'</span>) &amp;&amp; (*strptr != 0) )
00325             de-&gt;deName[i] = *strptr++;
00326         <span class="keywordflow">else</span>
00327             de-&gt;deName[i] = <span class="charliteral">' '</span>;
00328     }
00329     <span class="comment">// fill extension</span>
00330     <span class="comment">//strchr(filename, '.')</span>
00331     <span class="keywordflow">if</span>(*strptr == <span class="charliteral">'.'</span>)
00332     {
00333         strptr++;
00334         de-&gt;deExtension[0] = *strptr++;
00335         de-&gt;deExtension[1] = *strptr++;
00336         de-&gt;deExtension[2] = *strptr++;
00337     }
00338     <span class="keywordflow">else</span>
00339     {
00340         de-&gt;deExtension[0] = <span class="charliteral">' '</span>;
00341         de-&gt;deExtension[1] = <span class="charliteral">' '</span>;
00342         de-&gt;deExtension[2] = <span class="charliteral">' '</span>;
00343     }
00344     <span class="comment">// attributes</span>
00345     de-&gt;deAttributes = fileInfo-&gt;Attr;
00346     <span class="comment">// stuff</span>
00347     de-&gt;deLowerCase = 0;
00348     <span class="comment">// dates</span>
00349     de-&gt;deCHundredth = 0;
00350     de-&gt;deCTime[0] = fileInfo-&gt;CreateTime;
00351     de-&gt;deCTime[1] = fileInfo-&gt;CreateTime&gt;&gt;8;
00352     de-&gt;deCDate[0] = fileInfo-&gt;CreateDate;
00353     de-&gt;deCDate[1] = fileInfo-&gt;CreateDate&gt;&gt;8;
00354     de-&gt;deADate[0] = 0;
00355     de-&gt;deADate[1] = 0;
00356     de-&gt;deMTime[0] = 0;
00357     de-&gt;deMTime[1] = 0;
00358     de-&gt;deMDate[0] = 0;
00359     de-&gt;deMDate[1] = 0;
00360     <span class="comment">// file size</span>
00361     de-&gt;deFileSize = fileInfo-&gt;Size;
00362     <span class="comment">// set file's start cluster</span>
00363     de-&gt;deStartCluster = fileInfo-&gt;StartCluster;
00364     de-&gt;deHighClust = fileInfo-&gt;StartCluster&gt;&gt;16;
00365 
00366     <span class="comment">// write directory entry back to disk</span>
00367     FatFsInfo.devdisk.WriteSector(--sector, 1, SectorBuffer);
00368 
00369     <span class="keywordflow">return</span> 0;
00370 }
00371 
00372 <span class="keywordtype">int</span> fatFormat(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> volsize)
00373 {
00374     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i,j,fatsecs;
00375     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00376 
00377     <span class="keyword">struct </span>bootsector710 *bs;
00378     <span class="keyword">struct </span>bpb710* bpb;
00379 
00380     <span class="comment">// FIRST STAGE</span>
00381     rprintfProgStrM(<span class="stringliteral">"Calculating filesystem parameters\r\n"</span>);
00382     <span class="comment">// clear sector buffer</span>
00383     memset(SectorBuffer, 0, 512);
00384     <span class="comment">// create boot sector and bios parameter block</span>
00385     bs = (<span class="keyword">struct </span>bootsector710 *)SectorBuffer;
00386 
00387     strcpy(&amp;bs-&gt;bsOEMName[0], <span class="stringliteral">"MSDOS5.0"</span>);
00388     
00389     bpb = (<span class="keyword">struct </span>bpb710*)bs-&gt;bsBPB;
00390 
00391     <span class="comment">// BPB for FAT16</span>
00392     bpb-&gt;bpbBytesPerSec = 0x200;    <span class="comment">// standard 512Kbyte sectors</span>
00393     bpb-&gt;bpbSecPerClust = 8;        <span class="comment">// standard 4K clusters</span>
00394     bpb-&gt;bpbResSectors = 4;         <span class="comment">// number of reserved sectors before FAT starts</span>
00395     bpb-&gt;bpbFATs = 2;               <span class="comment">// standard 2 FATs</span>
00396     bpb-&gt;bpbRootDirEnts = 0x200;    <span class="comment">// 512 entries</span>
00397     <span class="keywordflow">if</span>(volsize &lt; 0x10000)
00398     {
00399         <span class="comment">// can be FAT16 only</span>
00400         bpb-&gt;bpbSectors = volsize;  <span class="comment">// size of the volume in sectors</span>
00401         bpb-&gt;bpbHugeSectors = 0;    
00402     }
00403     <span class="keywordflow">else</span>
00404     {
00405         <span class="comment">// can be FAT16 or FAT32</span>
00406         bpb-&gt;bpbSectors = 0;
00407         bpb-&gt;bpbHugeSectors = volsize;  <span class="comment">// size of the volume in sectors</span>
00408     }
00409     <span class="comment">// -----------------------------------------------------------------</span>
00410     <span class="comment">// figure out how to split the drive into FAT(s) and data clusters</span>
00411     <span class="comment">// -determine the number of sectors usable for FAT and clusters</span>
00412     i = volsize - (bpb-&gt;bpbResSectors + (bpb-&gt;bpbRootDirEnts+(DIRENTRIES_PER_SECTOR-1))/DIRENTRIES_PER_SECTOR);
00413     <span class="comment">// -each cluster occupies bpbSecPerClust + 1 FAT entry (2/4 bytes) per fat</span>
00414     j = ((<span class="keywordtype">unsigned</span> short)bpb-&gt;bpbSecPerClust&lt;&lt;8) + bpb-&gt;bpbFATs;
00415     <span class="comment">// if fat32 then j/=2;</span>
00416     fatsecs = (i+(j-1))/j;
00417     <span class="comment">/*</span>
00418 <span class="comment">    rprintf("rootentr = "); rprintfu32(bpb-&gt;bpbRootDirEnts); rprintfCRLF();</span>
00419 <span class="comment">    rprintf("i = "); rprintfu32(i); rprintfCRLF();</span>
00420 <span class="comment">    rprintf("j = "); rprintfu32(j); rprintfCRLF();</span>
00421 <span class="comment">    rprintf("fatsecs = %d\r\n", fatsecs);</span>
00422 <span class="comment">    */</span>
00423     <span class="comment">// -----------------------------------------------------------------    </span>
00424     <span class="keywordflow">if</span>(fatsecs &lt; 65525)
00425     {
00426         <span class="comment">// FAT16</span>
00427         bpb-&gt;bpbFATsecs = fatsecs;  <span class="comment">// number of sectors per FAT</span>
00428     }
00429     <span class="keywordflow">else</span>
00430     {
00431         <span class="comment">// FAT32</span>
00432         bpb-&gt;bpbFATsecs = 0;            <span class="comment">// real value is in bigFatSecs</span>
00433         bpb-&gt;bpbBigFATsecs = fatsecs;   <span class="comment">// number of sectors per FAT</span>
00434     }
00435     bpb-&gt;bpbMedia = 0xF8;           <span class="comment">// 0xF8 = standard fixed disk</span>
00436     bpb-&gt;bpbSecPerTrack = 63;   
00437     bpb-&gt;bpbHeads = 255;
00438     bpb-&gt;bpbHiddenSecs = 0;
00439     <span class="comment">// BPB for FAT32</span>
00440     bpb-&gt;bpbExtFlags = 0;           <span class="comment">// FATs are mirrored</span>
00441     bpb-&gt;bpbFSVers = FSVERS;
00442 
00443     <span class="comment">// apply bootsector signature</span>
00444     bs-&gt;bsBootSectSig0 = 0x55;
00445     bs-&gt;bsBootSectSig1 = 0xAA;
00446 
00447     <span class="comment">// write bootsector</span>
00448     rprintfProgStrM(<span class="stringliteral">"Writing boot sector\r\n"</span>);
00449     FatFsInfo.devdisk.WriteSector(0, 1, SectorBuffer);
00450 
00451     <span class="comment">// SECOND STAGE</span>
00452     <span class="comment">// initialize the FAT(s) and create the root directory</span>
00453 
00454     <span class="comment">// "remount" the filesystem</span>
00455     rprintfProgStrM(<span class="stringliteral">"Remounting Filesystem...\r\n"</span>);
00456     fatInit(&amp;FatFsInfo.devdisk);
00457     <span class="comment">// clear sector buffer</span>
00458     memset(SectorBuffer, 0, 512);
00459     <span class="comment">// initialize the FATs</span>
00460     rprintfProgStrM(<span class="stringliteral">"Initializing FAT sectors...\r\n"</span>);
00461     <span class="keywordflow">for</span>(i=0; i&lt;(FatFsInfo.NumberOfFats*FatFsInfo.SectorsPerFat); i++)
00462     {
00463         rprintfProgStrM(<span class="stringliteral">"Writing FAT sector: "</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(FatFsInfo.FirstFATSector+i); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'\r'</span>);
00464         FatFsInfo.devdisk.WriteSector(FatFsInfo.FirstFATSector+i, 1, SectorBuffer);
00465     }
00466     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00467 
00468     <span class="comment">// create the root directory</span>
00469     rprintfProgStrM(<span class="stringliteral">"Creating Root Directory...\r\n"</span>);
00470     <span class="comment">// tag root directory cluster as used in FAT</span>
00471     fatWriteClusterValue(FatFsInfo.RootDirStartCluster, CLUST_EOFE);
00472     <span class="comment">// find the starting sector of the root directory</span>
00473     sector = fatClusterToSector(FatFsInfo.RootDirStartCluster);
00474     <span class="comment">// clear sector buffer</span>
00475     memset(SectorBuffer, 0, 512);
00476     <span class="comment">// clear the cluster where the root directory will reside</span>
00477     <span class="keywordflow">for</span>(i=0; i&lt;FatFsInfo.SectorsPerCluster; i++)
00478     {
00479         rprintfProgStrM(<span class="stringliteral">"Writing Root Dir sector: "</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(sector+i); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'\r'</span>);
00480         FatFsInfo.devdisk.WriteSector(sector+i, 1, SectorBuffer);
00481     }
00482     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00483 
00484     <span class="comment">// create volume label entry</span>
00485     rprintfProgStrM(<span class="stringliteral">"Creating Volume Label...\r\n"</span>);
00486     
00487     FileInfo.Attr = ATTR_VOLUME;
00488     FileInfo.Size = 0;
00489     FileInfo.StartCluster = 0;
00490     FileInfo.CreateDate = 0;
00491     FileInfo.CreateTime = 0;
00492 
00493     fatCreateFile(<span class="stringliteral">"MYDISK"</span>, &amp;FileInfo);
00494 
00495     <span class="keywordflow">return</span> 0;
00496 }
00497 
00498 <span class="comment">// change directory into </span>
00499 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatChangeDirectory(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entry)
00500 {
00501     <span class="comment">// get the requested directory entry</span>
00502     <span class="keywordflow">if</span>( fatGetDirEntry(entry) )
00503     {
00504         <span class="comment">// make sure the entry is a directory</span>
00505         <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_DIRECTORY)
00506         {
00507             <span class="comment">// change directories into this directory</span>
00508             <span class="comment">// check to see if we are changing back to root directory</span>
00509             <span class="keywordflow">if</span>(FileInfo.StartCluster)
00510             {
00511                 <span class="comment">// standard change directory</span>
00512                 CurrentDirStartCluster = FileInfo.StartCluster;
00513             }
00514             <span class="keywordflow">else</span>
00515             {
00516                 <span class="comment">// if startCluster pointer is zero,</span>
00517                 <span class="comment">// a change to the root directory is intended</span>
00518                 <span class="comment">// change directory to root</span>
00519                 CurrentDirStartCluster = FatFsInfo.RootDirStartCluster;
00520             }
00521             <span class="comment">// TODO: handle pathname properly for going up a directory</span>
00522             <span class="comment">// set path string</span>
00523             strcat(PathNameBuffer, FileNameBuffer);
00524             strcat(PathNameBuffer, <span class="stringliteral">"\\"</span>);
00525             <span class="comment">// return success</span>
00526             <span class="keywordflow">return</span> TRUE;
00527         }
00528         <span class="keywordflow">else</span>
00529         {
00530             <span class="comment">// not a directory, cannot CD into a file!</span>
00531             <span class="keywordflow">return</span> FALSE;
00532         }
00533     }
00534     <span class="keywordflow">else</span>
00535     {
00536         <span class="comment">// not a valid entry, cannot CD!</span>
00537         <span class="keywordflow">return</span> FALSE;
00538     }
00539 }
00540 
00541 <span class="keywordtype">void</span> fatPrintDirEntry(<span class="keywordtype">void</span>)
00542 {
00543     <span class="comment">// print a formatted dir-style output for most recent file</span>
00544     <span class="comment">// print date</span>
00545     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 2, FALSE, <span class="charliteral">'0'</span>, (FileInfo.CreateDate&amp;DD_MONTH_MASK)&gt;&gt;DD_MONTH_SHIFT );    <span class="comment">// month</span>
00546     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'/'</span>);
00547     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 2, FALSE, <span class="charliteral">'0'</span>, (FileInfo.CreateDate&amp;DD_DAY_MASK)&gt;&gt;DD_DAY_SHIFT );        <span class="comment">// day</span>
00548     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'/'</span>);
00549     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 4, FALSE, <span class="charliteral">'0'</span>, (FileInfo.CreateDate&amp;DD_YEAR_MASK)&gt;&gt;DD_YEAR_SHIFT );  <span class="comment">// year</span>
00550     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00551 
00552     <span class="comment">// print time</span>
00553     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 2, FALSE, <span class="charliteral">'0'</span>, (FileInfo.CreateTime&amp;DT_HOURS_MASK)&gt;&gt;DT_HOURS_SHIFT );    <span class="comment">// month</span>
00554     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">':'</span>);
00555     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 2, FALSE, <span class="charliteral">'0'</span>, (FileInfo.CreateTime&amp;DT_MINUTES_MASK)&gt;&gt;DT_MINUTES_SHIFT );        <span class="comment">// day</span>
00556     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">':'</span>);
00557     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 2, FALSE, <span class="charliteral">'0'</span>, 2*(FileInfo.CreateTime&amp;DT_2SECONDS_MASK)&gt;&gt;DT_2SECONDS_SHIFT );    <span class="comment">// seconds</span>
00558     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00559 
00560     <span class="comment">// print attributes</span>
00561     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_VOLUME)     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'V'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00562     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_DIRECTORY)  <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'D'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00563     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_READONLY)   <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'R'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00564     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_HIDDEN)     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'H'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00565     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_SYSTEM)     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'S'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00566     <span class="keywordflow">if</span>(FileInfo.Attr &amp; ATTR_ARCHIVE)    <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'A'</span>); <span class="keywordflow">else</span> <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">'-'</span>);
00567     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00568 
00569     <span class="comment">// print filesize</span>
00570     <a class="code" href="group__rprintf.html#ga10">rprintfNum</a>(10, 8, FALSE, <span class="charliteral">' '</span>, FileInfo.Size);   <span class="comment">// filesize</span>
00571     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00572 
00573     <span class="comment">// print filename</span>
00574     <a class="code" href="group__rprintf.html#ga2">rprintfStr</a>(FileNameBuffer);
00575 }
00576 
00577 <span class="keywordtype">void</span> fatDumpDirSlot(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> slot)
00578 {
00579     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00580     
00581     <span class="comment">// load correct sector</span>
00582     sector = fatClusterToSector(CurrentDirStartCluster);
00583     sector += slot/DIRENTRIES_PER_SECTOR;
00584 
00585     rprintf(<span class="stringliteral">"CurrentDirStartCluster:"</span>);
00586     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(CurrentDirStartCluster);
00587     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00588     rprintf(<span class="stringliteral">"Sector access         :"</span>);
00589     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(sector);
00590     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00591         
00592     <span class="comment">// print the entry as a hex table</span>
00593     <a class="code" href="debug_8c.html#a0">debugPrintHexTable</a>(32, SectorBuffer+(slot&lt;&lt;5) );
00594 }
00595 
00596 FileInfo_t* fatGetFileInfo(<span class="keywordtype">void</span>)
00597 {
00598     <span class="keywordflow">return</span> &amp;FileInfo;
00599 }
00600 
00601 <span class="comment">// return the size of the last directory entry</span>
00602 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetFilesize(<span class="keywordtype">void</span>)
00603 {
00604     <span class="keywordflow">return</span> FileInfo.Size;
00605 }
00606 
00607 <span class="comment">// return the long name of the last directory entry</span>
00608 <span class="keywordtype">char</span>* fatGetFilename(<span class="keywordtype">void</span>)
00609 {   
00610     <span class="keywordflow">return</span> FileNameBuffer;
00611 }
00612 
00613 <span class="comment">// return the directory of the last directory entry</span>
00614 <span class="keywordtype">char</span>* fatGetDirname(<span class="keywordtype">void</span>)
00615 {   
00616     <span class="keywordflow">return</span> PathNameBuffer;
00617 }
00618 
00619 <span class="comment">// load a cluster-full of data</span>
00620 <span class="keywordtype">void</span> fatLoadCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer)
00621 {
00622     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00623     <span class="comment">// read cluster</span>
00624     <span class="comment">//while ( ataReadSectors( FatFsInfo.disk, clust2sect(cluster), SectorsPerCluster, buffer) != 0);</span>
00625     <span class="keywordflow">for</span>(i=0; i&lt;FatFsInfo.SectorsPerCluster; i++)
00626     {
00627         FatFsInfo.devdisk.ReadSector(fatClusterToSector(cluster)+i, 1, buffer+(i&lt;&lt;9) );
00628         <span class="comment">// temporary fix for wierd misaligned cluster problem</span>
00629         <span class="comment">// (only when using FAT16?)</span>
00630 <span class="comment">//      ataReadSectors(FatFsInfo.disk, fatClustToSect(cluster+8)+i, 1, buffer+(i&lt;&lt;9) );</span>
00631     }
00632 }
00633 
00634 
00635 <span class="comment">// find next cluster in the FAT chain</span>
00636 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatNextCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster)
00637 {
00638     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nextCluster;
00639 
00640     <span class="comment">// read the nextCluster value</span>
00641     nextCluster = fatClusterValue(cluster);
00642 
00643     <span class="comment">// check to see if we're at the end of the chain</span>
00644     <span class="keywordflow">if</span> (nextCluster == (CLUST_EOFE &amp; FatFsInfo.FatMask))
00645         nextCluster = 0;
00646 
00647 <span class="preprocessor">#ifdef DEBUG_FAT</span>
00648 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"&gt;"</span>);
00649     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(nextCluster);
00650     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00651 <span class="preprocessor">#endif</span>
00652 <span class="preprocessor"></span>    
00653     <span class="keywordflow">return</span> nextCluster;
00654 }
00655 
00656 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatNextFreeCluster(<span class="keywordtype">void</span>)
00657 {
00658     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster;
00659 
00660     <span class="comment">// start at beginning of fat</span>
00661     cluster = FatFsInfo.RootDirStartCluster;
00662 
00663     <span class="keywordflow">while</span>( fatClusterValue(cluster) != CLUST_FREE)
00664     {
00665         <span class="comment">// increment to next cluster</span>
00666         cluster++;
00667     }
00668     <span class="keywordflow">return</span> cluster;
00669 }
00670 
00671 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatClusterValue(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster)
00672 {
00673     <span class="comment">// return the value of the FAT entry for the requested cluster</span>
00674     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer;
00675     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatOffset;
00676     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00677     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
00678     
00679     <span class="comment">// get fat offset in bytes</span>
00680     <span class="keywordflow">if</span>(FatFsInfo.Fat32Enabled)
00681     {
00682         <span class="comment">// four FAT bytes (32 bits) for every cluster</span>
00683         fatOffset = cluster &lt;&lt; 2;
00684     }
00685     <span class="keywordflow">else</span>
00686     {
00687         <span class="comment">// two FAT bytes (16 bits) for every cluster</span>
00688         fatOffset = cluster &lt;&lt; 1;
00689     }
00690     
00691     <span class="comment">// calculate the FAT sector that we're interested in</span>
00692     sector = (fatOffset / FatFsInfo.BytesPerSector);
00693     <span class="comment">// calculate offset of the our entry within that FAT sector</span>
00694     offset = fatOffset % FatFsInfo.BytesPerSector;
00695     <span class="comment">// get the fat sector</span>
00696     buffer = fatGetFatSector( sector );
00697     <span class="comment">// return the fat value of the cluster</span>
00698     <span class="comment">// NOTE: don't be fooled by the UNSIGNED LONG,</span>
00699     <span class="comment">// this should nominally work for both FAT16 and FAT32</span>
00700     <span class="comment">// FAT16 -&gt; offset will be on 2-byte boundary</span>
00701     <span class="comment">// FAT32 -&gt; offset will be on 4-byte boundary</span>
00702     <span class="keywordflow">return</span> (*((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) &amp;buffer[offset])) &amp; FatFsInfo.FatMask;
00703 }
00704 
00705 <span class="keywordtype">int</span> fatWriteClusterValue(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster, <span class="keywordtype">unsigned</span> value)
00706 {
00707     <span class="comment">// write the value of the FAT entry for the requested cluster</span>
00708     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer;
00709     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatOffset;
00710     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatSector;
00711     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
00712     
00713     <span class="comment">// get fat offset in bytes</span>
00714     <span class="keywordflow">if</span>(FatFsInfo.Fat32Enabled)
00715     {
00716         <span class="comment">// four FAT bytes (32 bits) for every cluster</span>
00717         fatOffset = cluster &lt;&lt; 2;
00718     }
00719     <span class="keywordflow">else</span>
00720     {
00721         <span class="comment">// two FAT bytes (16 bits) for every cluster</span>
00722         fatOffset = cluster &lt;&lt; 1;
00723     }
00724     
00725     <span class="comment">// calculate the FAT sector that we're interested in</span>
00726     fatSector = (fatOffset / FatFsInfo.BytesPerSector);
00727     <span class="comment">// calculate offset of the our entry within that FAT sector</span>
00728     offset = fatOffset % FatFsInfo.BytesPerSector;
00729     <span class="comment">// get the fat sector</span>
00730     buffer = fatGetFatSector( fatSector );
00731     <span class="comment">// write the fat value of the cluster</span>
00732     <span class="comment">// NOTE: don't be fooled by the UNSIGNED LONG,</span>
00733     <span class="comment">// this should nominally work for both FAT16 and FAT32</span>
00734     <span class="comment">// FAT16 -&gt; offset will be on 2-byte boundary</span>
00735     <span class="comment">// FAT32 -&gt; offset will be on 4-byte boundary</span>
00736     *((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) &amp;buffer[offset]) = (value &amp; FatFsInfo.FatMask);
00737 
00738     <span class="comment">// flush to disk</span>
00739     FatFsInfo.devdisk.WriteSector(FatFsInfo.FirstFATSector+fatSector, 1, buffer);
00740 
00741     <span class="keywordflow">return</span> 0;
00742 }
00743 
00744 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* fatGetFatSector(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatsector)
00745 {
00746     <span class="comment">// NOTE: fatsector is referenced to the beginning of the fat</span>
00747     <span class="comment">// eg. fatsector=0 is the first sector of the first FAT</span>
00748 
00749     <span class="comment">// the idea here is to make a generic FAT loading function that</span>
00750     <span class="comment">// can later be used to cache not one but multiple FAT sectors that</span>
00751     <span class="comment">// have been recently used</span>
00752 
00753     <span class="comment">// if we don't already have this FAT chunk loaded, go get it</span>
00754     <span class="keywordflow">if</span>(fatsector != FatFsInfo.FatInCache)
00755     {
00756         <span class="comment">// read sector of FAT table</span>
00757         <span class="keywordflow">while</span> (FatFsInfo.devdisk.ReadSector(FatFsInfo.FirstFATSector+fatsector, 1, FatCacheBuffer) != 0);
00758         FatFsInfo.FatInCache = fatsector;
00759     }
00760     <span class="keywordflow">return</span> FatCacheBuffer;
00761 }
00762 
00763 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatClusterToSector(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster)
00764 {
00765     <span class="keywordflow">return</span> ((cluster-2) * FatFsInfo.SectorsPerCluster) + FatFsInfo.FirstDataSector;
00766 }
00767 
00768 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fatClusterSize(<span class="keywordtype">void</span>)
00769 {
00770     <span class="comment">// return the number of sectors in a disk cluster</span>
00771     <span class="keywordflow">return</span> FatFsInfo.SectorsPerCluster;
00772 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:59 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
