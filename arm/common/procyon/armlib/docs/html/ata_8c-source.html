<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: ata.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ata.c</h1><a href="ata_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ata.c \brief IDE-ATA hard disk interface driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ata.c'</span>
00005 <span class="comment">// Title        : IDE-ATA interface driver for hard disks</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/22/2000</span>
00008 <span class="comment">// Revised      : 4/2/2004</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : any</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "timer.h"</span>
00024 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="atadev_8h.html">atadev.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="ata_8h.html">ata.h</a>"</span>
00029 
00030 <span class="comment">// global variables</span>
00031 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> AtaBuffer[0x200];
00032 
00033 <span class="comment">// functions</span>
00034 <span class="keywordtype">void</span> ataInit(DiskInfo_t* disk, DevBlock_t ataif, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> driveno)
00035 {
00036     <span class="comment">// set drive interface </span>
00037     disk-&gt;ataif = ataif;    
00038     <span class="comment">// set drive number (0=master, 1=slave)</span>
00039     disk-&gt;driveno = driveno;
00040     <span class="comment">// initialize interface</span>
00041     disk-&gt;ataif.Init();
00042 }
00043 
00044 <span class="keywordtype">void</span> ataDriveInit(DiskInfo_t* disk)
00045 {
00046     u08 i;
00047     <span class="comment">//unsigned char* buffer = (unsigned char*)SECTOR_BUFFER_ADDR;</span>
00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer = AtaBuffer;
00049 
00050 <span class="comment">//  rprintfProgStrM("Init      :"); rprintfu32((unsigned int)disk-&gt;ataif.Init); rprintfCRLF();</span>
00051 <span class="comment">//  rprintfProgStrM("ReadReg   :"); rprintfu32((unsigned int)disk-&gt;ataif.ReadReg); rprintfCRLF();</span>
00052 <span class="comment">//  rprintfProgStrM("WriteReg  :"); rprintfu32((unsigned int)disk-&gt;ataif.WriteReg); rprintfCRLF();</span>
00053 <span class="comment">//  rprintfProgStrM("ReadBlock :"); rprintfu32((unsigned int)disk-&gt;ataif.ReadBlock); rprintfCRLF();</span>
00054 <span class="comment">//  rprintfProgStrM("WriteBlock:"); rprintfu32((unsigned int)disk-&gt;ataif.WriteBlock); rprintfCRLF();</span>
00055 
00056     <span class="comment">// read drive identity</span>
00057     rprintfProgStrM(<span class="stringliteral">"\r\nScanning IDE interface...\r\n"</span>);
00058     <span class="comment">// Wait for drive to be ready</span>
00059     ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00060     <span class="comment">// issue identify command</span>
00061     disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, 0xEC);
00062     <span class="comment">// wait for drive to request data transfer</span>
00063     ataStatusWait(disk, ATA_SR_DRQ, ATA_SR_DRQ);
00064     timerPause(20);
00065     <span class="comment">// read in the data</span>
00066     disk-&gt;ataif.ReadBlock(buffer, 512);
00067 
00068     <span class="comment">// set local drive info parameters</span>
00069     disk-&gt;cylinders =       *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*) buffer) + ATA_IDENT_CYLINDERS );
00070     disk-&gt;heads =           *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*) buffer) + ATA_IDENT_HEADS );
00071     disk-&gt;sectors =         *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*) buffer) + ATA_IDENT_SECTORS );
00072     disk-&gt;LBAsupport =      *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*) buffer) + ATA_IDENT_FIELDVALID );
00073     disk-&gt;sizeinsectors =   *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) (buffer + ATA_IDENT_LBASECTORS*2)) );
00074 
00075     <span class="comment">// copy model string</span>
00076     <span class="keywordflow">for</span>(i=0; i&lt;40; i+=2)
00077     {
00078         <span class="comment">// correct for byte order</span>
00079         disk-&gt;model[i  ] = buffer[(ATA_IDENT_MODEL*2) + i + 1];
00080         disk-&gt;model[i+1] = buffer[(ATA_IDENT_MODEL*2) + i    ];
00081     }
00082     <span class="comment">// terminate string</span>
00083     disk-&gt;model[40] = 0;
00084 
00085     <span class="comment">// process and print info</span>
00086     <span class="keywordflow">if</span>(disk-&gt;LBAsupport)
00087     {
00088         <span class="comment">// LBA support</span>
00089         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, disk-&gt;sizeinsectors/(1000000/512) );
00090         rprintfProgStrM(<span class="stringliteral">"LBA mode -- MODEL: "</span>);
00091     }
00092     <span class="keywordflow">else</span>
00093     {
00094         <span class="comment">// CHS, no LBA support</span>
00095         <span class="comment">// calculate drive size</span>
00096         disk-&gt;sizeinsectors = (<span class="keywordtype">unsigned</span> long) disk-&gt;cylinders*disk-&gt;heads*disk-&gt;sectors;
00097         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, disk-&gt;sizeinsectors/(1000000/512) );
00098         rprintf(<span class="stringliteral">"CHS mode C=%d H=%d S=%d -- MODEL: "</span>, disk-&gt;cylinders, disk-&gt;heads, disk-&gt;sectors );
00099     }
00100     <span class="comment">// print model information  </span>
00101     <a class="code" href="group__rprintf.html#ga2">rprintfStr</a>(disk-&gt;model); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00102 
00103     <span class="comment">// initialize local disk parameters</span>
00104     <span class="comment">//ataDriveInfo.cylinders = ATA_DISKPARM_CLYS;</span>
00105     <span class="comment">//ataDriveInfo.heads = ATA_DISKPARM_HEADS;</span>
00106     <span class="comment">//ataDriveInfo.sectors = ATA_DISKPARM_SECTORS;</span>
00107 }
00108 
00109 <span class="keywordtype">void</span> ataDiskErr(DiskInfo_t* disk)
00110 {
00111     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b;
00112 
00113     b = disk-&gt;ataif.ReadReg(ATA_REG_ERROR); 
00114     rprintfProgStrM(<span class="stringliteral">"ATA Error: "</span>); 
00115     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(b); 
00116     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00117 }
00118 
00119 <span class="keywordtype">void</span> ataSetDrivePowerMode(DiskInfo_t* disk, u08 mode, u08 timeout)
00120 {
00121     <span class="comment">// select drive</span>
00122     ataDriveSelect(disk);
00123     <span class="comment">// Wait for drive to be ready</span>
00124     ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00125 
00126     <span class="comment">// set mode</span>
00127     <span class="keywordflow">switch</span>(mode)
00128     {
00129     <span class="keywordflow">case</span> ATA_DISKMODE_SPINDOWN:
00130         disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, ATA_CMD_SPINDOWN);
00131         <span class="keywordflow">break</span>;
00132     <span class="keywordflow">case</span> ATA_DISKMODE_SPINUP:
00133         disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, ATA_CMD_SPINUP);
00134         <span class="keywordflow">break</span>;
00135     <span class="keywordflow">case</span> ATA_DISKMODE_SETTIMEOUT:
00136         disk-&gt;ataif.WriteReg(ATA_REG_SECCOUNT, timeout);
00137         disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, ATA_CMD_IDLE_5SU);
00138         <span class="keywordflow">break</span>;
00139     <span class="keywordflow">case</span> ATA_DISKMODE_SLEEP:
00140         disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, ATA_CMD_SLEEP);
00141         <span class="keywordflow">break</span>;
00142     <span class="keywordflow">default</span>:
00143         <span class="keywordflow">break</span>;
00144     }
00145 }
00146 
00147 u08 ataStatusWait(DiskInfo_t* disk, u08 mask, u08 waitStatus)
00148 {
00149     <span class="keyword">register</span> u08 status;
00150 
00151     delay(100);
00152 
00153     <span class="comment">// wait for desired status</span>
00154     <span class="keywordflow">while</span>( ((status = disk-&gt;ataif.ReadReg(ATA_REG_CMDSTATUS1)) &amp; mask) == waitStatus );
00155 
00156     <span class="keywordflow">return</span> status;
00157 }
00158 
00159 
00160 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsCHS(    DiskInfo_t* disk, 
00161                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00162                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00163                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00164                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00165                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00166 {
00167     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00168 
00169     <span class="comment">// Wait for drive to be ready</span>
00170     temp = ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00171 
00172     <span class="comment">// Prepare parameters...</span>
00173     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0xA0+(disk-&gt;driveno ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00174     disk-&gt;ataif.WriteReg(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00175     disk-&gt;ataif.WriteReg(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00176     disk-&gt;ataif.WriteReg(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00177     disk-&gt;ataif.WriteReg(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00178 
00179     <span class="comment">// Issue read sector command...</span>
00180     disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, 0x21);
00181 
00182     <span class="comment">// Wait for drive to be ready</span>
00183     temp = ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00184 
00185     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00186     {
00187         rprintfProgStrM(<span class="stringliteral">"RD ERR\r\n"</span>);
00188         <span class="keywordflow">return</span> 1;
00189     }
00190 
00191     <span class="comment">// Wait for drive to request data transfer</span>
00192     ataStatusWait(disk, ATA_SR_DRQ, 0);
00193 
00194     <span class="comment">// read data from drive</span>
00195     disk-&gt;ataif.ReadBlock(Buffer, 512*numsectors);
00196 
00197     <span class="comment">// Return the error bit from the status register...</span>
00198     temp = disk-&gt;ataif.ReadReg(ATA_REG_CMDSTATUS1); <span class="comment">// read status register</span>
00199 
00200     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00201 }
00202 
00203 
00204 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsCHS(   DiskInfo_t* disk,
00205                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00206                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00207                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00208                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00209                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00210 {
00211     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00212 
00213     <span class="comment">// Wait for drive to be ready</span>
00214     temp = ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00215 
00216     <span class="comment">// Prepare parameters...</span>
00217     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0xA0+(disk-&gt;driveno ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00218     disk-&gt;ataif.WriteReg(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00219     disk-&gt;ataif.WriteReg(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00220     disk-&gt;ataif.WriteReg(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00221     disk-&gt;ataif.WriteReg(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00222 
00223     <span class="comment">// Issue write sector command</span>
00224     disk-&gt;ataif.WriteReg(ATA_REG_CMDSTATUS1, 0x31);
00225 
00226     <span class="comment">//delay(100);</span>
00227 
00228     <span class="comment">// Wait for drive to request data transfer</span>
00229     ataStatusWait(disk, ATA_SR_DRQ, 0);
00230 
00231     <span class="comment">// write data to drive</span>
00232     disk-&gt;ataif.WriteBlock(Buffer, 512*numsectors);
00233     
00234     <span class="comment">// Wait for drive to finish write</span>
00235     temp = ataStatusWait(disk, ATA_SR_BSY, ATA_SR_BSY);
00236 
00237     <span class="comment">// check for errors</span>
00238     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00239     {
00240         rprintfProgStrM(<span class="stringliteral">"WR ERR\r\n"</span>);
00241         <span class="keywordflow">return</span> 1;
00242     }
00243 
00244     <span class="comment">// Return the error bit from the status register...</span>
00245     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00246 }
00247 
00248 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsLBA(    DiskInfo_t* disk,
00249                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00250                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00251                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00252 {
00253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00254     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00255 
00256 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00257 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"ATA LBA read "</span>);
00258     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00259     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(numsectors); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00260     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00261     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00262 <span class="preprocessor">#endif</span>
00263 <span class="preprocessor"></span>
00264     sect = (int) ( lba &amp; 0x000000ffL );
00265     lba = lba &gt;&gt; 8;
00266     cyl = (int) ( lba &amp; 0x0000ffff );
00267     lba = lba &gt;&gt; 16;
00268     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00269 
00270     temp = ataReadSectorsCHS( disk, head, cyl, sect, numsectors, Buffer );
00271 
00272     <span class="keywordflow">if</span>(temp)
00273         ataDiskErr(disk);
00274     <span class="keywordflow">return</span> temp;
00275 }
00276 
00277 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsLBA(   DiskInfo_t* disk,
00278                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00279                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00280                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00281 {
00282     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00283     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00284 
00285 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00286 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"ATA LBA write "</span>);
00287     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00288     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(numsectors); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00289     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00290     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00291 <span class="preprocessor">#endif</span>
00292 <span class="preprocessor"></span>
00293     sect = (int) ( lba &amp; 0x000000ffL );
00294     lba = lba &gt;&gt; 8;
00295     cyl = (int) ( lba &amp; 0x0000ffff );
00296     lba = lba &gt;&gt; 16;
00297     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00298 
00299     temp = ataWriteSectorsCHS( disk, head, cyl, sect, numsectors, Buffer );
00300 
00301     <span class="keywordflow">if</span>(temp)
00302         ataDiskErr(disk);
00303     <span class="keywordflow">return</span> temp;
00304 }                                   
00305 
00306 
00307 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectors(   DiskInfo_t* disk,
00308                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00309                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00310                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00311 {
00312     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00313     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00314 
00315     <span class="comment">// check if drive supports native LBA mode</span>
00316     <span class="keywordflow">if</span>(disk-&gt;LBAsupport)
00317     {
00318         <span class="comment">// drive supports using native LBA</span>
00319         temp = ataReadSectorsLBA(disk, lba, numsectors, Buffer);
00320     }
00321     <span class="keywordflow">else</span>
00322     {
00323         <span class="comment">// drive required CHS access</span>
00324 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00325 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00326             rprintfProgStrM(<span class="stringliteral">"ATA LBA for CHS read: "</span>);
00327             rprintfProgStrM(<span class="stringliteral">"LBA="</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00328 <span class="preprocessor">        #endif</span>
00329 <span class="preprocessor"></span>
00330         <span class="comment">// convert LBA to pseudo CHS</span>
00331         <span class="comment">// remember to offset the sector count by one</span>
00332         sect = (u08) (lba % disk-&gt;sectors)+1;
00333         lba = lba / disk-&gt;sectors;
00334         head = (u08) (lba % disk-&gt;heads);
00335         lba = lba / disk-&gt;heads;
00336         cyl = (u16) lba;
00337 
00338 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00339 <span class="preprocessor"></span>            rprintfProgStrM(<span class="stringliteral">"C:H:S="</span>);
00340             <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cyl); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">':'</span>);
00341             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(head); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">':'</span>);
00342             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(sect); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00343 <span class="preprocessor">        #endif</span>
00344 <span class="preprocessor"></span>
00345         temp = ataReadSectorsCHS( disk, head, cyl, sect, numsectors, Buffer );
00346     }
00347 
00348     <span class="keywordflow">if</span>(temp)
00349         ataDiskErr(disk);
00350     <span class="keywordflow">return</span> temp;
00351 }
00352 
00353 
00354 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectors(  DiskInfo_t* disk,
00355                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00356                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00357                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00358 {
00359     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00360     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00361 
00362     <span class="comment">// check if drive supports native LBA mode</span>
00363     <span class="keywordflow">if</span>(disk-&gt;LBAsupport)
00364     {
00365         <span class="comment">// drive supports using native LBA</span>
00366         temp = ataWriteSectorsLBA(disk, lba, numsectors, Buffer);
00367     }
00368     <span class="keywordflow">else</span>
00369     {
00370         <span class="comment">// drive required CHS access</span>
00371 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00372 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00373             rprintfProgStrM(<span class="stringliteral">"ATA LBA for CHS write: "</span>);
00374             rprintfProgStrM(<span class="stringliteral">"LBA="</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00375 <span class="preprocessor">        #endif</span>
00376 <span class="preprocessor"></span>
00377         <span class="comment">// convert LBA to pseudo CHS</span>
00378         <span class="comment">// remember to offset the sector count by one</span>
00379         sect = (u08) (lba % disk-&gt;sectors)+1;
00380         lba = lba / disk-&gt;sectors;
00381         head = (u08) (lba % disk-&gt;heads);
00382         lba = lba / disk-&gt;heads;
00383         cyl = (u16) lba;
00384 
00385 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00386 <span class="preprocessor"></span>            rprintfProgStrM(<span class="stringliteral">"C:H:S="</span>);
00387             <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cyl); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00388             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(head); <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00389             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(sect); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00390 <span class="preprocessor">        #endif</span>
00391 <span class="preprocessor"></span>
00392         temp = ataWriteSectorsCHS( disk, head, cyl, sect, numsectors, Buffer );
00393     }
00394 
00395     <span class="keywordflow">if</span>(temp)
00396         ataDiskErr(disk);
00397     <span class="keywordflow">return</span> temp;
00398 }                                   
00399 
00400 <span class="keywordtype">void</span> ataDriveSelect(DiskInfo_t* disk)
00401 {
00402     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0xA0+(disk-&gt;driveno ? 0x10:00)); <span class="comment">// Drive selection</span>
00403 }
00404 
00405 <span class="keywordtype">void</span> ataShowRegisters(DiskInfo_t* disk) 
00406 { 
00407     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0xA0 + (disk-&gt;driveno ? 0x10:0x00)); <span class="comment">// Select drive</span>
00408     
00409     rprintfProgStrM(<span class="stringliteral">"R0: DATA     = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_DATA     ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00410     rprintfProgStrM(<span class="stringliteral">"R1: ERROR    = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_ERROR    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00411     rprintfProgStrM(<span class="stringliteral">"R2: SECT CNT = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_SECCOUNT));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00412     rprintfProgStrM(<span class="stringliteral">"R3: SECT NUM = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_STARTSEC));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00413     rprintfProgStrM(<span class="stringliteral">"R4: CYL LOW  = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_CYLLO    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00414     rprintfProgStrM(<span class="stringliteral">"R5: CYL HIGH = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_CYLHI    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00415     rprintfProgStrM(<span class="stringliteral">"R6: HEAD/DEV = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_HDDEVSEL));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00416     rprintfProgStrM(<span class="stringliteral">"R7: CMD/STA  = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(disk-&gt;ataif.ReadReg(ATA_REG_CMDSTATUS1));    rprintfProgStrM(<span class="stringliteral">"\r\n"</span>);
00417 }
00418 
00419 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataSWReset(DiskInfo_t* disk)
00420 {
00421     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0x06);   <span class="comment">// SRST and nIEN bits</span>
00422     delay(10);  <span class="comment">// 10uS delay</span>
00423     disk-&gt;ataif.WriteReg(ATA_REG_HDDEVSEL, 0x02);   <span class="comment">// nIEN bits</span>
00424     delay(10);  <span class="comment">// 10uS delay</span>
00425    
00426     <span class="keywordflow">while</span>( (disk-&gt;ataif.ReadReg(ATA_REG_CMDSTATUS1) &amp; 0xC0) != 0x40 ); <span class="comment">// Wait for DRDY and not BSY</span>
00427     
00428     <span class="keywordflow">return</span> disk-&gt;ataif.ReadReg(ATA_REG_CMDSTATUS1) + disk-&gt;ataif.ReadReg(ATA_REG_ERROR);
00429 }
00430 
00431 <span class="comment">/*</span>
00432 <span class="comment">unsigned char ATA_Idle(unsigned char Drive)</span>
00433 <span class="comment">{</span>
00434 <span class="comment"></span>
00435 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (Drive ? 0x10:0x00)); // Select drive</span>
00436 <span class="comment">  WriteBYTE(CMD,7, 0xE1);</span>
00437 <span class="comment"></span>
00438 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40); // Wait for DRDY &amp; NOT BUSY </span>
00439 <span class="comment"></span>
00440 <span class="comment">  // Return the error register...</span>
00441 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00442 <span class="comment">}</span>
00443 <span class="comment">*/</span>
00444 <span class="comment">//----------------------------------------------------------------------------</span>
00445 <span class="comment">// Set drive mode (STANDBY, IDLE)</span>
00446 <span class="comment">//----------------------------------------------------------------------------</span>
00447 <span class="comment">/*#define STANDBY 0</span>
00448 <span class="comment">#define IDLE    1</span>
00449 <span class="comment">#define SLEEP   2 </span>
00450 <span class="comment">*/</span> 
00451 
00452 <span class="comment">/*</span>
00453 <span class="comment">unsigned char SetMode(unsigned char DriveNo, unsigned char Mode, unsigned char PwrDown) </span>
00454 <span class="comment">{</span>
00455 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (DriveNo ? 0x10:0x00)); // Select drive</span>
00456 <span class="comment">  WriteBYTE(CMD, 2, (PwrDown ? 0x01:0x00)); // Enable automatic power down</span>
00457 <span class="comment">  switch (Mode) </span>
00458 <span class="comment">  {</span>
00459 <span class="comment">    case STANDBY: WriteBYTE(CMD,7, 0xE2); break;</span>
00460 <span class="comment">    case IDLE:    WriteBYTE(CMD,7, 0xE3); break;</span>
00461 <span class="comment">    // NOTE: To recover from sleep, either issue a soft or hardware reset !</span>
00462 <span class="comment">    // (But not on all drives, f.ex seagate ST3655A it's not nessecary to reset</span>
00463 <span class="comment">    // but only to go in Idle mode, But on a Conner CFA170A it's nessecary with</span>
00464 <span class="comment">    // a reset)</span>
00465 <span class="comment">    case SLEEP:   WriteBYTE(CMD,7, 0xE6); break;</span>
00466 <span class="comment">  }</span>
00467 <span class="comment">  Timer10mSec=10000;</span>
00468 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40 &amp;&amp; Timer10mSec); // Wait for DRDY &amp; NOT BUSY </span>
00469 <span class="comment">  if (Timer10mSec==0) return 0xFF;                       //   or timeout</span>
00470 <span class="comment"> </span>
00471 <span class="comment">  // Return the error register...</span>
00472 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00473 <span class="comment">}</span>
00474 <span class="comment"></span>
00475 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
