<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: arch/lpc2000/i2c.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">arch</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">lpc2000</a></div>
<h1>i2c.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file i2c.c \brief I2C interface using Philips LPC internal I2C hardware. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'i2c.c'</span>
00005 <span class="comment">// Title        : I2C interface using Philips LPC internal I2C hardware</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004</span>
00007 <span class="comment">// Created      : 2004.05.05</span>
00008 <span class="comment">// Revised      : 2004.07.12</span>
00009 <span class="comment">// Version      : 0.9</span>
00010 <span class="comment">// Target MCU   : ARM, Philips LPC2100-series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description : I2C (pronounced "eye-squared-see") is a two-wire bidirectional</span>
00014 <span class="comment">//      network designed for easy transfer of information between a wide variety</span>
00015 <span class="comment">//      of intelligent devices.  Many of the Atmel AVR series processors have</span>
00016 <span class="comment">//      hardware support for transmitting and receiving using an I2C-type bus.</span>
00017 <span class="comment">//      In addition to the AVRs, there are thousands of other parts made by</span>
00018 <span class="comment">//      manufacturers like Philips, Maxim, National, TI, etc that use I2C as</span>
00019 <span class="comment">//      their primary means of communication and control.  Common device types</span>
00020 <span class="comment">//      are A/D &amp; D/A converters, temp sensors, intelligent battery monitors,</span>
00021 <span class="comment">//      MP3 decoder chips, EEPROM chips, multiplexing switches, etc.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">//      I2C uses only two wires (SDA and SCL) to communicate bidirectionally</span>
00024 <span class="comment">//      between devices.  I2C is a multidrop network, meaning that you can have</span>
00025 <span class="comment">//      several devices on a single bus.  Because I2C uses a 7-bit number to</span>
00026 <span class="comment">//      identify which device it wants to talk to, you cannot have more than</span>
00027 <span class="comment">//      127 devices on a single bus.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">//      I2C ordinarily requires two 4.7K pull-up resistors to power (one each on</span>
00030 <span class="comment">//      SDA and SCL), but for small numbers of devices (maybe 1-4), it is enough</span>
00031 <span class="comment">//      to activate the internal pull-up resistors in the AVR processor.  To do</span>
00032 <span class="comment">//      this, set the port pins, which correspond to the I2C pins SDA/SCL, high.</span>
00033 <span class="comment">//      For example, on the mega163, sbi(PORTC, 0); sbi(PORTC, 1);.</span>
00034 <span class="comment">//</span>
00035 <span class="comment">//      For complete information about I2C, see the Philips Semiconductor</span>
00036 <span class="comment">//      website.  They created I2C and have the largest family of devices that</span>
00037 <span class="comment">//      work with I2C.</span>
00038 <span class="comment">//</span>
00039 <span class="comment">// Note: Many manufacturers market I2C bus devices under a different or generic</span>
00040 <span class="comment">//      bus name like "Two-Wire Interface".  This is because Philips still holds</span>
00041 <span class="comment">//      "I2C" as a trademark.  For example, SMBus and SMBus devices are hardware</span>
00042 <span class="comment">//      compatible and closely related to I2C.  They can be directly connected</span>
00043 <span class="comment">//      to an I2C bus along with other I2C devices are are generally accessed in</span>
00044 <span class="comment">//      the same way as I2C devices.  SMBus is often found on modern motherboards</span>
00045 <span class="comment">//      for temp sensing and other low-level control tasks.</span>
00046 <span class="comment">//</span>
00047 <span class="comment">// This code is distributed under the GNU Public License</span>
00048 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//*****************************************************************************</span>
00051 
00052 <span class="preprocessor">#include "lpc2000.h"</span>
00053 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00054 <span class="preprocessor">#include "timer.h"</span>
00055 <span class="preprocessor">#include "i2c.h"</span>
00056 
<a name="l00057"></a><a class="code" href="group__i2c__at91.html#ga0">00057</a> <span class="keywordtype">void</span> <a class="code" href="group__i2c__at91.html#ga0">i2cInit</a>(<span class="keywordtype">void</span>)
00058 {
00059     <span class="comment">// setup SCL pin P02</span>
00060     PINSEL0 &amp;= ~(3&lt;&lt;4);
00061     PINSEL0 |=   1&lt;&lt;4;
00062     <span class="comment">// setup SDA pin P03</span>
00063     PINSEL0 &amp;= ~(3&lt;&lt;6);
00064     PINSEL0 |=   1&lt;&lt;6;
00065 
00066     <span class="comment">// set default bitrate of 100KHz</span>
00067     i2cSetBitrate(400);
00068 
00069     <span class="comment">// disable and reset interface</span>
00070     I2CONCLR = 0xFF;
00071     delay(10);
00072 
00073     <span class="comment">// enable interface</span>
00074     I2CONSET = BIT(I2CON_I2EN);
00075 }
00076 <span class="comment">/*</span>
00077 <span class="comment">void InitialiseI2C(void)</span>
00078 <span class="comment">{</span>
00079 <span class="comment"></span>
00080 <span class="comment">REG(I2C_I2SCLL) = 0x18;</span>
00081 <span class="comment"></span>
00082 <span class="comment">REG(I2C_I2SCLH) = 0x18;</span>
00083 <span class="comment"></span>
00084 <span class="comment">REG(I2C_I2CONCLR) = 0xFF;</span>
00085 <span class="comment"></span>
00086 <span class="comment">// Set pinouts as scl and sda</span>
00087 <span class="comment">REG(PCB_PINSEL0) = 0x50;</span>
00088 <span class="comment"></span>
00089 <span class="comment">REG(I2C_I2CONSET) = 0x40;</span>
00090 <span class="comment">delay(10);</span>
00091 <span class="comment">REG(I2C_I2CONSET) = 0x64;</span>
00092 <span class="comment"></span>
00093 <span class="comment">REG(I2C_I2DAT) = 0x42;</span>
00094 <span class="comment"></span>
00095 <span class="comment">REG(I2C_I2CONCLR) = 0x08;</span>
00096 <span class="comment"></span>
00097 <span class="comment">REG(I2C_I2CONCLR) = 0x20;</span>
00098 <span class="comment"></span>
00099 <span class="comment">}</span>
00100 <span class="comment">*/</span>
00101 
00102 <span class="keywordtype">void</span> i2cSetBitrate(u16 bitrateDiv)
00103 {
00104     <span class="comment">// @60MHz and VPB=2, set to 75 for 400KHz</span>
00105     <span class="comment">// @60MHz and VPB=2, set to 400 for 75KHz</span>
00106     <span class="comment">// set equal high and low periods</span>
00107     I2SCLL = bitrateDiv;
00108     I2SCLH = bitrateDiv;
00109 }
00110 
00111 <span class="keywordtype">void</span> i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
00112 {
00113     <span class="comment">// set local device address (used in slave mode only)</span>
00114     I2ADR = ((deviceAddr&amp;0xFE) | (genCallEn?1:0));
00115 }
00116 
00117 <span class="keywordtype">void</span> i2cSendStart(<span class="keywordtype">void</span>)
00118 {
00119     I2CONSET = BIT(I2CON_STA);
00120     I2CONCLR = BIT(I2CON_SI);
00121 }
00122 
00123 <span class="keywordtype">void</span> i2cSendStop(<span class="keywordtype">void</span>)
00124 {
00125     I2CONSET = BIT(I2CON_STO);
00126     I2CONCLR = BIT(I2CON_SI);
00127 }
00128 
00129 <span class="keywordtype">void</span> i2cWaitForComplete(<span class="keywordtype">void</span>)
00130 {
00131     <span class="comment">// wait for a valid status code</span>
00132     <span class="keywordflow">while</span>(I2STAT == TW_NO_INFO);
00133 }
00134 
00135 <span class="keywordtype">void</span> i2cSendByte(u08 data)
00136 {
00137     <span class="comment">// save data into data register</span>
00138     I2DAT = data;
00139     <span class="comment">// clear SI bit to begin transfer</span>
00140     I2CONCLR = BIT(I2CON_SI);
00141 }
00142 
00143 <span class="keywordtype">void</span> i2cReceiveByte(u08 ackFlag)
00144 {
00145     <span class="comment">// begin receive over i2c</span>
00146     <span class="keywordflow">if</span>( ackFlag )
00147     {
00148         <span class="comment">// ackFlag = TRUE: ACK the recevied data</span>
00149         I2CONSET = BIT(I2CON_AA);
00150         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));</span>
00151     }
00152     <span class="keywordflow">else</span>
00153     {
00154         <span class="comment">// ackFlag = FALSE: NACK the recevied data</span>
00155         I2CONCLR = BIT(I2CON_AA);
00156         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));</span>
00157     }
00158     <span class="comment">// clear SI bit to begin transfer</span>
00159     I2CONCLR = BIT(I2CON_SI);
00160 }
00161 
00162 u08 i2cGetReceivedByte(<span class="keywordtype">void</span>)
00163 {
00164     <span class="keywordflow">return</span> I2DAT;
00165 }
00166 
00167 u08 i2cGetStatus(<span class="keywordtype">void</span>)
00168 {
00169     <span class="keywordflow">return</span> I2STAT;
00170 }
00171 
00172 
00173 u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
00174 {
00175     u08 retval = I2C_OK;
00176 
00177     <span class="comment">// disable TWI interrupt</span>
00178     <span class="comment">//cbi(TWCR, TWIE);</span>
00179 
00180     <span class="comment">// send start condition</span>
00181     i2cSendStart();
00182     i2cWaitForComplete();
00183     I2CONCLR = BIT(I2CON_STA);
00184 
00185     <span class="comment">// send device address with write</span>
00186     i2cSendByte( deviceAddr &amp; 0xFE );
00187     i2cWaitForComplete();
00188 
00189     <span class="comment">// check if device is present and live</span>
00190     <span class="keywordflow">if</span>( I2STAT == TW_MT_SLA_ACK)
00191     {
00192         <span class="comment">// send data</span>
00193         <span class="keywordflow">while</span>(length)
00194         {
00195             i2cSendByte( *data++ );
00196             i2cWaitForComplete();
00197             length--;
00198         }
00199     }
00200     <span class="keywordflow">else</span>
00201     {
00202         <span class="comment">// device did not ACK it's address,</span>
00203         <span class="comment">// data will not be transferred</span>
00204         <span class="comment">// return error</span>
00205         retval = I2C_ERROR_NODEV;
00206     }
00207 
00208     <span class="comment">// transmit stop condition</span>
00209     <span class="comment">// leave with TWEA on for slave receiving</span>
00210 <span class="comment">//  I2CONSET = BIT(I2CON_STA);</span>
00211 <span class="comment">//  delay(10);</span>
00212 <span class="comment">//  I2CONCLR = BIT(I2CON_STO);</span>
00213     i2cSendStop();
00214     <span class="comment">//while( !(inb(TWCR) &amp; BV(TWSTO)) );</span>
00215 
00216     <span class="comment">// enable TWI interrupt</span>
00217     <span class="comment">//sbi(TWCR, TWIE);</span>
00218 
00219     <span class="keywordflow">return</span> retval;
00220 }
00221 
00222 u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
00223 {
00224     u08 retval = I2C_OK;
00225 
00226     <span class="comment">// disable TWI interrupt</span><span class="comment"></span>
00227 <span class="comment">    ///cbi(TWCR, TWIE);</span>
00228 <span class="comment"></span>
00229     <span class="comment">// send start condition</span>
00230     i2cSendStart();
00231     i2cWaitForComplete();
00232     I2CONCLR = BIT(I2CON_STA);
00233 
00234     <span class="comment">// send device address with read</span>
00235     i2cSendByte( deviceAddr | 0x01 );
00236     i2cWaitForComplete();
00237 
00238     <span class="comment">// check if device is present and live</span>
00239     <span class="keywordflow">if</span>( I2STAT == TW_MR_SLA_ACK)
00240     {
00241         <span class="comment">// accept receive data and ack it</span>
00242         <span class="keywordflow">while</span>(length &gt; 1)
00243         {
00244             i2cReceiveByte(TRUE);
00245             i2cWaitForComplete();
00246             *data++ = i2cGetReceivedByte();
00247             <span class="comment">// decrement length</span>
00248             length--;
00249         }
00250 
00251         <span class="comment">// accept receive data and nack it (last-byte signal)</span>
00252         i2cReceiveByte(FALSE);
00253         i2cWaitForComplete();
00254         *data++ = i2cGetReceivedByte();
00255     }
00256     <span class="keywordflow">else</span>
00257     {
00258         <span class="comment">// device did not ACK it's address,</span>
00259         <span class="comment">// data will not be transferred</span>
00260         <span class="comment">// return error</span>
00261         retval = I2C_ERROR_NODEV;
00262     }
00263 
00264     <span class="comment">// transmit stop condition</span>
00265     <span class="comment">// leave with TWEA on for slave receiving</span>
00266     i2cSendStop();
00267 
00268     <span class="comment">// enable TWI interrupt</span>
00269     <span class="comment">//sbi(TWCR, TWIE);</span>
00270 
00271     <span class="keywordflow">return</span> retval;
00272 }
00273 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
