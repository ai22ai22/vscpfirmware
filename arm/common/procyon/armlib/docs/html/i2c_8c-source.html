<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib-LPC2100: i2c.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>i2c.c</h1><a href="i2c_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file i2c.c \brief I2C interface using Philips LPC internal I2C hardware. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'i2c.c'</span>
00005 <span class="comment">// Title        : I2C interface using Philips LPC internal I2C hardware</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004</span>
00007 <span class="comment">// Created      : 2004.05.05</span>
00008 <span class="comment">// Revised      : 2004.07.12</span>
00009 <span class="comment">// Version      : 0.9</span>
00010 <span class="comment">// Target MCU   : ARM, Philips LPC2100-series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description : I2C (pronounced "eye-squared-see") is a two-wire bidirectional</span>
00014 <span class="comment">//      network designed for easy transfer of information between a wide variety</span>
00015 <span class="comment">//      of intelligent devices.  Many of the Atmel AVR series processors have</span>
00016 <span class="comment">//      hardware support for transmitting and receiving using an I2C-type bus.</span>
00017 <span class="comment">//      In addition to the AVRs, there are thousands of other parts made by</span>
00018 <span class="comment">//      manufacturers like Philips, Maxim, National, TI, etc that use I2C as</span>
00019 <span class="comment">//      their primary means of communication and control.  Common device types</span>
00020 <span class="comment">//      are A/D &amp; D/A converters, temp sensors, intelligent battery monitors,</span>
00021 <span class="comment">//      MP3 decoder chips, EEPROM chips, multiplexing switches, etc.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">//      I2C uses only two wires (SDA and SCL) to communicate bidirectionally</span>
00024 <span class="comment">//      between devices.  I2C is a multidrop network, meaning that you can have</span>
00025 <span class="comment">//      several devices on a single bus.  Because I2C uses a 7-bit number to</span>
00026 <span class="comment">//      identify which device it wants to talk to, you cannot have more than</span>
00027 <span class="comment">//      127 devices on a single bus.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">//      I2C ordinarily requires two 4.7K pull-up resistors to power (one each on</span>
00030 <span class="comment">//      SDA and SCL), but for small numbers of devices (maybe 1-4), it is enough</span>
00031 <span class="comment">//      to activate the internal pull-up resistors in the AVR processor.  To do</span>
00032 <span class="comment">//      this, set the port pins, which correspond to the I2C pins SDA/SCL, high.</span>
00033 <span class="comment">//      For example, on the mega163, sbi(PORTC, 0); sbi(PORTC, 1);.</span>
00034 <span class="comment">//</span>
00035 <span class="comment">//      For complete information about I2C, see the Philips Semiconductor</span>
00036 <span class="comment">//      website.  They created I2C and have the largest family of devices that</span>
00037 <span class="comment">//      work with I2C.</span>
00038 <span class="comment">//</span>
00039 <span class="comment">// Note: Many manufacturers market I2C bus devices under a different or generic</span>
00040 <span class="comment">//      bus name like "Two-Wire Interface".  This is because Philips still holds</span>
00041 <span class="comment">//      "I2C" as a trademark.  For example, SMBus and SMBus devices are hardware</span>
00042 <span class="comment">//      compatible and closely related to I2C.  They can be directly connected</span>
00043 <span class="comment">//      to an I2C bus along with other I2C devices are are generally accessed in</span>
00044 <span class="comment">//      the same way as I2C devices.  SMBus is often found on modern motherboards</span>
00045 <span class="comment">//      for temp sensing and other low-level control tasks.</span>
00046 <span class="comment">//</span>
00047 <span class="comment">// This code is distributed under the GNU Public License</span>
00048 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//*****************************************************************************</span>
00051 
00052 <span class="preprocessor">#include "lpc210x.h"</span>
00053 <span class="preprocessor">#include "config.h"</span>
00054 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="i2c_8h.html">i2c.h</a>"</span>
00057 
<a name="l00058"></a><a class="code" href="i2c_8h.html#a43">00058</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a0">i2cInit</a>(<span class="keywordtype">void</span>)
00059 {
00060     <span class="comment">// setup SCL pin P02</span>
00061     PINSEL0 &amp;= ~(3&lt;&lt;4);
00062     PINSEL0 |=   1&lt;&lt;4;
00063     <span class="comment">// setup SDA pin P03</span>
00064     PINSEL0 &amp;= ~(3&lt;&lt;6);
00065     PINSEL0 |=   1&lt;&lt;6;
00066 
00067     <span class="comment">// set default bitrate of 100KHz</span>
00068     <a class="code" href="i2c_8h.html#a44">i2cSetBitrate</a>(400);
00069 
00070     <span class="comment">// disable and reset interface</span>
00071     I2CONCLR = 0xFF;
00072     delay(10);
00073 
00074     <span class="comment">// enable interface</span>
00075     I2CONSET = BIT(I2CON_I2EN);
00076 }
00077 <span class="comment">/*</span>
00078 <span class="comment">void InitialiseI2C(void)</span>
00079 <span class="comment">{</span>
00080 <span class="comment"></span>
00081 <span class="comment">REG(I2C_I2SCLL) = 0x18;</span>
00082 <span class="comment"></span>
00083 <span class="comment">REG(I2C_I2SCLH) = 0x18;</span>
00084 <span class="comment"></span>
00085 <span class="comment">REG(I2C_I2CONCLR) = 0xFF;</span>
00086 <span class="comment"></span>
00087 <span class="comment">// Set pinouts as scl and sda</span>
00088 <span class="comment">REG(PCB_PINSEL0) = 0x50;</span>
00089 <span class="comment"></span>
00090 <span class="comment">REG(I2C_I2CONSET) = 0x40;</span>
00091 <span class="comment">delay(10);</span>
00092 <span class="comment">REG(I2C_I2CONSET) = 0x64;</span>
00093 <span class="comment"></span>
00094 <span class="comment">REG(I2C_I2DAT) = 0x42;</span>
00095 <span class="comment"></span>
00096 <span class="comment">REG(I2C_I2CONCLR) = 0x08;</span>
00097 <span class="comment"></span>
00098 <span class="comment">REG(I2C_I2CONCLR) = 0x20;</span>
00099 <span class="comment"></span>
00100 <span class="comment">}</span>
00101 <span class="comment">*/</span>
00102 
<a name="l00103"></a><a class="code" href="i2c_8h.html#a44">00103</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8h.html#a44">i2cSetBitrate</a>(u16 bitrateDiv)
00104 {
00105     <span class="comment">// @60MHz and VPB=2, set to 75 for 400KHz</span>
00106     <span class="comment">// @60MHz and VPB=2, set to 400 for 75KHz</span>
00107     I2SCLL = bitrateDiv;
00108     I2SCLH = bitrateDiv;
00109 }
00110 
<a name="l00111"></a><a class="code" href="i2c_8h.html#a45">00111</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8h.html#a45">i2cSetLocalDeviceAddr</a>(u08 deviceAddr, u08 genCallEn)
00112 {
00113     <span class="comment">// set local device address (used in slave mode only)</span>
00114     I2ADR = ((deviceAddr&amp;0xFE) | (genCallEn?1:0));
00115 }
00116 
<a name="l00117"></a><a class="code" href="i2c_8h.html#a46">00117</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a3">i2cSendStart</a>(<span class="keywordtype">void</span>)
00118 {
00119     I2CONSET = BIT(I2CON_STA);
00120     I2CONCLR = BIT(I2CON_SI);
00121 }
00122 
<a name="l00123"></a><a class="code" href="i2c_8h.html#a47">00123</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a4">i2cSendStop</a>(<span class="keywordtype">void</span>)
00124 {
00125     I2CONSET = BIT(I2CON_STO);
00126 }
00127 
<a name="l00128"></a><a class="code" href="i2c_8h.html#a48">00128</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>(<span class="keywordtype">void</span>)
00129 {
00130     <span class="comment">// wait for a valid status code</span>
00131     <span class="keywordflow">while</span>(I2STAT == TW_NO_INFO);
00132 }
00133 
<a name="l00134"></a><a class="code" href="i2c_8h.html#a49">00134</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8h.html#a49">i2cSendByte</a>(u08 data)
00135 {
00136     <span class="comment">// save data into data register</span>
00137     I2DAT = data;
00138     <span class="comment">// clear SI bit to begin transfer</span>
00139     I2CONCLR = BIT(I2CON_SI);
00140 }
00141 
<a name="l00142"></a><a class="code" href="i2c_8h.html#a50">00142</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8h.html#a50">i2cReceiveByte</a>(u08 ackFlag)
00143 {
00144     <span class="comment">// begin receive over i2c</span>
00145     <span class="keywordflow">if</span>( ackFlag )
00146     {
00147         <span class="comment">// ackFlag = TRUE: ACK the recevied data</span>
00148         I2CONSET = BIT(I2CON_AA);
00149         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));</span>
00150     }
00151     <span class="keywordflow">else</span>
00152     {
00153         <span class="comment">// ackFlag = FALSE: NACK the recevied data</span>
00154         I2CONCLR = BIT(I2CON_AA);
00155         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));</span>
00156     }
00157     <span class="comment">// clear SI bit to begin transfer</span>
00158     I2CONCLR = BIT(I2CON_SI);
00159 }
00160 
<a name="l00161"></a><a class="code" href="i2c_8h.html#a51">00161</a> u08 <a class="code" href="i2c_8c.html#a8">i2cGetReceivedByte</a>(<span class="keywordtype">void</span>)
00162 {
00163     <span class="keywordflow">return</span> I2DAT;
00164 }
00165 
<a name="l00166"></a><a class="code" href="i2c_8h.html#a52">00166</a> u08 <a class="code" href="i2c_8c.html#a9">i2cGetStatus</a>(<span class="keywordtype">void</span>)
00167 {
00168     <span class="keywordflow">return</span> I2STAT;
00169 }
00170 
00171 
<a name="l00172"></a><a class="code" href="i2c_8h.html#a53">00172</a> u08 <a class="code" href="i2c_8h.html#a53">i2cMasterSendNI</a>(u08 deviceAddr, u08 length, u08* data)
00173 {
00174     u08 retval = I2C_OK;
00175 
00176     <span class="comment">// disable TWI interrupt</span>
00177     <span class="comment">//cbi(TWCR, TWIE);</span>
00178 
00179     <span class="comment">// send start condition</span>
00180     <a class="code" href="i2c_8c.html#a3">i2cSendStart</a>();
00181     <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00182     I2CONCLR = BIT(I2CON_STA);
00183 
00184     <span class="comment">// send device address with write</span>
00185     <a class="code" href="i2c_8h.html#a49">i2cSendByte</a>( deviceAddr &amp; 0xFE );
00186     <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00187 
00188     <span class="comment">// check if device is present and live</span>
00189     <span class="keywordflow">if</span>( I2STAT == TW_MT_SLA_ACK)
00190     {
00191         <span class="comment">// send data</span>
00192         <span class="keywordflow">while</span>(length)
00193         {
00194             <a class="code" href="i2c_8h.html#a49">i2cSendByte</a>( *data++ );
00195             <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00196             length--;
00197         }
00198     }
00199     <span class="keywordflow">else</span>
00200     {
00201         <span class="comment">// device did not ACK it's address,</span>
00202         <span class="comment">// data will not be transferred</span>
00203         <span class="comment">// return error</span>
00204         retval = I2C_ERROR_NODEV;
00205     }
00206 
00207     <span class="comment">// transmit stop condition</span>
00208     <span class="comment">// leave with TWEA on for slave receiving</span>
00209     I2CONSET = BIT(I2CON_STA);
00210     delay(10);
00211     I2CONCLR = BIT(I2CON_STO);
00212     <span class="comment">//while( !(inb(TWCR) &amp; BV(TWSTO)) );</span>
00213 
00214     <span class="comment">// enable TWI interrupt</span>
00215     <span class="comment">//sbi(TWCR, TWIE);</span>
00216 
00217     <span class="keywordflow">return</span> retval;
00218 }
00219 
<a name="l00220"></a><a class="code" href="i2c_8h.html#a54">00220</a> u08 <a class="code" href="i2c_8h.html#a54">i2cMasterReceiveNI</a>(u08 deviceAddr, u08 length, u08 *data)
00221 {
00222     u08 retval = I2C_OK;
00223 
00224     <span class="comment">// disable TWI interrupt</span><span class="comment"></span>
00225 <span class="comment">    ///cbi(TWCR, TWIE);</span>
00226 <span class="comment"></span>
00227     <span class="comment">// send start condition</span>
00228     <a class="code" href="i2c_8c.html#a3">i2cSendStart</a>();
00229     <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00230 
00231     <span class="comment">// send device address with read</span>
00232     <a class="code" href="i2c_8h.html#a49">i2cSendByte</a>( deviceAddr | 0x01 );
00233     <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00234 
00235     <span class="comment">// check if device is present and live</span>
00236     <span class="keywordflow">if</span>( I2STAT == TW_MR_SLA_ACK)
00237     {
00238         <span class="comment">// accept receive data and ack it</span>
00239         <span class="keywordflow">while</span>(length &gt; 1)
00240         {
00241             <a class="code" href="i2c_8h.html#a50">i2cReceiveByte</a>(TRUE);
00242             <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00243             *data++ = <a class="code" href="i2c_8c.html#a8">i2cGetReceivedByte</a>();
00244             <span class="comment">// decrement length</span>
00245             length--;
00246         }
00247 
00248         <span class="comment">// accept receive data and nack it (last-byte signal)</span>
00249         <a class="code" href="i2c_8h.html#a50">i2cReceiveByte</a>(FALSE);
00250         <a class="code" href="i2c_8c.html#a5">i2cWaitForComplete</a>();
00251         *data++ = <a class="code" href="i2c_8c.html#a8">i2cGetReceivedByte</a>();
00252     }
00253     <span class="keywordflow">else</span>
00254     {
00255         <span class="comment">// device did not ACK it's address,</span>
00256         <span class="comment">// data will not be transferred</span>
00257         <span class="comment">// return error</span>
00258         retval = I2C_ERROR_NODEV;
00259     }
00260 
00261     <span class="comment">// transmit stop condition</span>
00262     <span class="comment">// leave with TWEA on for slave receiving</span>
00263     <a class="code" href="i2c_8c.html#a4">i2cSendStop</a>();
00264 
00265     <span class="comment">// enable TWI interrupt</span>
00266     <span class="comment">//sbi(TWCR, TWIE);</span>
00267 
00268     <span class="keywordflow">return</span> retval;
00269 }
00270 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jul 13 03:38:11 2004 for Procyon ARMlib-LPC2100 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
