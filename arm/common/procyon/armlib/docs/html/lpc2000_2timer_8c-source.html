<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: arch/lpc2000/timer.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">arch</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">lpc2000</a></div>
<h1>timer.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timer.c \brief Timer Support Library for LPC2100. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer.c'</span>
00005 <span class="comment">// Title        : Timer Support Library for LPC2100</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004</span>
00007 <span class="comment">// Created      : 2004.05.05</span>
00008 <span class="comment">// Revised      : 2004.07.12</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : ARM processors</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "lpc2000.h"</span>
00023 <span class="preprocessor">#include "processor.h"</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "timer.h"</span>
00027 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00028 
00029 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00030 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntrFunc[TIMER_NUM_INTERRUPTS];
00031 
00032 <span class="keyword">volatile</span> u32 Timer0Pause;
00033 <span class="keyword">volatile</span> u32 Timer0OverflowCount;
00034 <span class="keyword">volatile</span> u32 Timer1OverflowCount;
00035 
00036 <span class="keywordtype">void</span> delay(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> d)
00037 {     
00038     <span class="keywordflow">for</span>(; d; --d)
00039     {
00040         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00041     }
00042 }
00043 
00044 
00045 <span class="keywordtype">void</span> timerInit(<span class="keywordtype">void</span>)
00046 {
00047     u08 intNum;
00048     <span class="comment">// detach all user functions from interrupts</span>
00049     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00050         timerDetach(intNum);
00051 
00052     <span class="comment">// initialize timer0</span>
00053     timer0Init();
00054     <span class="comment">// initialize timer1</span>
00055     timer1Init();
00056     <span class="comment">// enable IRQ interrupts</span>
00057     processorEnableInt(CPSR_MASK_IRQ);
00058 }
00059 
00060 <span class="keywordtype">void</span> timer0Init(<span class="keywordtype">void</span>)
00061 {
00062     <span class="comment">// setup timer0</span>
00063     <span class="comment">// set prescaler</span>
00064     timer1PrescalerSet(1);
00065     <span class="comment">// reset timer</span>
00066     T0TCR = TCR_RESET;
00067     delay(10);
00068     <span class="comment">// start timer</span>
00069     T0TCR = TCR_ENABLE;
00070 
00071     <span class="comment">// setup timer0 for IRQ</span>
00072     <span class="comment">// set interrupt as IRQ</span>
00073     VICIntSelect &amp;= ~(1&lt;&lt;VIC_TIMER0);
00074     <span class="comment">// assign VIC slot</span>
00075     VICVectCntl4 = VIC_ENABLE | VIC_TIMER0;
00076     VICVectAddr4 = (u32)timer0Service;
00077     <span class="comment">// enable interrupt</span>
00078     VICIntEnable |= (1&lt;&lt;VIC_TIMER0);
00079 
00080     <span class="comment">// setup MR0 value</span>
00081     T0MR0 = PCLK/1000;
00082     <span class="comment">// enable timer0 interrupt and reset on MR0 match</span>
00083     T0MCR |= TMCR_MR0_I | TMCR_MR0_R;
00084 
00085 }
00086 
00087 <span class="keywordtype">void</span> timer1Init(<span class="keywordtype">void</span>)
00088 {
00089     <span class="comment">// setup timer1</span>
00090     <span class="comment">// set prescaler</span>
00091     timer1PrescalerSet(1);
00092     <span class="comment">// reset timer</span>
00093     T1TCR = TCR_RESET;
00094     delay(10);
00095     <span class="comment">// start timer</span>
00096     T1TCR = TCR_ENABLE;
00097 
00098     <span class="comment">// setup timer1 for IRQ</span>
00099     <span class="comment">// set interrupt as IRQ</span>
00100     VICIntSelect &amp;= ~(1&lt;&lt;VIC_TIMER1);
00101     <span class="comment">// assign VIC slot</span>
00102     VICVectCntl5 = VIC_ENABLE | VIC_TIMER1;
00103     VICVectAddr5 = (u32)timer1Service;
00104     <span class="comment">// enable interrupt</span>
00105     VICIntEnable |= (1&lt;&lt;VIC_TIMER1);
00106 }
00107 
00108 <span class="keywordtype">void</span> timer0PrescalerSet(u32 clockDiv)
00109 {
00110     <span class="comment">// timer0 increments every PR+1 cycles</span>
00111     <span class="comment">// subtract 1 so the argument is a true division ratio</span>
00112     T0PR = clockDiv-1;
00113 }
00114 <span class="keywordtype">void</span> timer1PrescalerSet(u32 clockDiv)
00115 {
00116     <span class="comment">// timer1 increments every PR+1 cycles</span>
00117     <span class="comment">// subtract 1 so the argument is a true division ratio</span>
00118     T1PR = clockDiv-1;
00119 }
00120 
<a name="l00121"></a><a class="code" href="group__timer__at91.html#ga3">00121</a> <span class="keywordtype">void</span> <a class="code" href="group__timer__at91.html#ga3">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00122 {
00123     <span class="comment">// make sure the interrupt number is within bounds</span>
00124     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00125     {
00126         <span class="comment">// set the interrupt function to run</span>
00127         <span class="comment">// the supplied user's function</span>
00128         TimerIntrFunc[interruptNum] = userFunc;
00129     }
00130 }
00131 
00132 <span class="keywordtype">void</span> timerDetach(u08 interruptNum)
00133 {
00134     <span class="comment">// make sure the interrupt number is within bounds</span>
00135     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00136     {
00137         <span class="comment">// set the interrupt function to run nothing</span>
00138         TimerIntrFunc[interruptNum] = 0;
00139     }
00140 }
00141 
00142 <span class="keywordtype">void</span> timerPause(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pause_ms)
00143 {
00144     Timer0Pause = pause_ms;
00145 
00146     <span class="keywordflow">while</span>(Timer0Pause)
00147     {
00148         <span class="comment">//rprintfu32(Timer0Pause);</span>
00149         <span class="comment">//rprintfCRLF();</span>
00150     }
00151 }
00152 
00153 <span class="keywordtype">void</span> timer0ClearOverflowCount(<span class="keywordtype">void</span>)
00154 {
00155     Timer0OverflowCount = 0;
00156 }
00157 
00158 u32 timer0GetOverflowCount(<span class="keywordtype">void</span>)
00159 {
00160     <span class="keywordflow">return</span> Timer0OverflowCount;
00161 }
00162 
00163 <span class="keywordtype">void</span> timer1ClearOverflowCount(<span class="keywordtype">void</span>)
00164 {
00165     Timer1OverflowCount = 0;
00166 }
00167 
00168 u32 timer1GetOverflowCount(<span class="keywordtype">void</span>)
00169 {
00170     <span class="keywordflow">return</span> Timer1OverflowCount;
00171 }
00172 
00173 <span class="keywordtype">void</span> timer0Match0Set(u32 value)
00174 {
00175     T0MR0 = value;
00176 }
00177 
00178 <span class="keywordtype">void</span> timer0Match1Set(u32 value)
00179 {
00180     T0MR1 = value;
00181 }
00182 
00183 <span class="keywordtype">void</span> timer1Match0Set(u32 value)
00184 {
00185     T1MR0 = value;
00186 }
00187 
00188 <span class="keywordtype">void</span> timer1Match1Set(u32 value)
00189 {
00190     T1MR1 = value;
00191 }
00192 
00193 <span class="keywordtype">void</span> timer0Capture0Init(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edge)
00194 {
00195     <span class="comment">// setup timer0 capture0</span>
00196     <span class="keywordflow">if</span>(edge)
00197     {
00198         <span class="comment">// pin select</span>
00199         PINSEL0 &amp;= ~(3&lt;&lt;(2*2)); <span class="comment">// clear pin select bits for P0.2 -&gt; GPIO</span>
00200         PINSEL0 |=  (2&lt;&lt;(2*2)); <span class="comment">// set pin select bits for P0.2 -&gt; Capture0.0</span>
00201         <span class="comment">// enable timer0 interrupt on rising/falling edge of CR0 capture</span>
00202         T0CCR &amp;= ~(TCCR_CR0_R | TCCR_CR0_F);
00203         T0CCR |= TCCR_CR0_I | (edge);
00204     }
00205     <span class="keywordflow">else</span>
00206     {
00207         <span class="comment">// pin select</span>
00208         PINSEL0 &amp;= ~(3&lt;&lt;(2*2)); <span class="comment">// clear pin select bits for P0.2 -&gt; GPIO</span>
00209         <span class="comment">// disable timer0 interrupt on rising/falling edge of CR0 capture</span>
00210         T0CCR &amp;= ~(TCCR_CR0_I);
00211     }
00212 }
00213 
00214 <span class="keywordtype">void</span> timer0Capture1Init(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edge)
00215 {
00216     <span class="comment">// setup timer0 capture1</span>
00217     <span class="keywordflow">if</span>(edge)
00218     {
00219         <span class="comment">// pin select</span>
00220         PINSEL0 &amp;= ~(3&lt;&lt;(4*2)); <span class="comment">// clear pin select bits for P0.4 -&gt; GPIO</span>
00221         PINSEL0 |=  (2&lt;&lt;(4*2)); <span class="comment">// set pin select bits for P0.4 -&gt; Capture0.1</span>
00222         <span class="comment">// enable timer0 interrupt on rising/falling edge of CR1 capture</span>
00223         T0CCR |= TCCR_CR1_I | (edge&lt;&lt;3);
00224     }
00225     <span class="keywordflow">else</span>
00226     {
00227         <span class="comment">// pin select</span>
00228         PINSEL0 &amp;= ~(3&lt;&lt;(4*2)); <span class="comment">// clear pin select bits for P0.4 -&gt; GPIO</span>
00229         <span class="comment">// disable timer0 interrupt on rising/falling edge of CR1 capture</span>
00230         T0CCR &amp;= ~(TCCR_CR1_I);
00231     }
00232 }
00233 
00234 <span class="keywordtype">void</span> timer1Capture0Init(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edge)
00235 {
00236     <span class="comment">// setup timer1 capture0</span>
00237     <span class="keywordflow">if</span>(edge)
00238     {
00239         <span class="comment">// pin select</span>
00240         PINSEL0 &amp;= ~(3&lt;&lt;(10*2));    <span class="comment">// clear pin select bits for P0.10 -&gt; GPIO</span>
00241         PINSEL0 |=  (2&lt;&lt;(10*2));    <span class="comment">// set pin select bits for P0.10 -&gt; Capture0.0</span>
00242         <span class="comment">// enable timer0 interrupt on rising/falling edge of CR0 capture</span>
00243         T1CCR &amp;= ~(TCCR_CR0_R | TCCR_CR0_F);
00244         T1CCR |= TCCR_CR0_I | (edge);
00245     }
00246     <span class="keywordflow">else</span>
00247     {
00248         <span class="comment">// pin select</span>
00249         PINSEL0 &amp;= ~(3&lt;&lt;(10*2));    <span class="comment">// clear pin select bits for P0.10 -&gt; GPIO</span>
00250         <span class="comment">// disable timer0 interrupt on rising/falling edge of CR0 capture</span>
00251         <span class="comment">//T0CCR &amp;= ~(TCCR_CR0_I | TCCR_CR0_R);</span>
00252         T1CCR &amp;= ~(TCCR_CR0_I);
00253     }
00254 }
00255 
00256 <span class="keywordtype">void</span> timer1Capture1Init(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edge)
00257 {
00258     <span class="comment">// setup timer1 capture1</span>
00259     <span class="keywordflow">if</span>(edge)
00260     {
00261         <span class="comment">// pin select</span>
00262         PINSEL0 &amp;= ~(3&lt;&lt;(11*2));    <span class="comment">// clear pin select bits for P0.11 -&gt; GPIO</span>
00263         PINSEL0 |=  (2&lt;&lt;(11*2));    <span class="comment">// set pin select bits for P0.11 -&gt; Capture0.0</span>
00264         <span class="comment">// enable timer0 interrupt on rising/falling edge of CR0 capture</span>
00265         T1CCR &amp;= ~(TCCR_CR0_R | TCCR_CR0_F);
00266         T1CCR |= TCCR_CR1_I | (edge&lt;&lt;3);
00267     }
00268     <span class="keywordflow">else</span>
00269     {
00270         <span class="comment">// pin select</span>
00271         PINSEL0 &amp;= ~(3&lt;&lt;(11*2));    <span class="comment">// clear pin select bits for P0.11 -&gt; GPIO</span>
00272         <span class="comment">// disable timer0 interrupt on rising/falling edge of CR0 capture</span>
00273         <span class="comment">//T0CCR &amp;= ~(TCCR_CR0_I | TCCR_CR0_R);</span>
00274         T1CCR &amp;= ~(TCCR_CR1_I);
00275     }
00276 }
00277 
00278 <span class="keywordtype">void</span> timer0Service(<span class="keywordtype">void</span>)
00279 {
00280     ISR_ENTRY();
00281     
00282     <span class="comment">// check the interrupt sources</span>
00283     <span class="keywordflow">if</span>(T0IR &amp; TIR_MR0I)
00284     {
00285         <span class="comment">// clear MR0 Interrupt</span>
00286         T0IR |= TIR_MR0I;
00287         <span class="keywordflow">if</span>(Timer0Pause)
00288             Timer0Pause--;
00289         Timer0OverflowCount++;
00290         <span class="comment">// if a user function is defined, execute it</span>
00291         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0MATCH0_INT])
00292             TimerIntrFunc[TIMER0MATCH0_INT]();
00293     }
00294     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T0IR &amp; TIR_CR0I)
00295     {
00296         <span class="comment">// clear CR0 Interrupt</span>
00297         T0IR |= TIR_CR0I;
00298         <span class="comment">// if a user function is defined, execute it</span>
00299         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0CAPTURE0_INT])
00300             TimerIntrFunc[TIMER0CAPTURE0_INT]();
00301     }
00302     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T0IR &amp; TIR_CR1I)
00303     {
00304         <span class="comment">// clear CR1 Interrupt</span>
00305         T0IR |= TIR_CR1I;
00306         <span class="comment">// if a user function is defined, execute it</span>
00307         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0CAPTURE1_INT])
00308             TimerIntrFunc[TIMER0CAPTURE1_INT]();
00309     }
00310     
00311     VICSoftIntClear = (1&lt;&lt;VIC_TIMER0);
00312     VICVectAddr = 0x00000000;             <span class="comment">// clear this interrupt from the VIC</span>
00313     ISR_EXIT();                           <span class="comment">// recover registers and return</span>
00314 }
00315 
00316 <span class="keywordtype">void</span> timer1Service(<span class="keywordtype">void</span>)
00317 {
00318     ISR_ENTRY();
00319 
00320     <span class="keywordflow">if</span>(T1IR &amp; TIR_MR0I)
00321     {
00322         <span class="comment">// clear MR0 Interrupt</span>
00323         T1IR |= TIR_MR0I;
00324         Timer1OverflowCount++;
00325         <span class="comment">// if a user function is defined, execute it</span>
00326         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER1MATCH0_INT])
00327             TimerIntrFunc[TIMER1MATCH0_INT]();
00328     }
00329     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T1IR &amp; TIR_CR0I)
00330     {
00331         <span class="comment">// clear CR0 Interrupt</span>
00332         T1IR |= TIR_CR0I;
00333         <span class="comment">// if a user function is defined, execute it</span>
00334         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER1CAPTURE0_INT])
00335             TimerIntrFunc[TIMER1CAPTURE0_INT]();
00336     }
00337     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T1IR &amp; TIR_CR1I)
00338     {
00339         <span class="comment">// clear CR1 Interrupt</span>
00340         T1IR |= TIR_CR1I;
00341         <span class="comment">// if a user function is defined, execute it</span>
00342         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER1CAPTURE1_INT])
00343             TimerIntrFunc[TIMER1CAPTURE1_INT]();
00344     }
00345     
00346     VICSoftIntClear = (1&lt;&lt;VIC_TIMER1);
00347     VICVectAddr = 0x00000000;             <span class="comment">// clear this interrupt from the VIC</span>
00348     ISR_EXIT();                           <span class="comment">// recover registers and return</span>
00349 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
