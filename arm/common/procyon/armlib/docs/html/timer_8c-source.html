<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib-LPC2100: timer.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>timer.c</h1><a href="timer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file timer.c \brief Timer Support Library for LPC2100. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer.c'</span>
00005 <span class="comment">// Title        : Timer Support Library for LPC2100</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004</span>
00007 <span class="comment">// Created      : 2004.05.05</span>
00008 <span class="comment">// Revised      : 2004.07.12</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : ARM processors</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "lpc210x.h"</span>
00023 <span class="preprocessor">#include "<a class="code" href="processor_8h.html">processor.h</a>"</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00028 
00029 <span class="keyword">typedef</span> void (*voidFuncPtr)(<span class="keywordtype">void</span>);
00030 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntrFunc[TIMER_NUM_INTERRUPTS];
00031 
00032 <span class="keyword">volatile</span> u32 Timer0Pause;
00033 <span class="keyword">volatile</span> u32 Timer0OverflowCount;
00034 <span class="keyword">volatile</span> u32 Timer1OverflowCount;
00035 
00036 <span class="keywordtype">void</span> delay(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> d)
00037 {     
00038     <span class="keywordflow">for</span>(; d; --d)
00039     {
00040         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00041     }
00042 }
00043 
00044 
00045 <span class="keywordtype">void</span> timerInit(<span class="keywordtype">void</span>)
00046 {
00047     u08 intNum;
00048     <span class="comment">// detach all user functions from interrupts</span>
00049     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00050         <a class="code" href="timer_8h.html#a21">timerDetach</a>(intNum);
00051 
00052     <span class="comment">// initialize timer0</span>
00053     timer0Init();
00054     <span class="comment">// initialize timer1</span>
00055     timer1Init();
00056     <span class="comment">// enable interrupts</span>
00057     enableIRQ();
00058 }
00059 
00060 <span class="keywordtype">void</span> timer0Init(<span class="keywordtype">void</span>)
00061 {
00062     <span class="comment">// setup timer0</span>
00063     <span class="comment">// set prescaler</span>
00064     timer1PrescalerSet(1);
00065     <span class="comment">// reset timer</span>
00066     T0TCR = TCR_RESET;
00067     delay(10);
00068     <span class="comment">// start timer</span>
00069     T0TCR = TCR_ENABLE;
00070 
00071     <span class="comment">// setup timer0 for IRQ</span>
00072     <span class="comment">// set interrupt as IRQ</span>
00073     VICIntSelect &amp;= ~(1&lt;&lt;VIC_TIMER0);
00074     <span class="comment">// assign VIC slot</span>
00075     VICVectCntl4 = VIC_ENABLE | VIC_TIMER0;
00076     VICVectAddr4 = (u32)timer0Service;
00077     <span class="comment">// enable interrupt</span>
00078     VICIntEnable |= (1&lt;&lt;VIC_TIMER0);
00079 
00080     <span class="comment">// setup MR0 value</span>
00081     T0MR0 = CCLK/1000;
00082     <span class="comment">// enable timer0 interrupt and reset on MR0 match</span>
00083     T0MCR |= TMCR_MR0_I | TMCR_MR0_R;
00084 
00085 }
00086 
00087 <span class="keywordtype">void</span> timer1Init(<span class="keywordtype">void</span>)
00088 {
00089     <span class="comment">// setup timer1</span>
00090     <span class="comment">// set prescaler</span>
00091     timer1PrescalerSet(1);
00092     <span class="comment">// reset timer</span>
00093     T1TCR = TCR_RESET;
00094     delay(10);
00095     <span class="comment">// start timer</span>
00096     T1TCR = TCR_ENABLE;
00097 
00098     <span class="comment">// setup timer1 for IRQ</span>
00099     <span class="comment">// set interrupt as IRQ</span>
00100     VICIntSelect &amp;= ~(1&lt;&lt;VIC_TIMER1);
00101     <span class="comment">// assign VIC slot</span>
00102     VICVectCntl5 = VIC_ENABLE | VIC_TIMER1;
00103     VICVectAddr5 = (u32)timer1Service;
00104     <span class="comment">// enable interrupt</span>
00105     VICIntEnable |= (1&lt;&lt;VIC_TIMER1);
00106 }
00107 
00108 <span class="keywordtype">void</span> timer0PrescalerSet(u32 clockDiv)
00109 {
00110     <span class="comment">// timer0 increments every PR+1 cycles</span>
00111     <span class="comment">// subtract 1 so the argument is a true division ratio</span>
00112     T0PR = clockDiv-1;
00113 }
00114 <span class="keywordtype">void</span> timer1PrescalerSet(u32 clockDiv)
00115 {
00116     <span class="comment">// timer1 increments every PR+1 cycles</span>
00117     <span class="comment">// subtract 1 so the argument is a true division ratio</span>
00118     T1PR = clockDiv-1;
00119 }
00120 
<a name="l00121"></a><a class="code" href="timer_8h.html#a20">00121</a> <span class="keywordtype">void</span> <a class="code" href="timer_8h.html#a20">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00122 {
00123     <span class="comment">// make sure the interrupt number is within bounds</span>
00124     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00125     {
00126         <span class="comment">// set the interrupt function to run</span>
00127         <span class="comment">// the supplied user's function</span>
00128         TimerIntrFunc[interruptNum] = userFunc;
00129     }
00130 }
00131 
<a name="l00132"></a><a class="code" href="timer_8h.html#a21">00132</a> <span class="keywordtype">void</span> <a class="code" href="timer_8h.html#a21">timerDetach</a>(u08 interruptNum)
00133 {
00134     <span class="comment">// make sure the interrupt number is within bounds</span>
00135     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00136     {
00137         <span class="comment">// set the interrupt function to run nothing</span>
00138         TimerIntrFunc[interruptNum] = 0;
00139     }
00140 }
00141 
00142 <span class="keywordtype">void</span> timerPause(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pause_ms)
00143 {
00144     Timer0Pause = pause_ms;
00145 
00146     <span class="keywordflow">while</span>(Timer0Pause);
00147 }
00148 
00149 <span class="keywordtype">void</span> timer0ClearOverflowCount(<span class="keywordtype">void</span>)
00150 {
00151     Timer0OverflowCount = 0;
00152 }
00153 
00154 u32 timer0GetOverflowCount(<span class="keywordtype">void</span>)
00155 {
00156     <span class="keywordflow">return</span> Timer0OverflowCount;
00157 }
00158 
00159 <span class="keywordtype">void</span> timer1ClearOverflowCount(<span class="keywordtype">void</span>)
00160 {
00161     Timer1OverflowCount = 0;
00162 }
00163 
00164 u32 timer1GetOverflowCount(<span class="keywordtype">void</span>)
00165 {
00166     <span class="keywordflow">return</span> Timer1OverflowCount;
00167 }
00168 
00169 <span class="keywordtype">void</span> timer0Match0Set(u32 value)
00170 {
00171     T0MR0 = value;
00172 }
00173 
00174 <span class="keywordtype">void</span> timer0Match1Set(u32 value)
00175 {
00176     T0MR1 = value;
00177 }
00178 
00179 <span class="keywordtype">void</span> timer1Match0Set(u32 value)
00180 {
00181     T1MR0 = value;
00182 }
00183 
00184 <span class="keywordtype">void</span> timer1Match1Set(u32 value)
00185 {
00186     T1MR1 = value;
00187 }
00188 
00189 
00190 <span class="keywordtype">void</span> timer0Capture0Init(<span class="keywordtype">int</span> on)
00191 {
00192     <span class="comment">// setup timer0 capture0</span>
00193     <span class="keywordflow">if</span>(on)
00194     {
00195         <span class="comment">// pin select</span>
00196         PINSEL0 &amp;= ~(3&lt;&lt;4); <span class="comment">// clear pin select bits for P0.2 -&gt; GPIO</span>
00197         PINSEL0 |=  (2&lt;&lt;4); <span class="comment">// set pin select bits for P0.2 -&gt; Capture0.0</span>
00198         <span class="comment">// enable timer0 interrupt on rising edge of CR0 capture</span>
00199         T0CCR |= TCCR_CR0_I | TCCR_CR0_R;
00200     }
00201     <span class="keywordflow">else</span>
00202     {
00203         <span class="comment">// pin select</span>
00204         PINSEL0 &amp;= ~(3&lt;&lt;4); <span class="comment">// clear pin select bits for P0.2 -&gt; GPIO</span>
00205         <span class="comment">// disable timer0 interrupt on rising edge of CR0 capture</span>
00206         T0CCR &amp;= ~(TCCR_CR0_I | TCCR_CR0_R);
00207     }
00208 }
00209 
00210 <span class="keywordtype">void</span> timer0Capture1Init(<span class="keywordtype">int</span> on)
00211 {
00212     <span class="comment">// setup timer0 capture1</span>
00213     <span class="keywordflow">if</span>(on)
00214     {
00215         <span class="comment">// pin select</span>
00216         PINSEL0 &amp;= ~(3&lt;&lt;8); <span class="comment">// clear pin select bits for P0.4 -&gt; GPIO</span>
00217         PINSEL0 |=  (2&lt;&lt;8); <span class="comment">// set pin select bits for P0.4 -&gt; Capture0.1</span>
00218         <span class="comment">// enable timer0 interrupt on rising edge of CR1 capture</span>
00219         T0CCR |= TCCR_CR1_I | TCCR_CR1_R;
00220     }
00221     <span class="keywordflow">else</span>
00222     {
00223         <span class="comment">// pin select</span>
00224         PINSEL0 &amp;= ~(3&lt;&lt;8); <span class="comment">// clear pin select bits for P0.4 -&gt; GPIO</span>
00225         <span class="comment">// disable timer0 interrupt on rising edge of CR1 capture</span>
00226         T0CCR &amp;= ~(TCCR_CR1_I | TCCR_CR1_R);
00227     }
00228 }
00229 
00230 <span class="keywordtype">void</span> timer0Service(<span class="keywordtype">void</span>)
00231 {
00232     ISR_ENTRY();
00233     
00234     <span class="comment">// check the interrupt sources</span>
00235     <span class="keywordflow">if</span>(T0IR &amp; TIR_MR0I)
00236     {
00237         <span class="comment">// clear MR0 Interrupt</span>
00238         T0IR |= TIR_MR0I;
00239         <span class="keywordflow">if</span>(Timer0Pause)
00240             Timer0Pause--;
00241         Timer0OverflowCount++;
00242         <span class="comment">// if a user function is defined, execute it</span>
00243         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0MATCH0_INT])
00244             TimerIntrFunc[TIMER0MATCH0_INT]();
00245     }
00246     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T0IR &amp; TIR_CR0I)
00247     {
00248         <span class="comment">// clear CR0 Interrupt</span>
00249         T0IR |= TIR_CR0I;
00250         <span class="comment">// if a user function is defined, execute it</span>
00251         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0CAPTURE0_INT])
00252             TimerIntrFunc[TIMER0CAPTURE0_INT]();
00253     }
00254     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(T0IR &amp; TIR_CR1I)
00255     {
00256         <span class="comment">// clear CR1 Interrupt</span>
00257         T0IR |= TIR_CR1I;
00258         <span class="comment">// if a user function is defined, execute it</span>
00259         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER0CAPTURE1_INT])
00260             TimerIntrFunc[TIMER0CAPTURE1_INT]();
00261     }
00262     
00263     VICSoftIntClear = (1&lt;&lt;VIC_TIMER0);
00264     VICVectAddr = 0x00000000;             <span class="comment">// clear this interrupt from the VIC</span>
00265     ISR_EXIT();                           <span class="comment">// recover registers and return</span>
00266 }
00267 
00268 <span class="keywordtype">void</span> timer1Service(<span class="keywordtype">void</span>)
00269 {
00270     ISR_ENTRY();
00271 
00272     <span class="keywordflow">if</span>(T0IR &amp; TIR_MR0I)
00273     {
00274         <span class="comment">// clear MR0 Interrupt</span>
00275         T1IR |= TIR_MR0I;
00276         Timer1OverflowCount++;
00277         <span class="comment">// if a user function is defined, execute it</span>
00278         <span class="keywordflow">if</span>(TimerIntrFunc[TIMER1MATCH0_INT])
00279             TimerIntrFunc[TIMER1MATCH0_INT]();
00280     }
00281     
00282     VICSoftIntClear = (1&lt;&lt;VIC_TIMER1);
00283     VICVectAddr = 0x00000000;             <span class="comment">// clear this interrupt from the VIC</span>
00284     ISR_EXIT();                           <span class="comment">// recover registers and return</span>
00285 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jul 13 03:38:12 2004 for Procyon ARMlib-LPC2100 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
