<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: arch/at91/processor.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">arch</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">at91</a></div>
<h1>processor.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file processor.c \brief AT91SAM7S Processor Initialization and Support. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'processor.c'</span>
00005 <span class="comment">// Title        : AT91SAM7S Processor Initialization and Support</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2006</span>
00007 <span class="comment">// Created      : 2006.01.30</span>
00008 <span class="comment">// Revised      : 2006.02.20</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : ARM processors</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">//*****************************************************************************</span>
00018 
00019 <span class="comment">// Include the processor definitions</span>
00020 <span class="preprocessor">#include "at91sam7s64.h"</span>
00021 <span class="comment">// Include project-level definitions</span>
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 
00024 <span class="preprocessor">#include "processor.h"</span>
00025 
00026 <span class="comment">// The following functions must be writen in ARM mode this function called directly</span>
00027 <span class="comment">// by exception vector</span>
00028 <span class="keyword">extern</span> <span class="keywordtype">void</span> AT91F_Spurious_handler(<span class="keywordtype">void</span>);
00029 <span class="keyword">extern</span> <span class="keywordtype">void</span> AT91F_Default_IRQ_handler(<span class="keywordtype">void</span>);
00030 <span class="keyword">extern</span> <span class="keywordtype">void</span> AT91F_Default_FIQ_handler(<span class="keywordtype">void</span>);
00031 
00032 <span class="comment">// if you wish to change the interrupt priority for the system interrupt,</span>
00033 <span class="comment">// DO NOT EDIT THE LINE BELOW.  Add your desired definition for</span>
00034 <span class="comment">// xxx_INTERRUPT_LEVEL to your project's global.h and it will override</span>
00035 <span class="comment">// this default definition.</span>
00036 <span class="preprocessor">#ifndef SYS_INTERRUPT_LEVEL</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define SYS_INTERRUPT_LEVEL     AT91C_AIC_PRIOR_HIGHEST</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00041 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr SysIntFunc[SYSPID_NUM];
00042 
00043 
00044 <span class="comment">// Low-level processor initialization and clock control</span>
00045 <span class="comment">// ** requires valid stack setup</span>
00046 <span class="keywordtype">void</span> processorInit( <span class="keywordtype">void</span>)
00047 {
00048     <span class="comment">// make pointer to PMC to reduce code size</span>
00049     <span class="comment">//AT91PS_PMC pPMC = AT91C_BASE_PMC;</span>
00050     
00051     <span class="comment">// Set Flash wait state to 1WS</span>
00052     <span class="comment">// Single Cycle Access at Up to 30 MHz, or 40</span>
00053     AT91C_BASE_MC-&gt;MC_FMR = AT91C_MC_FWS_1FWS;
00054     
00055     <span class="comment">// Disable watchdog</span>
00056     AT91C_BASE_WDTC-&gt;WDTC_WDMR= AT91C_WDTC_WDDIS;
00057     
00058     <span class="comment">// Enable the Main Oscillator</span>
00059     <span class="comment">// SCK = 1/32768 = 30.51 uSecond</span>
00060     <span class="comment">// Start up time = 8 * 6 / SCK = 56 * 30.51 = 1.46484375 ms</span>
00061     AT91C_BASE_PMC-&gt;PMC_MOR = (( AT91C_CKGR_OSCOUNT &amp; (0x06&lt;&lt;8) ) | AT91C_CKGR_MOSCEN );
00062     <span class="comment">// Wait the startup time</span>
00063     <span class="keywordflow">while</span>(!(AT91C_BASE_PMC-&gt;PMC_SR &amp; AT91C_PMC_MOSCS));
00064     
00065     <span class="comment">// Set PLL and divider:</span>
00066     <span class="comment">// - div by 5 Fin = 3.6864 =(18.432 / 5)</span>
00067     <span class="comment">// - Mul 25+1: Fout =   95.8464 =(3.6864*26)</span>
00068     <span class="comment">// for 96 MHz the erroe is 0.16%</span>
00069     <span class="comment">// Field out NOT USED = 0</span>
00070     <span class="comment">// PLLCOUNT pll startup time estimate at : 0.844 ms</span>
00071     <span class="comment">// PLLCOUNT 28 = 0.000844 /(1/32768)</span>
00072     AT91C_BASE_PMC-&gt;PMC_PLLR = 
00073         ((AT91C_CKGR_DIV &amp; (OSC_DIV)) |
00074         (AT91C_CKGR_PLLCOUNT &amp; (28&lt;&lt;8)) |
00075         (AT91C_CKGR_MUL &amp; ((PLL_MUL-1)&lt;&lt;16)));
00076     
00077     <span class="comment">// Wait for PLL to lock and for clock to become ready</span>
00078     <span class="keywordflow">while</span>(!(AT91C_BASE_PMC-&gt;PMC_SR &amp; AT91C_PMC_LOCK));
00079     <span class="keywordflow">while</span>(!(AT91C_BASE_PMC-&gt;PMC_SR &amp; AT91C_PMC_MCKRDY));
00080     
00081     <span class="comment">// Set Processor Clock and Master Clock to PLL Clock/2</span>
00082     AT91C_BASE_PMC-&gt;PMC_MCKR = AT91C_PMC_PRES_CLK_2;
00083     <span class="keywordflow">while</span>(!(AT91C_BASE_PMC-&gt;PMC_SR &amp; AT91C_PMC_MCKRDY));
00084     
00085     AT91C_BASE_PMC-&gt;PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK;
00086     <span class="keywordflow">while</span>(!(AT91C_BASE_PMC-&gt;PMC_SR &amp; AT91C_PMC_MCKRDY));
00087 
00088     <span class="comment">// if 18.432MHz crystal, master clock now 47.9232MHz -&gt; 48MHz for USB operation</span>
00089 
00090     <span class="comment">// setup initial AIC config</span>
00091     processorAicInit();
00092     <span class="comment">// attach the system interrupt distributer</span>
00093     processorAicAttach(AT91C_ID_SYS, (SYS_INTERRUPT_LEVEL|AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL), processorSysIntService);
00094 }
00095 
00096 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> processorDisableInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr_mask)
00097 {
00098     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr;
00099     <span class="comment">// read CPSR</span>
00100     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"mrs  %0, cpsr"</span> : <span class="stringliteral">"=r"</span> (cpsr) : );
00101     <span class="comment">// set interrupt disable bit and write CPSR</span>
00102     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"msr  cpsr, %0"</span> : : <span class="stringliteral">"r"</span> (cpsr|(cpsr_mask&amp;CPSR_MASK_INT)) );
00103     <span class="comment">// return the original CPSR</span>
00104     <span class="keywordflow">return</span> cpsr;
00105 }
00106 
00107 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> processorEnableInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr_mask)
00108 {
00109     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr;
00110     <span class="comment">// read CPSR</span>
00111     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"mrs  %0, cpsr"</span> : <span class="stringliteral">"=r"</span> (cpsr) : );
00112     <span class="comment">// clear interrupt disable bit(s) and write CPSR</span>
00113     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"msr  cpsr, %0"</span> : : <span class="stringliteral">"r"</span> (cpsr&amp;~(cpsr_mask&amp;CPSR_MASK_INT)) );
00114     <span class="comment">// return the original CPSR</span>
00115     <span class="keywordflow">return</span> cpsr;
00116 }
00117 
00118 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> processorRestoreInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr_orig)
00119 {
00120     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsr;
00121     <span class="comment">// read CPSR</span>
00122     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"mrs  %0, cpsr"</span> : <span class="stringliteral">"=r"</span> (cpsr) : );
00123     <span class="comment">// clear interrupt disable bit(s) and write CPSR</span>
00124     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"msr  cpsr, %0"</span> : : <span class="stringliteral">"r"</span> ( (cpsr&amp;~CPSR_MASK_INT) | (cpsr_orig&amp;CPSR_MASK_INT)) );
00125     <span class="comment">// return the original CPSR</span>
00126     <span class="keywordflow">return</span> cpsr;
00127 }
00128 
00129 <span class="keywordtype">void</span> processorAicInit(<span class="keywordtype">void</span>)
00130 {
00131     <span class="keywordtype">int</span> i;
00132 
00133     <span class="comment">// Set up the default interrupt handler vectors</span>
00134     AT91C_BASE_AIC-&gt;AIC_SVR[0] = (<span class="keywordtype">unsigned</span> int)AT91F_Default_FIQ_handler;
00135     <span class="keywordflow">for</span>(i=1; i&lt;31; i++)
00136     {
00137         AT91C_BASE_AIC-&gt;AIC_SVR[i] = (<span class="keywordtype">unsigned</span> int)AT91F_Default_IRQ_handler;
00138     }
00139     AT91C_BASE_AIC-&gt;AIC_SPU  = (<span class="keywordtype">unsigned</span> int)AT91F_Spurious_handler;
00140 }
00141 
00142 <span class="keywordtype">void</span> processorAicAttach(<span class="keywordtype">int</span> pid, <span class="keywordtype">int</span> srcmode, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00143 {
00144     <span class="comment">// first disable the interrupt at the AIC</span>
00145     AT91C_BASE_AIC-&gt;AIC_IDCR = (1&lt;&lt;pid);
00146     <span class="comment">// set a new interrupt handler routine pointer</span>
00147     AT91C_BASE_AIC-&gt;AIC_SVR[pid] = (<span class="keywordtype">unsigned</span> int)userFunc;
00148     <span class="comment">// configure the interrupt</span>
00149     AT91C_BASE_AIC-&gt;AIC_SMR[pid] = srcmode;
00150     <span class="comment">// clear the interrupt flag in the AIC</span>
00151     AT91C_BASE_AIC-&gt;AIC_ICCR = (1&lt;&lt;pid);
00152     <span class="comment">// enable the interrupt at the AIC</span>
00153     AT91C_BASE_AIC-&gt;AIC_IECR = (1&lt;&lt;pid);
00154 }
00155 
00156 <span class="keywordtype">void</span> processorAicDetach(<span class="keywordtype">int</span> pid)
00157 {
00158     <span class="comment">// first disable the interrupt at the AIC</span>
00159     AT91C_BASE_AIC-&gt;AIC_IDCR = (1&lt;&lt;pid);
00160     <span class="comment">// clear the interrupt flag in the AIC</span>
00161     AT91C_BASE_AIC-&gt;AIC_ICCR = (1&lt;&lt;pid);
00162     <span class="comment">// clear the interrupt handler routine pointer</span>
00163     AT91C_BASE_AIC-&gt;AIC_SVR[pid] = 0;
00164 }
00165 
00166 <span class="keywordtype">void</span> processorAicAttachSys(<span class="keywordtype">int</span> syspid, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00167 {
00168     <span class="comment">// make sure the interrupt number is within bounds</span>
00169     <span class="keywordflow">if</span>(syspid &lt; SYSPID_NUM)
00170     {
00171         <span class="comment">// set the interrupt service to run the supplied user function</span>
00172         SysIntFunc[syspid] = userFunc;
00173     }
00174 }
00175 
00176 <span class="keywordtype">void</span> processorSysIntService(<span class="keywordtype">void</span>)
00177 {
00178     <span class="comment">// service most likely SYSINT interrupt sources first.</span>
00179     <span class="comment">// in each if(), we are careful to check only *enabled* interrupt sources!</span>
00180 
00181     <span class="comment">// check if sysint caused by PITC (periodic interval timer)</span>
00182     <span class="keywordflow">if</span>( (AT91C_BASE_PITC-&gt;PITC_PIMR &amp; AT91C_PITC_PITIEN) &amp;&amp; 
00183         (AT91C_BASE_PITC-&gt;PITC_PISR &amp; AT91C_PITC_PITS) )
00184     {
00185         <span class="keywordflow">if</span>(SysIntFunc[SYSPID_PITC]) SysIntFunc[SYSPID_PITC]();
00186         <span class="keywordflow">return</span>;
00187     }
00188     <span class="comment">// check if sysint caused by DBGU (debug uart)</span>
00189     <span class="keywordflow">if</span>(AT91C_BASE_DBGU-&gt;DBGU_IMR &amp; AT91C_BASE_DBGU-&gt;DBGU_CSR)
00190     {
00191         <span class="keywordflow">if</span>(SysIntFunc[SYSPID_DBGU]) SysIntFunc[SYSPID_DBGU]();
00192         <span class="keywordflow">return</span>;
00193     }
00194     <span class="comment">// check if sysint caused by RTT (real-time timer)</span>
00195     <span class="keywordflow">if</span>( ((AT91C_BASE_RTTC-&gt;RTTC_RTMR&gt;&gt;16) &amp; AT91C_BASE_RTTC-&gt;RTTC_RTSR) &amp;
00196             (AT91C_RTTC_RTTINC|AT91C_RTTC_ALMS) )
00197     {
00198         <span class="keywordflow">if</span>(SysIntFunc[SYSPID_RTTC]) SysIntFunc[SYSPID_RTTC]();
00199         <span class="keywordflow">return</span>;
00200     }
00201     <span class="comment">// check if sysint caused by EFC (embedded flash controller)</span>
00202     <span class="keywordflow">if</span>( (AT91C_BASE_MC-&gt;MC_FMR &amp; AT91C_BASE_MC-&gt;MC_FSR) &amp;
00203             (AT91C_MC_FRDY|AT91C_MC_LOCKE|AT91C_MC_PROGE) )
00204     {
00205         <span class="keywordflow">if</span>(SysIntFunc[SYSPID_EFC]) SysIntFunc[SYSPID_EFC]();
00206         <span class="keywordflow">return</span>;
00207     }
00208     <span class="comment">// check if sysint caused by PMC (power management controller)</span>
00209     <span class="keywordflow">if</span>( AT91C_BASE_PMC-&gt;PMC_IER &amp; AT91C_BASE_PMC-&gt;PMC_SR )
00210     {
00211         <span class="keywordflow">if</span>(SysIntFunc[SYSPID_PMC]) SysIntFunc[SYSPID_PMC]();
00212         <span class="keywordflow">return</span>;
00213     }
00214 
00215     <span class="comment">// could not determine source of interrupt</span>
00216     <span class="comment">// throw error?</span>
00217 }
00218 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
