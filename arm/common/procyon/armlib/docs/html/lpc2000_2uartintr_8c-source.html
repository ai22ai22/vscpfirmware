<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: arch/lpc2000/uartintr.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">arch</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">lpc2000</a></div>
<h1>uartintr.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uartintr.c \brief UART driver for ARM LPC2000 16550 with interrupts. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uartintr.c'</span>
00005 <span class="comment">// Title        : UART driver for ARM LPC2000 16550 with interrupts</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2004-2006</span>
00007 <span class="comment">// Created      : 4/3/2004</span>
00008 <span class="comment">// Revised      : 4/11/2006</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Philips ARM LPC2000 Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00019 <span class="preprocessor">#include "LPC2000.h"</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00022 <span class="preprocessor">#include "processor.h"</span>
00023 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00024 <span class="preprocessor">#include "uartintr.h"</span>
00025 
00026 <span class="comment">// receive and transmit buffers</span>
00027 cBuffer uartRxBuffer[2];            <span class="comment">///&lt; uart receive buffer</span>
00028 <span class="comment"></span>cBuffer uartTxBuffer[2];            <span class="comment">///&lt; uart transmit buffer</span>
00029 <span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uart0RxData[<a class="code" href="group__uartdma__at91.html#ga44">UART0_RX_BUFFER_SIZE</a>];
00030 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uart1RxData[<a class="code" href="group__uartdma__at91.html#ga46">UART1_RX_BUFFER_SIZE</a>];
00031 <span class="comment"></span>
00032 <span class="comment">//! enable and initialize the uart</span>
00033 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="group__uart__at91.html#ga0">uart0Init</a>(uint16_t baud, uint8_t mode, uint8_t fifomode)
00034 {
00035     <span class="comment">// set pin-select register to connect to UART0</span>
00036     PINSEL0 = (PINSEL0 &amp; ~U0_PINMASK) | U0_PINSEL;
00037     <span class="comment">// reset and initialize the UART</span>
00038     U0IER = 0;      <span class="comment">// disable all interrupt sources</span>
00039     U0IIR;          <span class="comment">// clear any pending interrupts</span>
00040     U0FCR = (UFCR_TX_FIFO_RESET|UFCR_RX_FIFO_RESET);    <span class="comment">// reset the Tx/Rx FIFOs</span>
00041     <span class="comment">// set the baudrate divisor</span>
00042     U0LCR = ULCR_DLAB_ENABLE;   <span class="comment">// set divisor access bit (permits modification of divisors)</span>
00043     U0DLL = (baud);             <span class="comment">// set the baud division</span>
00044     U0DLM = (baud&gt;&gt;8);
00045     U0LCR = 0;                  <span class="comment">// reset DLAB (normal operation)</span>
00046     <span class="comment">// set line parameters and fifo mode</span>
00047     U0LCR = mode;
00048     U0FCR = fifomode;
00049     <span class="comment">// with uart configured, clear line status and receive registers</span>
00050     U0RBR; U0LSR;
00051     <span class="comment">// initialize buffers</span>
00052     <a class="code" href="group__uartdma__at91.html#ga3">uart0InitBuffers</a>();
00053     <span class="comment">// attach interrupt handler</span>
00054     processorVicAttach(VIC_UART0, 0, <a class="code" href="group__uartdma__at91.html#ga25">uart0Service</a>);
00055     <span class="comment">// enable receive interrupt</span>
00056     U0IER |= UIER_ERBFI;
00057 }
00058 
00059 <span class="keywordtype">void</span> uart1Init(uint16_t baud, uint8_t mode, uint8_t fifomode)
00060 {
00061     <span class="comment">// set pin-select register to connect to UART1</span>
00062     PINSEL0 = (PINSEL0 &amp; ~U1_PINMASK) | U1_PINSEL;
00063     <span class="comment">// reset and initialize the UART</span>
00064     U1IER = 0;      <span class="comment">// disable all interrupt sources</span>
00065     U1IIR;          <span class="comment">// clear any pending interrupts</span>
00066     U1FCR = (UFCR_TX_FIFO_RESET|UFCR_RX_FIFO_RESET);    <span class="comment">// reset the Tx/Rx FIFOs</span>
00067     <span class="comment">// set the baudrate divisor</span>
00068     U1LCR = ULCR_DLAB_ENABLE;   <span class="comment">// set divisor access bit (permits modification of divisors)</span>
00069     U1DLL = (baud);             <span class="comment">// set the baud division</span>
00070     U1DLM = (baud&gt;&gt;8);
00071     U1LCR = 0;                  <span class="comment">// reset DLAB (normal operation)</span>
00072     <span class="comment">// set line parameters and fifo mode</span>
00073     U1LCR = mode;
00074     U1FCR = fifomode;
00075     <span class="comment">// with uart configured, clear line status and receive registers</span>
00076     U1RBR; U1LSR;
00077     <span class="comment">// initialize buffers</span>
00078     uart1InitBuffers();
00079     <span class="comment">// attach interrupt handler</span>
00080     processorVicAttach(VIC_UART1, 0, uart1Service);
00081     <span class="comment">// enable receive interrupt</span>
00082     U1IER |= UIER_ERBFI;
00083 }
00084 
<a name="l00085"></a><a class="code" href="group__uartdma__at91.html#ga3">00085</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga3">uart0InitBuffers</a>(<span class="keywordtype">void</span>)
00086 {
00087     <span class="comment">// initialize the UART0 buffers</span>
00088     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[0], uart0RxData, <a class="code" href="group__uartdma__at91.html#ga44">UART0_RX_BUFFER_SIZE</a>);
00089     <span class="comment">//bufferInit(&amp;uartTxBuffer[0], uart0TxData, UART0_TX_BUFFER_SIZE);</span>
00090 }
00091 
00092 <span class="keywordtype">void</span> uart1InitBuffers(<span class="keywordtype">void</span>)
00093 {
00094     <span class="comment">// initialize the UART1 buffers</span>
00095     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[1], uart1RxData, <a class="code" href="group__uartdma__at91.html#ga46">UART1_RX_BUFFER_SIZE</a>);
00096     <span class="comment">//bufferInit(&amp;uartTxBuffer[1], uart1TxData, UART1_TX_BUFFER_SIZE);</span>
00097 }
00098 
00099 cBuffer* uart0GetRxBuffer(<span class="keywordtype">void</span>)
00100 {
00101     <span class="comment">// return rx buffer pointer</span>
00102     <span class="keywordflow">return</span> &amp;uartRxBuffer[0];
00103 }
00104 
00105 cBuffer* uart1GetRxBuffer(<span class="keywordtype">void</span>)
00106 {
00107     <span class="comment">// return rx buffer pointer</span>
00108     <span class="keywordflow">return</span> &amp;uartRxBuffer[1];
00109 }
00110 
<a name="l00111"></a><a class="code" href="group__uart__at91.html#ga3">00111</a> <span class="keywordtype">int</span> <a class="code" href="group__uart__at91.html#ga3">uart0SendByte</a>(<span class="keywordtype">int</span> data)
00112 {
00113     <span class="comment">// wait for tx buffer ready</span>
00114     <span class="keywordflow">while</span>( !(U0LSR &amp; ULSR_THRE) );
00115     <span class="comment">// send the character</span>
00116     <span class="keywordflow">return</span> (U0THR = data);
00117 }
00118 
00119 <span class="keywordtype">int</span> uart1SendByte(<span class="keywordtype">int</span> data)
00120 {
00121     <span class="comment">// wait for tx buffer ready</span>
00122     <span class="keywordflow">while</span>( !(U1LSR &amp; ULSR_THRE) );
00123     <span class="comment">// send the character</span>
00124     <span class="keywordflow">return</span> (U1THR = data);
00125 }
00126 
<a name="l00127"></a><a class="code" href="group__uart__at91.html#ga6">00127</a> <span class="keywordtype">int</span> <a class="code" href="group__uart__at91.html#ga6">uart0GetByte</a>(<span class="keywordtype">void</span>)
00128 {
00129     <span class="comment">// if character is available, return it</span>
00130     <span class="keywordflow">if</span>(uartRxBuffer[0].datalength)
00131         <span class="keywordflow">return</span> <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartRxBuffer[0]);
00132     <span class="comment">// otherwise, return failure</span>
00133     <span class="keywordflow">return</span> -1;
00134 }
00135 
00136 <span class="keywordtype">int</span> uart1GetByte(<span class="keywordtype">void</span>)
00137 {   
00138     <span class="comment">// if character is available, return it</span>
00139     <span class="keywordflow">if</span>(uartRxBuffer[1].datalength)      <span class="comment">// check if character is available</span>
00140         <span class="keywordflow">return</span> <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartRxBuffer[1]);    <span class="comment">// return character</span>
00141     <span class="comment">// otherwise, return failure</span>
00142     <span class="keywordflow">return</span> -1;
00143 }
00144 
<a name="l00145"></a><a class="code" href="group__uartdma__at91.html#ga25">00145</a> <span class="keywordtype">void</span> <a class="code" href="group__uartdma__at91.html#ga25">uart0Service</a>(<span class="keywordtype">void</span>)
00146 {
00147     uint8_t intr_flags;
00148 
00149 <span class="comment">//  ISR_ENTRY();</span>
00150     
00151     <span class="comment">// service pending interrupts until the interrupt status register is clear</span>
00152     <span class="keywordflow">while</span>( !((intr_flags=U0IIR) &amp; UIIR_NO_INT) )
00153     {
00154         <span class="comment">// check the interrupt source</span>
00155         <span class="keywordflow">switch</span>(intr_flags &amp; UIIR_ID_MASK)
00156         {
00157         <span class="keywordflow">case</span> UIIR_RLS_INT:  <span class="comment">// receive line status interrupt</span>
00158             U0LSR;                  <span class="comment">// clear interrupt by reading status</span>
00159             <span class="keywordflow">break</span>;
00160         <span class="keywordflow">case</span> UIIR_CTI_INT:  <span class="comment">// character timeout interrupt</span>
00161         <span class="keywordflow">case</span> UIIR_RDA_INT:  <span class="comment">// receive data available interrupt</span>
00162             <span class="keywordflow">do</span> { <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartRxBuffer[1], U0RBR); } <span class="keywordflow">while</span>(U0LSR &amp; ULSR_RDR);
00163             <span class="keywordflow">break</span>;
00164         <span class="keywordflow">case</span> UIIR_THRE_INT: <span class="comment">// transmit holding register empty</span>
00165             <span class="keywordflow">break</span>;
00166         <span class="keywordflow">default</span>:            <span class="comment">// unknown/unhandled interrupt</span>
00167             U0LSR;                  <span class="comment">// read registers to clear</span>
00168             U0RBR;
00169             <span class="keywordflow">break</span>;
00170         }
00171     }
00172 
00173     VICSoftIntClear = (1&lt;&lt;VIC_UART0);   <span class="comment">// clear software interrupt</span>
00174     VICVectAddr = 0x00000000;           <span class="comment">// clear the VIC</span>
00175 <span class="comment">//  ISR_EXIT();</span>
00176 }
00177 
00178 <span class="keywordtype">void</span> uart1Service(<span class="keywordtype">void</span>)
00179 {
00180     uint8_t intr_flags;
00181 
00182 <span class="comment">//  ISR_ENTRY();</span>
00183 
00184     <span class="comment">// service pending interrupts until the interrupt status register is clear</span>
00185     <span class="keywordflow">while</span>( !((intr_flags=U1IIR) &amp; UIIR_NO_INT) )
00186     {
00187         <span class="comment">// check the interrupt source</span>
00188         <span class="keywordflow">switch</span>(intr_flags &amp; UIIR_ID_MASK)
00189         {
00190         <span class="keywordflow">case</span> UIIR_RLS_INT:  <span class="comment">// receive line status interrupt</span>
00191             U1LSR;                  <span class="comment">// clear interrupt by reading status</span>
00192             <span class="keywordflow">break</span>;
00193         <span class="keywordflow">case</span> UIIR_CTI_INT:  <span class="comment">// character timeout interrupt</span>
00194         <span class="keywordflow">case</span> UIIR_RDA_INT:  <span class="comment">// receive data available interrupt</span>
00195             <span class="keywordflow">do</span> { <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartRxBuffer[1], U1RBR); } <span class="keywordflow">while</span>(U1LSR &amp; ULSR_RDR);
00196             <span class="keywordflow">break</span>;
00197         <span class="keywordflow">case</span> UIIR_THRE_INT: <span class="comment">// transmit holding register empty</span>
00198             <span class="keywordflow">break</span>;
00199         <span class="keywordflow">case</span> UIIR_MS_INT:   <span class="comment">// MODEM Status</span>
00200             U1MSR;                  <span class="comment">// read MSR to clear</span>
00201             <span class="keywordflow">break</span>;
00202         <span class="keywordflow">default</span>:            <span class="comment">// unknown/unhandled interrupt</span>
00203             U1LSR;                  <span class="comment">// read registers to clear</span>
00204             U1RBR;
00205             U1MSR;
00206             <span class="keywordflow">break</span>;
00207         }
00208     }
00209     
00210     VICSoftIntClear = (1&lt;&lt;VIC_UART1);   <span class="comment">// clear software interrupt</span>
00211     VICVectAddr = 0x00000000;           <span class="comment">// clear the VIC</span>
00212 <span class="comment">//  ISR_EXIT();</span>
00213 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:58 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
