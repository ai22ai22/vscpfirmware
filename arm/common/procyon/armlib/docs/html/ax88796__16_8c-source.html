<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon ARMlib: net/ax88796_16.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000005.html">net</a></div>
<h1>ax88796_16.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ax88796.c \brief ASIX AX88796 Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ax88796.c'</span>
00005 <span class="comment">// Title        : ASIX AX88796 Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 10/22/2002</span>
00008 <span class="comment">// Revised      : 8/21/2005</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description  : This driver provides initialization and transmit/receive</span>
00014 <span class="comment">//      functions for the ASIX AX88796 10/100Mb Ethernet Controller and PHY.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// Based in part on code by Louis Beaudoin (www.embedded-creations.com).</span>
00017 <span class="comment">// Thanks to Adam Dunkels and Louis Beaudoin for providing the initial</span>
00018 <span class="comment">// structure in which to write this driver.</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "timer.h"</span>
00024 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="ax88796_8h.html">ax88796.h</a>"</span>
00027 
00028 <span class="comment">// include configuration</span>
00029 <span class="preprocessor">#include "<a class="code" href="ax88796conf_8h.html">ax88796conf.h</a>"</span>
00030 
00031 <span class="comment">// pointers to locations in the ax88796 receive buffer</span>
00032 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NextPage;              <span class="comment">// page pointer to next Rx packet</span>
00033 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CurrentRetreiveAddress; <span class="comment">// DMA address for read Rx packet location</span>
00034 
00035 
<a name="l00036"></a><a class="code" href="group__nic.html#ga0">00036</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00037 {
00038     ax88796Init();
00039 }
00040 
<a name="l00041"></a><a class="code" href="group__nic.html#ga1">00041</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00042 {
00043     ax88796BeginPacketSend(len);
00044     ax88796SendPacketData(packet, len);
00045     ax88796EndPacketSend();
00046 }
00047 
<a name="l00048"></a><a class="code" href="group__nic.html#ga2">00048</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00049 {
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00051     
00052     packetLength = ax88796BeginPacketRetreive();
00053 
00054     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00055     <span class="keywordflow">if</span>( !packetLength )
00056         <span class="keywordflow">return</span> 0;
00057 
00058     <span class="comment">// drop anything too big for the buffer</span>
00059     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00060     {
00061         ax88796EndPacketRetreive();
00062         <span class="keywordflow">return</span> 0;
00063     }
00064     
00065     <span class="comment">// copy the packet data into the uIP packet buffer</span>
00066     ax88796RetreivePacketData( packet, packetLength );
00067     ax88796EndPacketRetreive();
00068         
00069     <span class="keywordflow">return</span> packetLength;
00070 }
00071 
00072 <span class="keywordtype">void</span> nicGetMacAddress(u08* macaddr)
00073 {
00074     u08 tempCR;
00075     <span class="comment">// switch register pages</span>
00076     tempCR = ax88796Read(CR);
00077     ax88796Write(CR,tempCR|PS0);
00078     <span class="comment">// read MAC address registers</span>
00079     *macaddr++ = ax88796Read(PAR0);
00080     *macaddr++ = ax88796Read(PAR1);
00081     *macaddr++ = ax88796Read(PAR2);
00082     *macaddr++ = ax88796Read(PAR3);
00083     *macaddr++ = ax88796Read(PAR4);
00084     *macaddr++ = ax88796Read(PAR5);
00085     <span class="comment">// switch register pages back</span>
00086     ax88796Write(CR,tempCR);
00087 }
00088 
00089 <span class="keywordtype">void</span> nicSetMacAddress(u08* macaddr)
00090 {
00091     u08 tempCR;
00092     <span class="comment">// switch register pages</span>
00093     tempCR = ax88796Read(CR);
00094     ax88796Write(CR,tempCR|PS0);
00095     <span class="comment">// write MAC address registers</span>
00096     ax88796Write(PAR0, *macaddr++);
00097     ax88796Write(PAR1, *macaddr++);
00098     ax88796Write(PAR2, *macaddr++);
00099     ax88796Write(PAR3, *macaddr++);
00100     ax88796Write(PAR4, *macaddr++);
00101     ax88796Write(PAR5, *macaddr++);
00102     <span class="comment">// switch register pages back</span>
00103     ax88796Write(CR,tempCR);
00104 }
00105 
<a name="l00106"></a><a class="code" href="group__nic.html#ga5">00106</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga5">nicRegDump</a>(<span class="keywordtype">void</span>)
00107 {
00108     ax88796RegDump();
00109 }
00110 
00111 
00112 <span class="keywordtype">void</span> ax88796SetupPorts(<span class="keywordtype">void</span>)
00113 {
00114 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00115 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00116 <span class="comment">//  sbi(MCUCR, SRE);</span>
00117 <span class="comment">//  sbi(MCUCR, SRW10);</span>
00118 <span class="comment">//  sbi(XMCRA, SRW00);</span>
00119 <span class="comment">//  sbi(XMCRA, SRW01);</span>
00120 <span class="comment">//  sbi(XMCRA, SRW11);</span>
00121 <span class="preprocessor">#else</span>
00122 <span class="preprocessor"></span>    <span class="comment">// set address port to output</span>
00123     AX88796_ADDRESS_DDR = AX88796_ADDRESS_MASK;
00124     
00125     <span class="comment">// set data port to input with pull-ups</span>
00126     AX88796_DATA_DDR = 0x00;
00127     AX88796_DATA_PORT = 0xFF;
00128 
00129     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00130     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN );
00131     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN );
00132     <span class="comment">// set the read and write pins to output</span>
00133     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_READPIN );
00134     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_WRITEPIN );
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00137 <span class="comment">//  sbi( AX88796_RESET_DDR, AX88796_RESET_PIN );</span>
00138 }
00139 
00140 
00141 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00142 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00143 {
00144     *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address) = data;
00145 }
00146 <span class="preprocessor">#else</span>
00147 <span class="preprocessor"></span><span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00148 {
00149     <span class="comment">// assert the address</span>
00150     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00151 
00152     <span class="comment">// set data bus as output and place data on bus</span>
00153     AX88796_DATA_DDR = 0xFF;
00154     AX88796_DATA_PORT = data;
00155     
00156     <span class="comment">// clock write pin</span>
00157     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00158     nop();
00159     nop();
00160     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00161     
00162     <span class="comment">// set data bus back to input with pullups enabled</span>
00163     AX88796_DATA_DDR = 0x00;
00164     AX88796_DATA_PORT = 0xFF;
00165 }
00166 <span class="preprocessor">#endif</span>
00167 <span class="preprocessor"></span>
00168 
00169 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00170 <span class="preprocessor"></span><span class="keyword">inline</span> u08 ax88796Read(u08 address)
00171 {
00172     <span class="keywordflow">return</span> *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address);
00173 }
00174 <span class="preprocessor">#else</span>
00175 <span class="preprocessor"></span>u08 ax88796Read(u08 address)
00176 {
00177     u08 data;
00178    
00179     <span class="comment">// assert the address</span>
00180     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00181 
00182     <span class="comment">// assert read</span>
00183     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00184     nop();
00185     nop();
00186     <span class="comment">// read in the data</span>
00187     data = AX88796_DATA_PIN;
00188 
00189     <span class="comment">// negate read</span>
00190     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00191 
00192     <span class="keywordflow">return</span> data;
00193 }
00194 <span class="preprocessor">#endif                       </span>
00195 <span class="preprocessor"></span>
00196 
00197 <span class="keywordtype">void</span> ax88796Init(<span class="keywordtype">void</span>)
00198 {
00199     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tcrFduFlag;
00200     
00201     <span class="comment">// initialize I/O ports</span>
00202     ax88796SetupPorts();
00203 
00204     <span class="comment">// do a hard reset</span>
00205 <span class="comment">//  sbi(AX88796_RESET_PORT, AX88796_RESET_PIN);</span>
00206 <span class="comment">//  delay_ms(100);</span>
00207 <span class="comment">//  cbi(AX88796_RESET_PORT, AX88796_RESET_PIN);</span>
00208 
00209     <span class="comment">// do soft reset</span>
00210     ax88796Write(ISR, ax88796Read(ISR));
00211     delay_ms(50);
00212 
00213     <span class="comment">// wait for PHY to come out of reset</span>
00214     ax88796Read(RSTPORT);
00215     <span class="keywordflow">while</span>(ax88796Read(TR) &amp; RST_B);
00216 
00217     <span class="comment">// if the phy has not completed autonegotiation,</span>
00218     <span class="comment">// power it down, wait 2.5sec, and then re-enable autonegotioation</span>
00219     <span class="keywordflow">if</span>(!(ax88796Read(TR) &amp; AUTOD))
00220     {
00221         ax88796WriteMii(0x10,0x00,0x0800);
00222         delay_ms(2500);
00223         ax88796WriteMii(0x10,0x00,0x1200);
00224     }
00225 
00226     ax88796Write(CR,(RD2|STOP));        <span class="comment">// stop the NIC, abort DMA, page 0</span>
00227     delay_ms(5);                        <span class="comment">// make sure nothing is coming in or going out</span>
00228     ax88796Write(DCR,DCR_INIT);    
00229     ax88796Write(RBCR0,0x00);
00230     ax88796Write(RBCR1,0x00);
00231     ax88796Write(IMR,0x00);
00232     ax88796Write(ISR,0xFF);
00233     ax88796Write(RCR,0x20);
00234     ax88796Write(BNRY,RXSTART_INIT);
00235     ax88796Write(PSTART,RXSTART_INIT);
00236     ax88796Write(PSTOP,RXSTOP_INIT);
00237     
00238     <span class="comment">// switch to page 1</span>
00239     ax88796Write(CR,(PS0|RD2|STOP));
00240     <span class="comment">// write mac address</span>
00241     ax88796Write(PAR0, AX88796_MAC0);
00242     ax88796Write(PAR1, AX88796_MAC1);
00243     ax88796Write(PAR2, AX88796_MAC2);
00244     ax88796Write(PAR3, AX88796_MAC3);
00245     ax88796Write(PAR4, AX88796_MAC4);
00246     ax88796Write(PAR5, AX88796_MAC5);
00247     <span class="comment">// set start point</span>
00248     ax88796Write(CURR,RXSTART_INIT+1);
00249 
00250     ax88796Write(CR,(RD2|START));
00251     ax88796Write(RCR,RCR_INIT);
00252 
00253     <span class="keywordflow">if</span>(ax88796Read(GPI) &amp; I_SPD)        <span class="comment">// check PHY speed setting</span>
00254         tcrFduFlag = FDU;               <span class="comment">// if 100base, do full duplex</span>
00255     <span class="keywordflow">else</span>
00256         tcrFduFlag = 0;                 <span class="comment">// if 10base, do half duplex</span>
00257         
00258     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00259 
00260     ax88796Write(GPOC,MPSEL);           <span class="comment">// select media interface</span>
00261   
00262     ax88796Write(TPSR,TXSTART_INIT);
00263 
00264     ax88796Write(CR,(RD2|STOP));
00265     ax88796Write(DCR,DCR_INIT);
00266     ax88796Write(CR,(RD2|START));
00267     ax88796Write(ISR,0xFF);
00268     ax88796Write(IMR,IMR_INIT);
00269     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00270 
00271     <span class="comment">//test</span>
00272 <span class="comment">/*</span>
00273 <span class="comment">    while(1)</span>
00274 <span class="comment">    {</span>
00275 <span class="comment">        vt100SetCursorPos(18,0);</span>
00276 <span class="comment">        ax88796RegDump();</span>
00277 <span class="comment">    }</span>
00278 <span class="comment">*/</span>
00279 }
00280 
00281 
00282 <span class="keywordtype">void</span> ax88796BeginPacketSend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength)
00283 {
00284     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendPacketLength;
00285     sendPacketLength = (packetLength&gt;=ETHERNET_MIN_PACKET_LENGTH)?
00286                         (packetLength):(ETHERNET_MIN_PACKET_LENGTH);
00287     
00288     <span class="comment">// start the NIC</span>
00289     ax88796Write(CR,(RD2|START));
00290     
00291     <span class="comment">// still transmitting a packet - wait for it to finish</span>
00292     <span class="keywordflow">while</span>( ax88796Read(CR) &amp; TXP );
00293 
00294     <span class="comment">//load beginning page for transmit buffer</span>
00295     ax88796Write(TPSR,TXSTART_INIT);
00296     
00297     <span class="comment">//set start address for remote DMA operation</span>
00298     ax88796Write(RSAR0,0x00);
00299     ax88796Write(RSAR1,0x40);
00300     
00301     <span class="comment">//clear the packet stored interrupt</span>
00302     ax88796Write(ISR, PTX);
00303 
00304     <span class="comment">//load data byte count for remote DMA</span>
00305     ax88796Write(RBCR0, packetLength);
00306     ax88796Write(RBCR1, packetLength&gt;&gt;8);
00307 
00308     ax88796Write(TBCR0, sendPacketLength);
00309     ax88796Write(TBCR1, sendPacketLength&gt;&gt;8);
00310     
00311     <span class="comment">//do remote write operation</span>
00312     ax88796Write(CR,(RD1|START));
00313 }
00314 
00315 
00316 <span class="keywordtype">void</span> ax88796SendPacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00317 {
00318     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00319     
00320     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00321         ax88796Write(RDMAPORT, localBuffer[i]);
00322 }
00323 
00324 
00325 <span class="keywordtype">void</span> ax88796EndPacketSend(<span class="keywordtype">void</span>)
00326 {
00327     <span class="comment">// send the contents of the transmit buffer onto the network</span>
00328     ax88796Write(CR,(RD2|TXP));
00329     
00330     <span class="comment">// clear the remote DMA interrupt</span>
00331     ax88796Write(ISR, RDC);
00332 }
00333 
00334 
00335 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796BeginPacketRetreive(<span class="keywordtype">void</span>)
00336 {
00337     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> writePagePtr;
00338     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> readPagePtr;
00339     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00340     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00341     
00342     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pageheader[4];
00343     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rxlen;
00344     
00345     <span class="comment">// check for and handle an overflow</span>
00346     ax88796ProcessInterrupt();
00347     
00348     <span class="comment">// read CURR from page 1</span>
00349     ax88796Write(CR,(PS0|RD2|START));
00350     writePagePtr = ax88796Read(CURR);
00351     <span class="comment">// read the boundary register from page 0</span>
00352     ax88796Write(CR,(RD2|START));
00353     bnryPagePtr = ax88796Read(BNRY);
00354 
00355     <span class="comment">// first packet is at page bnryPtr+1</span>
00356     readPagePtr = bnryPagePtr+1;
00357     <span class="keywordflow">if</span>(readPagePtr &gt;= RXSTOP_INIT) readPagePtr = RXSTART_INIT;
00358     
00359     <span class="comment">// return if there is no packet in the buffer</span>
00360     <span class="keywordflow">if</span>( readPagePtr == writePagePtr )
00361     {
00362         <span class="keywordflow">return</span> 0;
00363     }
00364     
00365     <span class="comment">// clear the packet received interrupt flag</span>
00366     ax88796Write(ISR, PRX);
00367     
00368     <span class="comment">// if the boundary pointer is invalid,</span>
00369     <span class="comment">// reset the contents of the buffer and exit</span>
00370     <span class="keywordflow">if</span>( (bnryPagePtr &lt; RXSTART_INIT) || (bnryPagePtr &gt;= RXSTOP_INIT) )
00371     {
00372         ax88796Write(BNRY, RXSTART_INIT);
00373         ax88796Write(CR, (PS0|RD2|START));
00374         ax88796Write(CURR, RXSTART_INIT+1);
00375         ax88796Write(CR, (RD2|START));
00376         
00377 <span class="comment">//      rprintf("B");</span>
00378         <span class="keywordflow">return</span> 0;
00379     }
00380 
00381     <span class="comment">// initiate DMA to transfer the RTL8019 packet header</span>
00382     ax88796Write(RBCR0, 4);
00383     ax88796Write(RBCR1, 0);
00384     ax88796Write(RSAR0, 0);
00385     ax88796Write(RSAR1, readPagePtr);
00386     ax88796Write(CR, (RD0|START));
00387     <span class="keywordflow">for</span>(i=0;i&lt;4;i++)
00388         pageheader[i] = ax88796Read(RDMAPORT);
00389 
00390     <span class="comment">// end the DMA operation</span>
00391     ax88796Write(CR, (RD2|START));
00392     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00393         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00394             <span class="keywordflow">break</span>;
00395     ax88796Write(ISR, RDC);
00396     
00397     rxlen = (pageheader[PKTHEADER_PKTLENH]&lt;&lt;8) + pageheader[PKTHEADER_PKTLENL];
00398     NextPage = pageheader[PKTHEADER_NEXTPAGE];
00399     
00400     CurrentRetreiveAddress = (readPagePtr&lt;&lt;8) + 4;
00401     
00402     <span class="comment">// if the NextPage pointer is invalid, the packet is not ready yet - exit</span>
00403     <span class="keywordflow">if</span>( (NextPage &gt;= RXSTOP_INIT) || (NextPage &lt; RXSTART_INIT) )
00404     {
00405 <span class="comment">//      rprintf("N");</span>
00406 <span class="comment">//      rprintfu08(nextPage);</span>
00407         <span class="keywordflow">return</span> 0;
00408     }
00409 
00410     <span class="keywordflow">return</span> rxlen-4;
00411 }
00412 
00413 
00414 <span class="keywordtype">void</span> ax88796RetreivePacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00415 {
00416     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00417     
00418     <span class="comment">// initiate DMA to transfer the data</span>
00419     ax88796Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)length);
00420     ax88796Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(length&gt;&gt;8));
00421     ax88796Write(RSAR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)CurrentRetreiveAddress);
00422     ax88796Write(RSAR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(CurrentRetreiveAddress&gt;&gt;8));
00423     ax88796Write(CR, (RD0|START));
00424     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00425         localBuffer[i] = ax88796Read(RDMAPORT);
00426 
00427     <span class="comment">// end the DMA operation</span>
00428     ax88796Write(CR, (RD2|START));
00429     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00430         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00431             <span class="keywordflow">break</span>;
00432     ax88796Write(ISR, RDC);
00433     
00434     CurrentRetreiveAddress += length;
00435     <span class="keywordflow">if</span>( CurrentRetreiveAddress &gt;= 0x6000 )
00436         CurrentRetreiveAddress -= (0x6000-0x4600) ;
00437 }
00438 
00439 
00440 <span class="keywordtype">void</span> ax88796EndPacketRetreive(<span class="keywordtype">void</span>)
00441 {
00442     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00443     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00444 
00445     <span class="comment">// end the DMA operation</span>
00446     ax88796Write(CR, (RD2|START));
00447     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00448         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00449             <span class="keywordflow">break</span>;
00450     ax88796Write(ISR, RDC);
00451 
00452     <span class="comment">// set the boundary register to point</span>
00453     <span class="comment">// to the start of the next packet-1</span>
00454     bnryPagePtr = NextPage-1;
00455     <span class="keywordflow">if</span>(bnryPagePtr &lt; RXSTART_INIT) bnryPagePtr = RXSTOP_INIT-1;
00456 
00457     ax88796Write(BNRY, bnryPagePtr);
00458 }
00459 
00460 
00461 <span class="keywordtype">void</span> ax88796ProcessInterrupt(<span class="keywordtype">void</span>)
00462 {
00463     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> intr = ax88796Read(ISR);
00464     
00465     <span class="comment">// check for receive overflow</span>
00466     <span class="keywordflow">if</span>( intr &amp; OVW )
00467         ax88796ReceiveOverflowRecover();
00468 }
00469 
00470 
00471 <span class="keywordtype">void</span> ax88796ReceiveOverflowRecover(<span class="keywordtype">void</span>)
00472 {
00473     <span class="comment">// receive buffer overflow handling procedure</span>
00474     <span class="comment">// as specified in the AX88796 datasheet</span>
00475 
00476     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmdReg;
00477     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> resend=0;
00478 
00479     <span class="comment">// check if we were transmitting something</span>
00480     cmdReg = ax88796Read(CR);
00481     <span class="comment">// stop the interface</span>
00482     ax88796Write(CR, (RD2|STOP));
00483     <span class="comment">// wait for timeout</span>
00484     delay_ms(2);
00485     <span class="comment">// clear remote byte count registers</span>
00486     ax88796Write(RBCR0, 0x00);
00487     ax88796Write(RBCR1, 0x00);
00488     
00489     <span class="comment">// if we were transmitting something</span>
00490     <span class="keywordflow">if</span>(cmdReg &amp; TXP)
00491     {
00492         <span class="comment">// check if the transmit completed</span>
00493         cmdReg = ax88796Read(ISR);
00494         <span class="keywordflow">if</span>((cmdReg &amp; PTX) || (cmdReg &amp; TXE))
00495             resend = 0;     <span class="comment">// transmit completed</span>
00496         <span class="keywordflow">else</span>
00497             resend = 1;     <span class="comment">// transmit was interrupted, must resend</span>
00498     }
00499     <span class="comment">// switch to loopback mode</span>
00500     ax88796Write(TCR, LB0);
00501     <span class="comment">// start the interface</span>
00502     ax88796Write(CR, (RD2|START));
00503     <span class="comment">// set boundary</span>
00504     ax88796Write(BNRY, RXSTART_INIT);
00505     <span class="comment">// go to page 1</span>
00506     ax88796Write(CR, (PS0|RD2|START));
00507     <span class="comment">// set current page register</span>
00508     ax88796Write(CPR, RXSTART_INIT+1);
00509     <span class="comment">// go to page 0</span>
00510     ax88796Write(CR, (RD2|START));
00511     <span class="comment">// clear the overflow int</span>
00512     ax88796Write(ISR, OVW);
00513     <span class="comment">// switch to normal (non-loopback mode)</span>
00514     ax88796Write(TCR, TCR_INIT);
00515 
00516     <span class="comment">// if previous transmit was interrupted, then resend</span>
00517     <span class="keywordflow">if</span>(resend)
00518         ax88796Write(CR, (RD2|TXP|START));
00519 
00520     <span class="comment">// recovery completed</span>
00521 }
00522 
00523 
00524 <span class="preprocessor">#define set_mdc     ax88796Write(MEMR,ax88796Read(MEMR)|0x01);</span>
00525 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdc     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFE);</span>
00526 <span class="preprocessor"></span>
00527 <span class="preprocessor">#define mii_clk     set_mdc; clr_mdc;                 </span>
00528 <span class="preprocessor"></span>                    
00529 <span class="preprocessor">#define set_mdir    ax88796Write(MEMR,ax88796Read(MEMR)|0x02);</span>
00530 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdir    ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFD);</span>
00531 <span class="preprocessor"></span>                    
00532 <span class="preprocessor">#define set_mdo     ax88796Write(MEMR,ax88796Read(MEMR)|0x08)</span>
00533 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdo     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xF7)</span>
00534 <span class="preprocessor"></span>
00535 <span class="preprocessor">#define mii_write   clr_mdo; mii_clk;   \</span>
00536 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00537 <span class="preprocessor">                    clr_mdo; mii_clk;   \</span>
00538 <span class="preprocessor">                    set_mdo; mii_clk;</span>
00539 <span class="preprocessor"></span>
00540 <span class="preprocessor">#define mii_read    clr_mdo; mii_clk;   \</span>
00541 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00542 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00543 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00544 <span class="preprocessor"></span>
00545 <span class="preprocessor">#define mii_r_ta    mii_clk; mii_clk;</span>
00546 <span class="preprocessor"></span>
00547 <span class="preprocessor">#define mii_w_ta    set_mdo; mii_clk;   \</span>
00548 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00549 <span class="preprocessor"></span>            
00550 <span class="keywordtype">void</span> ax88796WriteMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mii_data)
00551 {
00552     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8;
00553     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i,mask16;
00554 
00555     clr_mdir;
00556     mii_write;
00557  
00558     mask8 = 0x10;
00559     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00560     {
00561         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00562             set_mdo;
00563         <span class="keywordflow">else</span>
00564             clr_mdo;
00565         mii_clk;
00566         mask8 &gt;&gt;= 1;     
00567     }   
00568     mask8 = 0x10;
00569     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00570     {
00571         <span class="keywordflow">if</span>(mask8 &amp; regad)
00572             set_mdo;
00573         <span class="keywordflow">else</span>
00574             clr_mdo;
00575         mii_clk;
00576         mask8 &gt;&gt;= 1;     
00577     }                       
00578     mii_w_ta;
00579  
00580     mask16 = 0x8000;
00581     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00582     {
00583         <span class="keywordflow">if</span>(mask16 &amp; mii_data)
00584             set_mdo;
00585         <span class="keywordflow">else</span>
00586             clr_mdo;
00587         mii_clk;     
00588         mask16 &gt;&gt;= 1;    
00589     }               
00590 }
00591  
00592 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796ReadMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad)
00593 {
00594     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8,i;
00595     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  mask16,result16;
00596  
00597     clr_mdir;
00598     mii_read;
00599 
00600     mask8 = 0x10;
00601     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00602     {
00603         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00604             set_mdo;
00605         <span class="keywordflow">else</span>
00606             clr_mdo;
00607         mii_clk;     
00608         mask8 &gt;&gt;= 1;
00609     }
00610     mask8 = 0x10;
00611     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00612     {
00613         <span class="keywordflow">if</span>(mask8 &amp; regad)
00614             set_mdo;
00615         <span class="keywordflow">else</span>
00616             clr_mdo;
00617         mii_clk;
00618         mask8 &gt;&gt;= 1;
00619     }
00620             
00621     set_mdir;
00622     mii_r_ta;
00623  
00624     mask16 = 0x8000;
00625     result16 = 0x0000;
00626     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00627     {
00628         <span class="keywordflow">if</span>(ax88796Read(MEMR) &amp; 0x04)
00629         {
00630             result16 |= mask16;
00631         }
00632         <span class="keywordflow">else</span>
00633         {
00634             <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00635             <span class="comment">//break;</span>
00636         }
00637         mii_clk;
00638         mask16 &gt;&gt;= 1;
00639     }
00640     <span class="keywordflow">return</span> result16;
00641 }
00642 
00643 
00644 <span class="keywordtype">void</span> ax88796RegDump(<span class="keywordtype">void</span>)
00645 {
00646     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> result;
00647     result = ax88796Read(TR);
00648     
00649     rprintf(<span class="stringliteral">"Media State: "</span>);
00650     <span class="keywordflow">if</span>(!(result &amp; AUTOD))
00651         rprintf(<span class="stringliteral">"Autonegotiation\r\n"</span>);
00652     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(result &amp; RST_B)
00653         rprintf(<span class="stringliteral">"PHY in Reset   \r\n"</span>);
00654     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_10B))
00655         rprintf(<span class="stringliteral">"10BASE-T       \r\n"</span>);
00656     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_TXB))
00657         rprintf(<span class="stringliteral">"100BASE-T      \r\n"</span>);
00658                 
00659     <span class="comment">//rprintf("TR regsiter      : %x\r\n",result);</span>
00660     <span class="comment">//result = read_mii(0x10,0);</span>
00661     <span class="comment">//rprintf("MII regsiter 0x10: %x\r\n",result);</span>
00662 
00663     rprintfProgStrM(<span class="stringliteral">"Page0: CR  BNRY PSR PST ISR TSR RSR MMR TR  GPI\r\n"</span>);
00664     rprintfProgStrM(<span class="stringliteral">"       "</span>);
00665     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00666     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00667     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(BNRY));
00668     rprintfProgStrM(<span class="stringliteral">"   "</span>);
00669     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTART));
00670     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00671     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTOP));
00672     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00673     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(ISR));
00674     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00675     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TSR));
00676     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00677     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(RSR));
00678     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00679     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(MEMR));
00680     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00681     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TR));
00682     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00683     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(GPI));
00684     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00685 
00686     ax88796Write(CR,ax88796Read(CR)|PS0);
00687 
00688     rprintf(<span class="stringliteral">"Page1: CR  PAR    CPR\r\n"</span>);
00689     rprintfProgStrM(<span class="stringliteral">"       "</span>);
00690     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00691     rprintfProgStrM(<span class="stringliteral">"  "</span>);
00692     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR0));
00693     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR1));
00694     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR2));
00695     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR3));
00696     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR4));
00697     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR5));
00698     rprintfProgStrM(<span class="stringliteral">" "</span>);
00699     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CPR));
00700     
00701     ax88796Write(CR,ax88796Read(CR)&amp;~PS0);
00702 
00703     delay_ms(25);
00704 }
00705 
00706 <span class="keywordtype">void</span> ax88796PhyDump(<span class="keywordtype">void</span>)
00707 {
00708     rprintfProgStrM(<span class="stringliteral">"----- AX88796 PHY INFO -----\r\n"</span>);
00709     rprintfProgStrM(<span class="stringliteral">"MR 0 (Control)      = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 0) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00710     rprintfProgStrM(<span class="stringliteral">"MR 1 (Status)       = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 1) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00711     rprintfProgStrM(<span class="stringliteral">"MR 2 (PHY ID1)      = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 2) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00712     rprintfProgStrM(<span class="stringliteral">"MR 3 (PHY ID2)      = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 3) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00713     rprintfProgStrM(<span class="stringliteral">"MR 4 (AutoNeg Adv)  = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 4) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00714     rprintfProgStrM(<span class="stringliteral">"MR 5 (AutoNeg Abil) = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 5) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00715     rprintfProgStrM(<span class="stringliteral">"MR 6 (AutoNeg Exp)  = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 6) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00716     rprintfProgStrM(<span class="stringliteral">"MR 7 (NextPg Tx)    = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10, 7) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00717     rprintfProgStrM(<span class="stringliteral">"MR16 (PCS Ctrl)     = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,16) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00718     rprintfProgStrM(<span class="stringliteral">"MR17 (AutoNeg RegA) = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,17) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00719     rprintfProgStrM(<span class="stringliteral">"MR18 (AutoNeg RegB) = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,18) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00720     rprintfProgStrM(<span class="stringliteral">"MR19 (Analog Test)  = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,19) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00721     rprintfProgStrM(<span class="stringliteral">"MR21 (RXERR count)  = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,21) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00722     rprintfProgStrM(<span class="stringliteral">"MR28 (Status Reg)   = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,28) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00723     rprintfProgStrM(<span class="stringliteral">"MR29 (100Mbs Ctrl)  = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,29) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00724     rprintfProgStrM(<span class="stringliteral">"MR30 (10Mbs Ctrl)   = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,30) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00725     rprintfProgStrM(<span class="stringliteral">"MR31 (Quick Status) = 0x"</span>); <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>( ax88796ReadMii(0x10,31) ); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00726 }
00727 
00728 
00729 <span class="comment">/*</span>
00730 <span class="comment">unsigned char ax88796ReceiveEmpty(void)</span>
00731 <span class="comment">{</span>
00732 <span class="comment">    unsigned char temp;</span>
00733 <span class="comment"></span>
00734 <span class="comment">    // read CPR from page 1</span>
00735 <span class="comment">    ax88796Write(CR,0x62);</span>
00736 <span class="comment">    temp = ax88796Read(CPR);</span>
00737 <span class="comment">    </span>
00738 <span class="comment">    // return to page 0</span>
00739 <span class="comment">    ax88796Write(CR,0x22);</span>
00740 <span class="comment">    </span>
00741 <span class="comment">    return ( ax88796Read(BNRY) == temp );</span>
00742 <span class="comment">    </span>
00743 <span class="comment">}*/</span>
00744 
00745 
00746 
00747 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 6 23:36:59 2006 for Procyon ARMlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
