###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:36 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\development\gediminas\CAN4USB\project\app\cd_class.c  #
#    Command line =  D:\development\gediminas\CAN4USB\project\app\cd_class.c  #
#                    -lC D:\development\gediminas\CAN4USB\project\RELEASE\Lis #
#                    t\ -lA D:\development\gediminas\CAN4USB\project\RELEASE\ #
#                    List\ -o D:\development\gediminas\CAN4USB\project\RELEAS #
#                    E\Obj\ --no_cse --no_unroll --no_inline                  #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian little --cpu            #
#                    ARM7TDMI-S -e --fpu None --dlib_config "D:\Program\IAR   #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I D:\development\gediminas\CAN4USB\project\ -I     #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\cd #
#                    _class.lst                                               #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\cd_ #
#                    class.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\development\gediminas\CAN4USB\project\app\cd_class.c
      1          /*************************************************************************
      2           *
      3           *    Used with ICCARM and AARM.
      4           *
      5           *    (c) Copyright IAR Systems 2006
      6           *
      7           *    File name   : cd_class.c
      8           *    Description : Communication device class module
      9           *
     10           *    History :
     11           *    1. Date        : June 28, 2006
     12           *       Author      : Stanimir Bonev
     13           *       Description : Create
     14           *
     15           *    $Revision: 16170 $
     16          **************************************************************************/
     17          #define CD_CLASS_GLOBAL
     18          #include "cd_class.h"

   \                                 In section .text, align 4
   \   __??Code32?? __code __interwork Int32U AtomicExchange(Int32U, pInt32U)
   \                     AtomicExchange:
   \   00000000   900001E1           swp  r0, r0, [r1] 
   \   00000004   1EFF2FE1           BX       LR               ;; return
     19          
     20          #pragma data_alignment=4

   \                                 In section .bss, align 4
     21          CDC_LineCoding_t CDC_LineCoding;
   \                     CDC_LineCoding:
   \   00000000                      DS8 8
     22          
     23          #if CDC_DEVICE_SUPPORT_LINE_CODING > 0

   \                                 In section .bss, align 4
     24          volatile Int32U LineCodingDelta;
   \                     LineCodingDelta:
   \   00000000                      DS8 4
     25          #endif // CDC_DEVICE_SUPPORT_LINE_CODING > 0
     26          
     27          #pragma data_alignment=4

   \                                 In section .bss, align 4
     28          CDC_LineState_t  CDC_LineState;
   \                     CDC_LineState:
   \   00000000                      DS8 4
     29          
     30          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0

   \                                 In section .bss, align 4
     31          volatile Int32U SerialStateDelta;
   \                     SerialStateDelta:
   \   00000000                      DS8 4
     32          

   \                                 In section .bss, align 4
     33          volatile Int32U LineStateDelta;
   \                     LineStateDelta:
   \   00000000                      DS8 4
     34          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
     35          
     36          #if CDC_DEVICE_SUPPORT_BREAK > 0

   \                                 In section .bss, align 4
     37          volatile Int32U BreakCntr;
   \                     BreakCntr:
   \   00000000                      DS8 4
     38          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
     39          
     40          #pragma data_alignment=4

   \                                 In section .bss, align 4
     41          UsbSetupPacket_t CdcReqPacket;
   \                     CdcReqPacket:
   \   00000000                      DS8 8
     42          

   \                                 In section .bss, align 4
     43          Int32U CDC_ReceiveIndx, CDC_ReceiveIndxHold;
   \                     CDC_ReceiveIndx:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     CDC_ReceiveIndxHold:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     44          Int32U CDC_TransmitSize;
   \                     CDC_TransmitSize:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     45          volatile Boolean USB_CDC_OutEpBufferNotEmpty;
   \                     USB_CDC_OutEpBufferNotEmpty:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     46          pInt8U volatile pCDC_TransmitUserBuffer;
   \                     pCDC_TransmitUserBuffer:
   \   00000000                      DS8 4
     47          
     48          #pragma data_alignment=4

   \                                 In section .bss, align 4
     49          Int8U CDC_ReceiveBuffer[CommOutEpMaxSize];
   \                     CDC_ReceiveBuffer:
   \   00000000                      DS8 64
     50          #pragma data_alignment=4

   \                                 In section .bss, align 4
     51          Int8U CDC_TransmitBuffer[CommInEpMaxSize];
   \                     CDC_TransmitBuffer:
   \   00000000                      DS8 64
     52          

   \                                 In section .bss, align 1
     53          volatile Boolean CDC_Configure;
   \                     CDC_Configure:
   \   00000000                      DS8 1
     54          
     55          /*************************************************************************
     56           * Function Name: Tim1Handler
     57           * Parameters: void
     58           *
     59           * Return: none
     60           *
     61           * Description: Timer 1 interrupt handler
     62           *
     63           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     64          void Tim1Handler(void)
     65          {
   \                     Tim1Handler:
   \   00000000   01B5               PUSH     {R0,LR}
     66          #if CDC_DEVICE_SUPPORT_BREAK > 0
     67            if(BreakCntr)
   \   00000002   ....               LDR      R0,??DataTable26  ;; BreakCntr
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   05D0               BEQ      ??Tim1Handler_0
     68            {
     69              --BreakCntr;
   \   0000000A   ....               LDR      R0,??DataTable26  ;; BreakCntr
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   ....               LDR      R1,??DataTable26  ;; BreakCntr
   \   00000012   0860               STR      R0,[R1, #+0]
   \   00000014   06E0               B        ??Tim1Handler_1
     70            }
     71            else
     72            {
     73              CDC_BreakCallBack(NULL);
   \                     ??Tim1Handler_0:
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   ........           BL       CDC_BreakCallBack
     74              // Disable TIM1 counter
     75              TIM_Cmd(TIM1, DISABLE);
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   ....               LDR      R0,??DataTable15  ;; 0xffff9000
   \   00000020   ........           BL       TIM_Cmd
     76            }
     77          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
     78            // Clear the Update pending Bit
     79            TIM_ClearITPendingBit(TIM1, TIM_IT_Update);
   \                     ??Tim1Handler_1:
   \   00000024   0121               MOVS     R1,#+1
   \   00000026   ....               LDR      R0,??DataTable15  ;; 0xffff9000
   \   00000028   ........           BL       TIM_ClearITPendingBit
     80          }
   \   0000002C   08BC               POP      {R3}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
     81          
     82          /*************************************************************************
     83           * Function Name: UsbCdcInit
     84           * Parameters: Int32U IntrPriority
     85           *
     86           * Return: none
     87           *
     88           * Description: USB communication device class init
     89           *
     90           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     91          void UsbCdcInit (Int32U IntrPriority)
     92          {
   \                     UsbCdcInit:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   90B0               SUB      SP,SP,#+64
   \   00000004   0400               MOVS     R4,R0
     93          #if CDC_DEVICE_SUPPORT_BREAK > 0
     94          TIM_InitTypeDef TIM_InitStructure;
     95          EIC_IRQInitTypeDef EIC_IRQInitStructure;
     96          MRCC_ClocksTypeDef MRCC_Clocks;
     97          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
     98          
     99            // Init CD Class variables
    100            CDC_Configure               = FALSE;
   \   00000006   ....               LDR      R0,??DataTable27  ;; CDC_Configure
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0170               STRB     R1,[R0, #+0]
    101          
    102            CDC_LineCoding.dwDTERate    = CDC_DATA_RATE;
   \   0000000C   ....               LDR      R0,??DataTable6  ;; CDC_LineCoding
   \   0000000E   E121               MOVS     R1,#+225
   \   00000010   4902               LSLS     R1,R1,#+9        ;; #+115200
   \   00000012   0160               STR      R1,[R0, #+0]
    103            CDC_LineCoding.bDataBits    = CDC_DATA_BITS;
   \   00000014   3548               LDR      R0,??UsbCdcInit_0  ;; CDC_LineCoding + 6
   \   00000016   0821               MOVS     R1,#+8
   \   00000018   0170               STRB     R1,[R0, #+0]
    104            CDC_LineCoding.bParityType  = CDC_PARITY;
   \   0000001A   3548               LDR      R0,??UsbCdcInit_0+0x4  ;; CDC_LineCoding + 5
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   0170               STRB     R1,[R0, #+0]
    105            CDC_LineCoding.bCharFormat  = CDC_STOP_BITS;
   \   00000020   3448               LDR      R0,??UsbCdcInit_0+0x8  ;; CDC_LineCoding + 4
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   0170               STRB     R1,[R0, #+0]
    106          
    107          #if CDC_DEVICE_SUPPORT_LINE_CODING > 0
    108            // Update the line coding
    109            LineCodingDelta             = TRUE;
   \   00000026   ....               LDR      R0,??DataTable7  ;; LineCodingDelta
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0160               STR      R1,[R0, #+0]
    110          #endif // CDC_DEVICE_SUPPORT_LINE_CODING > 0
    111          
    112            CDC_LineState.DTR_State     = CDC_LINE_DTR;
   \   0000002C   ....               LDR      R0,??DataTable11  ;; CDC_LineState
   \   0000002E   0078               LDRB     R0,[R0, #+0]
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   0143               ORRS     R1,R1,R0
   \   00000034   ....               LDR      R0,??DataTable11  ;; CDC_LineState
   \   00000036   0170               STRB     R1,[R0, #+0]
    113            CDC_LineState.RTS_State     = CDC_LINE_RTS;
   \   00000038   ....               LDR      R0,??DataTable11  ;; CDC_LineState
   \   0000003A   0078               LDRB     R0,[R0, #+0]
   \   0000003C   0221               MOVS     R1,#+2
   \   0000003E   0143               ORRS     R1,R1,R0
   \   00000040   ....               LDR      R0,??DataTable11  ;; CDC_LineState
   \   00000042   0170               STRB     R1,[R0, #+0]
    114          
    115          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    116            // Update the line state
    117            LineStateDelta              = TRUE;
   \   00000044   ....               LDR      R0,??DataTable12  ;; LineStateDelta
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   0160               STR      R1,[R0, #+0]
    118            SerialStateDelta            = FALSE;
   \   0000004A   ....               LDR      R0,??DataTable28  ;; SerialStateDelta
   \   0000004C   0021               MOVS     R1,#+0
   \   0000004E   0160               STR      R1,[R0, #+0]
    119          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    120          
    121          #if CDC_DEVICE_SUPPORT_BREAK > 0
    122          
    123            BreakCntr = 0;
   \   00000050   ....               LDR      R0,??DataTable26  ;; BreakCntr
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   0160               STR      R1,[R0, #+0]
    124            // Init Break timer resolution 1 ms
    125            // Enable TIM1 clocks
    126            MRCC_PeripheralClockConfig(MRCC_Peripheral_TIM1, ENABLE);
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   0820               MOVS     R0,#+8
   \   0000005A   ........           BL       MRCC_PeripheralClockConfig
    127            // Release TIM1 reset
    128            MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM1,DISABLE);
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   0820               MOVS     R0,#+8
   \   00000062   ........           BL       MRCC_PeripheralSWResetConfig
    129            // Calculate counter value
    130            MRCC_GetClocksStatus(&MRCC_Clocks);
   \   00000066   01A8               ADD      R0,SP,#+4
   \   00000068   ........           BL       MRCC_GetClocksStatus
    131          
    132            TIM_InitStructure.TIM_Period = (MRCC_Clocks.CKTIM_Frequency / 1000);
   \   0000006C   0598               LDR      R0,[SP, #+20]
   \   0000006E   FA21               MOVS     R1,#+250
   \   00000070   8900               LSLS     R1,R1,#+2        ;; #+1000
   \   00000072   ........           BL       __aeabi_uidivmod
   \   00000076   07A9               ADD      R1,SP,#+28
   \   00000078   4881               STRH     R0,[R1, #+10]
    133            TIM_InitStructure.TIM_Prescaler = 0;
   \   0000007A   07A8               ADD      R0,SP,#+28
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   4180               STRH     R1,[R0, #+2]
    134            TIM_InitStructure.TIM_Mode = TIM_Mode_OCTiming;
   \   00000080   6846               MOV      R0,SP
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   8183               STRH     R1,[R0, #+28]
    135            TIM_InitStructure.TIM_ClockSource = TIM_ClockSource_Internal;
   \   00000086   07A8               ADD      R0,SP,#+28
   \   00000088   0121               MOVS     R1,#+1
   \   0000008A   8180               STRH     R1,[R0, #+4]
    136            TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000008C   07A8               ADD      R0,SP,#+28
   \   0000008E   0021               MOVS     R1,#+0
   \   00000090   0181               STRH     R1,[R0, #+8]
    137            TIM_InitStructure.TIM_Channel = TIM_Channel_2;
   \   00000092   07A8               ADD      R0,SP,#+28
   \   00000094   0221               MOVS     R1,#+2
   \   00000096   8181               STRH     R1,[R0, #+12]
    138            TIM_Init(TIM1, &TIM_InitStructure);
   \   00000098   07A9               ADD      R1,SP,#+28
   \   0000009A   ....               LDR      R0,??DataTable15  ;; 0xffff9000
   \   0000009C   ........           BL       TIM_Init
    139          
    140            // Enable and configure the priority of the TIM1 Update IRQ Channel
    141            EIC_IRQInitStructure.EIC_IRQChannel = TIM1_UP_IRQChannel;
   \   000000A0   6846               MOV      R0,SP
   \   000000A2   0821               MOVS     R1,#+8
   \   000000A4   0170               STRB     R1,[R0, #+0]
    142            EIC_IRQInitStructure.EIC_IRQChannelPriority = IntrPriority;
   \   000000A6   6846               MOV      R0,SP
   \   000000A8   2100               MOVS     R1,R4
   \   000000AA   4170               STRB     R1,[R0, #+1]
    143            EIC_IRQInitStructure.EIC_IRQChannelCmd = ENABLE;
   \   000000AC   6846               MOV      R0,SP
   \   000000AE   0121               MOVS     R1,#+1
   \   000000B0   8170               STRB     R1,[R0, #+2]
    144            EIC_IRQInit(&EIC_IRQInitStructure);
   \   000000B2   6846               MOV      R0,SP
   \   000000B4   ........           BL       EIC_IRQInit
    145          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
    146          
    147            CDC_ReceiveIndx      = \
    148            CDC_ReceiveIndxHold  = \
    149            CDC_TransmitSize     = 0;
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   ....               LDR      R1,??DataTable41  ;; CDC_TransmitSize
   \   000000BC   0860               STR      R0,[R1, #+0]
   \   000000BE   ....               LDR      R1,??DataTable23  ;; CDC_ReceiveIndxHold
   \   000000C0   0860               STR      R0,[R1, #+0]
   \   000000C2   ....               LDR      R1,??DataTable31  ;; CDC_ReceiveIndx
   \   000000C4   0860               STR      R0,[R1, #+0]
    150          
    151            USB_CDC_OutEpBufferNotEmpty = FALSE;
   \   000000C6   ....               LDR      R0,??DataTable33  ;; USB_CDC_OutEpBufferNotEmpty
   \   000000C8   0021               MOVS     R1,#+0
   \   000000CA   0170               STRB     R1,[R0, #+0]
    152          
    153            pCDC_TransmitUserBuffer = NULL;
   \   000000CC   ....               LDR      R0,??DataTable43  ;; pCDC_TransmitUserBuffer
   \   000000CE   0021               MOVS     R1,#+0
   \   000000D0   0160               STR      R1,[R0, #+0]
    154          
    155            // Registered the class request
    156            USB_UserFuncRegistering(UsbCdcRequest,UsbUserClass);
   \   000000D2   2321               MOVS     R1,#+35
   \   000000D4   0848               LDR      R0,??UsbCdcInit_0+0xC  ;; UsbCdcRequest
   \   000000D6   ........           BL       USB_UserFuncRegistering
    157            // Registered the function for a data receive of the class request
    158            USB_UserFuncRegistering(UsbCdcData,UsbClassEp0OutPacket);
   \   000000DA   2021               MOVS     R1,#+32
   \   000000DC   0748               LDR      R0,??UsbCdcInit_0+0x10  ;; UsbCdcData
   \   000000DE   ........           BL       USB_UserFuncRegistering
    159          }
   \   000000E2   10B0               ADD      SP,SP,#+64
   \   000000E4   10BC               POP      {R4}
   \   000000E6   01BC               POP      {R0}
   \   000000E8   0047               BX       R0               ;; return
   \   000000EA   C046               Nop      
   \                     ??UsbCdcInit_0:
   \   000000EC   ........           DC32     CDC_LineCoding + 6
   \   000000F0   ........           DC32     CDC_LineCoding + 5
   \   000000F4   ........           DC32     CDC_LineCoding + 4
   \   000000F8   ........           DC32     UsbCdcRequest
   \   000000FC   ........           DC32     UsbCdcData
    160          
    161          /*************************************************************************
    162           * Function Name: UsbCdcConfigure
    163           * Parameters:  void * pArg
    164           *
    165           * Return: void *
    166           *
    167           * Description: USB communication device class configure
    168           *
    169           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    170          void * UsbCdcConfigure (void * pArg)
    171          {
   \                     UsbCdcConfigure:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    172          UsbDevCtrl_t * pUsbDevCtrl = (UsbDevCtrl_t *)pArg;
   \   00000004   2500               MOVS     R5,R4
    173            if(pUsbDevCtrl == NULL)
   \   00000006   002D               CMP      R5,#+0
   \   00000008   26D1               BNE      ??UsbCdcConfigure_0
    174            {
    175              CDC_Configure = FALSE;
   \   0000000A   ....               LDR      R0,??DataTable27  ;; CDC_Configure
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0170               STRB     R1,[R0, #+0]
    176              if(UsbCoreReq(UsbCoreReqConfiquration) != 0)
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   ........           BL       UsbCoreReq
   \   00000016   0028               CMP      R0,#+0
   \   00000018   4CD0               BEQ      ??UsbCdcConfigure_1
    177              {
    178                // disable all class EPs
    179                USB_RealizeEp((USB_Endpoint_t)CommOutEp,0,EP_BULK_SING_BUFF,EP_SLOT2);
   \   0000001A   0223               MOVS     R3,#+2
   \   0000001C   0022               MOVS     R2,#+0
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   0420               MOVS     R0,#+4
   \   00000022   ........           BL       USB_RealizeEp
    180                USB_UserFuncRegistering(NULL,CommOutEp);
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   0020               MOVS     R0,#+0
   \   0000002A   ........           BL       USB_UserFuncRegistering
    181                USB_RealizeEp((USB_Endpoint_t)CommInEp,0,EP_BULK_SING_BUFF,EP_SLOT2);
   \   0000002E   0223               MOVS     R3,#+2
   \   00000030   0022               MOVS     R2,#+0
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   0520               MOVS     R0,#+5
   \   00000036   ........           BL       USB_RealizeEp
    182                USB_UserFuncRegistering(NULL,CommInEp);
   \   0000003A   0521               MOVS     R1,#+5
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ........           BL       USB_UserFuncRegistering
    183                USB_RealizeEp((USB_Endpoint_t)ReportEp,0,EP_INTERRUPT,EP_SLOT1);
   \   00000042   0123               MOVS     R3,#+1
   \   00000044   0322               MOVS     R2,#+3
   \   00000046   0021               MOVS     R1,#+0
   \   00000048   0320               MOVS     R0,#+3
   \   0000004A   ........           BL       USB_RealizeEp
    184                USB_UserFuncRegistering(NULL,ReportEp);
   \   0000004E   0321               MOVS     R1,#+3
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   ........           BL       USB_UserFuncRegistering
   \   00000056   2DE0               B        ??UsbCdcConfigure_1
    185              }
    186            }
    187            else
    188            {
    189              // Init variables
    190              CDC_ReceiveIndx      = \
    191              CDC_ReceiveIndxHold  = \
    192              CDC_TransmitSize     = 0;
   \                     ??UsbCdcConfigure_0:
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   ....               LDR      R1,??DataTable41  ;; CDC_TransmitSize
   \   0000005C   0860               STR      R0,[R1, #+0]
   \   0000005E   ....               LDR      R1,??DataTable23  ;; CDC_ReceiveIndxHold
   \   00000060   0860               STR      R0,[R1, #+0]
   \   00000062   ....               LDR      R1,??DataTable31  ;; CDC_ReceiveIndx
   \   00000064   0860               STR      R0,[R1, #+0]
    193          
    194              USB_CDC_OutEpBufferNotEmpty = FALSE;
   \   00000066   ....               LDR      R0,??DataTable33  ;; USB_CDC_OutEpBufferNotEmpty
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   0170               STRB     R1,[R0, #+0]
    195          
    196          #if CDC_DEVICE_SUPPORT_BREAK > 0
    197              BreakCntr = 0;
   \   0000006C   ....               LDR      R0,??DataTable26  ;; BreakCntr
   \   0000006E   0021               MOVS     R1,#+0
   \   00000070   0160               STR      R1,[R0, #+0]
    198          #endif  // CDC_DEVICE_SUPPORT_BREAK > 0
    199          
    200              // enable all class EPs
    201              USB_UserFuncRegistering((UserFunc_t)UsbCdcInHadler,CommOutEp);
   \   00000072   0421               MOVS     R1,#+4
   \   00000074   1148               LDR      R0,??UsbCdcConfigure_2  ;; UsbCdcInHadler
   \   00000076   ........           BL       USB_UserFuncRegistering
    202              USB_RealizeEp((USB_Endpoint_t)CommOutEp,CommOutEpMaxSize,EP_BULK_SING_BUFF,EP_SLOT2);
   \   0000007A   0223               MOVS     R3,#+2
   \   0000007C   0022               MOVS     R2,#+0
   \   0000007E   4021               MOVS     R1,#+64
   \   00000080   0420               MOVS     R0,#+4
   \   00000082   ........           BL       USB_RealizeEp
    203              USB_UserFuncRegistering((UserFunc_t)UsbCdcOutHadler,CommInEp);
   \   00000086   0521               MOVS     R1,#+5
   \   00000088   0D48               LDR      R0,??UsbCdcConfigure_2+0x4  ;; UsbCdcOutHadler
   \   0000008A   ........           BL       USB_UserFuncRegistering
    204              USB_RealizeEp((USB_Endpoint_t)CommInEp,CommInEpMaxSize,EP_BULK_SING_BUFF,EP_SLOT2);
   \   0000008E   0223               MOVS     R3,#+2
   \   00000090   0022               MOVS     R2,#+0
   \   00000092   4021               MOVS     R1,#+64
   \   00000094   0520               MOVS     R0,#+5
   \   00000096   ........           BL       USB_RealizeEp
    205          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    206              USB_UserFuncRegistering((UserFunc_t)UsbCdcReportHadler,ReportEp);
   \   0000009A   0321               MOVS     R1,#+3
   \   0000009C   0948               LDR      R0,??UsbCdcConfigure_2+0x8  ;; UsbCdcReportHadler
   \   0000009E   ........           BL       USB_UserFuncRegistering
    207              USB_RealizeEp((USB_Endpoint_t)ReportEp,ReportEpMaxSize,EP_INTERRUPT,EP_SLOT1);
   \   000000A2   0123               MOVS     R3,#+1
   \   000000A4   0322               MOVS     R2,#+3
   \   000000A6   1021               MOVS     R1,#+16
   \   000000A8   0320               MOVS     R0,#+3
   \   000000AA   ........           BL       USB_RealizeEp
    208          #else
    209              USB_UserFuncRegistering(NULL,ReportEp);
    210              USB_RealizeEp((USB_Endpoint_t)ReportEp,ReportEpMaxSize,EP_INTERRUPT,EP_SLOT1);
    211          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    212          
    213              CDC_Configure = TRUE;
   \   000000AE   ....               LDR      R0,??DataTable27  ;; CDC_Configure
   \   000000B0   0121               MOVS     R1,#+1
   \   000000B2   0170               STRB     R1,[R0, #+0]
    214            }
    215            return(NULL);
   \                     ??UsbCdcConfigure_1:
   \   000000B4   0020               MOVS     R0,#+0
   \   000000B6   38BC               POP      {R3-R5}
   \   000000B8   02BC               POP      {R1}
   \   000000BA   0847               BX       R1               ;; return
   \                     ??UsbCdcConfigure_2:
   \   000000BC   ........           DC32     UsbCdcInHadler
   \   000000C0   ........           DC32     UsbCdcOutHadler
   \   000000C4   ........           DC32     UsbCdcReportHadler
    216          }
    217          
    218          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    219          /*************************************************************************
    220           * Function Name: UsbCdcReportHadler
    221           * Parameters:  void * pArg
    222           *
    223           * Return: none
    224           *
    225           * Description: USB Communication Device Class Report (In) EP handler
    226           *
    227           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    228          void UsbCdcReportHadler (void *Arg)
    229          {
    230            SerialStateDelta = FALSE;
   \                     UsbCdcReportHadler:
   \   00000000   ....               LDR      R1,??DataTable28  ;; SerialStateDelta
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0A60               STR      R2,[R1, #+0]
    231          }
   \   00000006   7047               BX       LR               ;; return
    232          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    233          
    234          /*************************************************************************
    235           * Function Name: UsbCdcInHadler
    236           * Parameters:  void * pArg
    237           *
    238           * Return: none
    239           *
    240           * Description: USB Communication Device Class Out EP handler
    241           *
    242           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    243          void UsbCdcInHadler (void *Arg)
    244          {
   \                     UsbCdcInHadler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    245              if(CDC_ReceiveIndx == 0)
   \   00000004   ....               LDR      R0,??DataTable31  ;; CDC_ReceiveIndx
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0CD1               BNE      ??UsbCdcInHadler_0
    246              {
    247                CDC_ReceiveIndx = CommOutEpMaxSize;
   \   0000000C   ....               LDR      R0,??DataTable31  ;; CDC_ReceiveIndx
   \   0000000E   4021               MOVS     R1,#+64
   \   00000010   0160               STR      R1,[R0, #+0]
    248                USB_EpRead((USB_Endpoint_t)CommOutEp,
    249                           (pInt8U)CDC_ReceiveBuffer,
    250                           &CDC_ReceiveIndx);
   \   00000012   ....               LDR      R2,??DataTable31  ;; CDC_ReceiveIndx
   \   00000014   ....               LDR      R1,??DataTable32  ;; CDC_ReceiveBuffer
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   ........           BL       USB_EpRead
    251                USB_EpValidate((USB_Endpoint_t)CommOutEp,
    252                               TRUE);
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   0420               MOVS     R0,#+4
   \   00000020   ........           BL       USB_EpValidate
   \   00000024   02E0               B        ??UsbCdcInHadler_1
    253              }
    254              else
    255              {
    256                USB_CDC_OutEpBufferNotEmpty = TRUE;
   \                     ??UsbCdcInHadler_0:
   \   00000026   ....               LDR      R0,??DataTable33  ;; USB_CDC_OutEpBufferNotEmpty
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0170               STRB     R1,[R0, #+0]
    257              }
    258          }
   \                     ??UsbCdcInHadler_1:
   \   0000002C   10BC               POP      {R4}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
    259          
    260          /*************************************************************************
    261           * Function Name: UsbCdcOutHadler
    262           * Parameters:  void * pArg
    263           *
    264           * Return: none
    265           *
    266           * Description: USB Communication Device Class In EP handler
    267           *
    268           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    269          void UsbCdcOutHadler (void *Arg)
    270          {
   \                     UsbCdcOutHadler:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    271          Int32U Counter, CurrWriteSize;
    272            if(CDC_TransmitSize != 0)
   \   00000004   ....               LDR      R0,??DataTable41  ;; CDC_TransmitSize
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   25D0               BEQ      ??UsbCdcOutHadler_0
    273            {
    274              CurrWriteSize = MIN(CDC_TransmitSize,CommInEpMaxSize);
   \   0000000C   ....               LDR      R0,??DataTable41  ;; CDC_TransmitSize
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   4028               CMP      R0,#+64
   \   00000012   03D2               BCS      ??UsbCdcOutHadler_1
   \   00000014   ....               LDR      R0,??DataTable41  ;; CDC_TransmitSize
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   0090               STR      R0,[SP, #+0]
   \   0000001A   01E0               B        ??UsbCdcOutHadler_2
   \                     ??UsbCdcOutHadler_1:
   \   0000001C   4020               MOVS     R0,#+64
   \   0000001E   0090               STR      R0,[SP, #+0]
    275              for(Counter = 0; Counter < CurrWriteSize; ++Counter)
   \                     ??UsbCdcOutHadler_2:
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   0500               MOVS     R5,R0
   \                     ??UsbCdcOutHadler_3:
   \   00000024   0098               LDR      R0,[SP, #+0]
   \   00000026   8542               CMP      R5,R0
   \   00000028   0AD2               BCS      ??UsbCdcOutHadler_4
    276              {
    277                CDC_TransmitBuffer[Counter] = *pCDC_TransmitUserBuffer++;
   \   0000002A   ....               LDR      R0,??DataTable43  ;; pCDC_TransmitUserBuffer
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   0100               MOVS     R1,R0
   \   00000030   491C               ADDS     R1,R1,#+1
   \   00000032   ....               LDR      R2,??DataTable43  ;; pCDC_TransmitUserBuffer
   \   00000034   1160               STR      R1,[R2, #+0]
   \   00000036   ....               LDR      R1,??DataTable42  ;; CDC_TransmitBuffer
   \   00000038   0078               LDRB     R0,[R0, #+0]
   \   0000003A   4855               STRB     R0,[R1, R5]
    278              }
   \   0000003C   6D1C               ADDS     R5,R5,#+1
   \   0000003E   F1E7               B        ??UsbCdcOutHadler_3
    279              CDC_TransmitSize -= CurrWriteSize;
   \                     ??UsbCdcOutHadler_4:
   \   00000040   ....               LDR      R0,??DataTable41  ;; CDC_TransmitSize
   \   00000042   0068               LDR      R0,[R0, #+0]
   \   00000044   0099               LDR      R1,[SP, #+0]
   \   00000046   401A               SUBS     R0,R0,R1
   \   00000048   ....               LDR      R1,??DataTable41  ;; CDC_TransmitSize
   \   0000004A   0860               STR      R0,[R1, #+0]
    280              USB_EpWrite((USB_Endpoint_t)CommInEp,CDC_TransmitBuffer,&CurrWriteSize);
   \   0000004C   6A46               MOV      R2,SP
   \   0000004E   ....               LDR      R1,??DataTable42  ;; CDC_TransmitBuffer
   \   00000050   0520               MOVS     R0,#+5
   \   00000052   ........           BL       USB_EpWrite
   \   00000056   02E0               B        ??UsbCdcOutHadler_5
    281            }
    282            else
    283            {
    284              pCDC_TransmitUserBuffer = NULL;
   \                     ??UsbCdcOutHadler_0:
   \   00000058   ....               LDR      R0,??DataTable43  ;; pCDC_TransmitUserBuffer
   \   0000005A   0021               MOVS     R1,#+0
   \   0000005C   0160               STR      R1,[R0, #+0]
    285            }
    286          }
   \                     ??UsbCdcOutHadler_5:
   \   0000005E   38BC               POP      {R3-R5}
   \   00000060   01BC               POP      {R0}
   \   00000062   0047               BX       R0               ;; return
    287          
    288          /*************************************************************************
    289           * Function Name: UsbCdcRequest
    290           * Parameters:  void * pArg
    291           *
    292           * Return: void *
    293           *
    294           * Description: The class requests processing
    295           *
    296           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    297          void * UsbCdcRequest (void * pArg)
    298          {
   \                     UsbCdcRequest:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    299          UsbEpCtrl_t * pCdcReqCtrl = (UsbEpCtrl_t *) pArg;
   \   00000004   2500               MOVS     R5,R4
    300            CdcReqPacket = *(UsbSetupPacket_t *)pCdcReqCtrl->pData;
   \   00000006   5148               LDR      R0,??UsbCdcRequest_0  ;; CdcReqPacket
   \   00000008   2968               LDR      R1,[R5, #+0]
   \   0000000A   0822               MOVS     R2,#+8
   \   0000000C   ........           BL       __aeabi_memcpy
    301            // Validate Request
    302            if (CdcReqPacket.mRequestType.Recipient == UsbRecipientInterface)
   \   00000010   4E48               LDR      R0,??UsbCdcRequest_0  ;; CdcReqPacket
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000016   C00E               LSRS     R0,R0,#+27
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   00D0               BEQ      .+4
   \   0000001C   8EE0               B        ??UsbCdcRequest_1
    303            {
    304              switch (CdcReqPacket.bRequest)
   \   0000001E   4C48               LDR      R0,??UsbCdcRequest_0+0x4  ;; CdcReqPacket + 1
   \   00000020   0078               LDRB     R0,[R0, #+0]
   \   00000022   2038               SUBS     R0,R0,#+32
   \   00000024   06D0               BEQ      ??UsbCdcRequest_2
   \   00000026   401E               SUBS     R0,R0,#+1
   \   00000028   24D0               BEQ      ??UsbCdcRequest_3
   \   0000002A   401E               SUBS     R0,R0,#+1
   \   0000002C   30D0               BEQ      ??UsbCdcRequest_4
   \   0000002E   401E               SUBS     R0,R0,#+1
   \   00000030   5CD0               BEQ      ??UsbCdcRequest_5
   \   00000032   83E0               B        ??UsbCdcRequest_1
    305              {
    306              case SET_LINE_CODING:
    307                if ((CdcReqPacket.wValue.Word == 0) &&
    308                    (CdcReqPacket.wIndex.Word == 0))
   \                     ??UsbCdcRequest_2:
   \   00000034   4748               LDR      R0,??UsbCdcRequest_0+0x8  ;; CdcReqPacket + 2
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0028               CMP      R0,#+0
   \   0000003A   00D0               BEQ      .+4
   \   0000003C   7EE0               B        ??UsbCdcRequest_1
   \   0000003E   4648               LDR      R0,??UsbCdcRequest_0+0xC  ;; CdcReqPacket + 4
   \   00000040   0088               LDRH     R0,[R0, #+0]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   7AD1               BNE      ??UsbCdcRequest_1
    309                {
    310                  pCdcReqCtrl->Counter = MIN(sizeof(CDC_LineCoding_t),
    311                                            ((CdcReqPacket.wLength.Hi << 8) + CdcReqPacket.wLength.Lo));
   \   00000046   4548               LDR      R0,??UsbCdcRequest_0+0x10  ;; CdcReqPacket + 7
   \   00000048   0078               LDRB     R0,[R0, #+0]
   \   0000004A   0002               LSLS     R0,R0,#+8
   \   0000004C   4449               LDR      R1,??UsbCdcRequest_0+0x14  ;; CdcReqPacket + 6
   \   0000004E   0978               LDRB     R1,[R1, #+0]
   \   00000050   4018               ADDS     R0,R0,R1
   \   00000052   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000054   000C               LSRS     R0,R0,#+16
   \   00000056   0828               CMP      R0,#+8
   \   00000058   01D3               BCC      ??UsbCdcRequest_6
   \   0000005A   0720               MOVS     R0,#+7
   \   0000005C   05E0               B        ??UsbCdcRequest_7
   \                     ??UsbCdcRequest_6:
   \   0000005E   3F48               LDR      R0,??UsbCdcRequest_0+0x10  ;; CdcReqPacket + 7
   \   00000060   0078               LDRB     R0,[R0, #+0]
   \   00000062   0002               LSLS     R0,R0,#+8
   \   00000064   3E49               LDR      R1,??UsbCdcRequest_0+0x14  ;; CdcReqPacket + 6
   \   00000066   0978               LDRB     R1,[R1, #+0]
   \   00000068   4018               ADDS     R0,R0,R1
   \                     ??UsbCdcRequest_7:
   \   0000006A   6860               STR      R0,[R5, #+4]
    312                  pCdcReqCtrl->pData = (pInt8U)&CDC_LineCoding;
   \   0000006C   3D48               LDR      R0,??UsbCdcRequest_0+0x18  ;; CDC_LineCoding
   \   0000006E   2860               STR      R0,[R5, #+0]
    313                  return((void *)UsbPass);
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   67E0               B        ??UsbCdcRequest_8
    314                }
    315                break;
    316              case GET_LINE_CODING:
    317                if ((CdcReqPacket.wValue.Word == 0) &&
    318                    (CdcReqPacket.wIndex.Word == 0))
   \                     ??UsbCdcRequest_3:
   \   00000074   3748               LDR      R0,??UsbCdcRequest_0+0x8  ;; CdcReqPacket + 2
   \   00000076   0088               LDRH     R0,[R0, #+0]
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   5FD1               BNE      ??UsbCdcRequest_1
   \   0000007C   3648               LDR      R0,??UsbCdcRequest_0+0xC  ;; CdcReqPacket + 4
   \   0000007E   0088               LDRH     R0,[R0, #+0]
   \   00000080   0028               CMP      R0,#+0
   \   00000082   5BD1               BNE      ??UsbCdcRequest_1
    319                {
    320                  pCdcReqCtrl->Counter = sizeof(CDC_LineCoding_t);
   \   00000084   0720               MOVS     R0,#+7
   \   00000086   6860               STR      R0,[R5, #+4]
    321                  pCdcReqCtrl->pData   = (pInt8U)&CDC_LineCoding;
   \   00000088   3648               LDR      R0,??UsbCdcRequest_0+0x18  ;; CDC_LineCoding
   \   0000008A   2860               STR      R0,[R5, #+0]
    322                  return((void*)UsbPass);
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   59E0               B        ??UsbCdcRequest_8
    323                }
    324                break;
    325              case SET_CONTROL_LINE_STATE:
    326                if ((CdcReqPacket.wLength.Word == 0) &&
    327                    (CdcReqPacket.wIndex.Word == 0))
   \                     ??UsbCdcRequest_4:
   \   00000090   3348               LDR      R0,??UsbCdcRequest_0+0x14  ;; CdcReqPacket + 6
   \   00000092   0088               LDRH     R0,[R0, #+0]
   \   00000094   0028               CMP      R0,#+0
   \   00000096   51D1               BNE      ??UsbCdcRequest_1
   \   00000098   2F48               LDR      R0,??UsbCdcRequest_0+0xC  ;; CdcReqPacket + 4
   \   0000009A   0088               LDRH     R0,[R0, #+0]
   \   0000009C   0028               CMP      R0,#+0
   \   0000009E   4DD1               BNE      ??UsbCdcRequest_1
    328                {
    329                  CDC_LineState.DTR_State = ((CdcReqPacket.wValue.Lo & 1) != 0);
   \   000000A0   3148               LDR      R0,??UsbCdcRequest_0+0x1C  ;; CDC_LineState
   \   000000A2   0078               LDRB     R0,[R0, #+0]
   \   000000A4   FE21               MOVS     R1,#+254
   \   000000A6   0140               ANDS     R1,R1,R0
   \   000000A8   2A48               LDR      R0,??UsbCdcRequest_0+0x8  ;; CdcReqPacket + 2
   \   000000AA   0078               LDRB     R0,[R0, #+0]
   \   000000AC   0122               MOVS     R2,#+1
   \   000000AE   0240               ANDS     R2,R2,R0
   \   000000B0   0120               MOVS     R0,#+1
   \   000000B2   1040               ANDS     R0,R0,R2
   \   000000B4   0843               ORRS     R0,R0,R1
   \   000000B6   2C49               LDR      R1,??UsbCdcRequest_0+0x1C  ;; CDC_LineState
   \   000000B8   0870               STRB     R0,[R1, #+0]
    330                  CDC_LineState.RTS_State = ((CdcReqPacket.wValue.Lo & 2) != 0);
   \   000000BA   2648               LDR      R0,??UsbCdcRequest_0+0x8  ;; CdcReqPacket + 2
   \   000000BC   0078               LDRB     R0,[R0, #+0]
   \   000000BE   0221               MOVS     R1,#+2
   \   000000C0   0140               ANDS     R1,R1,R0
   \   000000C2   481E               SUBS     R0,R1,#+1
   \   000000C4   8041               SBCS     R0,R0,R0
   \   000000C6   C043               MVNS     R0,R0
   \   000000C8   C00F               LSRS     R0,R0,#+31
   \   000000CA   2749               LDR      R1,??UsbCdcRequest_0+0x1C  ;; CDC_LineState
   \   000000CC   0978               LDRB     R1,[R1, #+0]
   \   000000CE   FD22               MOVS     R2,#+253
   \   000000D0   0A40               ANDS     R2,R2,R1
   \   000000D2   4000               LSLS     R0,R0,#+1
   \   000000D4   0221               MOVS     R1,#+2
   \   000000D6   0140               ANDS     R1,R1,R0
   \   000000D8   1143               ORRS     R1,R1,R2
   \   000000DA   2348               LDR      R0,??UsbCdcRequest_0+0x1C  ;; CDC_LineState
   \   000000DC   0170               STRB     R1,[R0, #+0]
    331                  // Send AKN
    332                  pCdcReqCtrl->Counter = 0;
   \   000000DE   0020               MOVS     R0,#+0
   \   000000E0   6860               STR      R0,[R5, #+4]
    333          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    334                  LineStateDelta = TRUE;
   \   000000E2   2248               LDR      R0,??UsbCdcRequest_0+0x20  ;; LineStateDelta
   \   000000E4   0121               MOVS     R1,#+1
   \   000000E6   0160               STR      R1,[R0, #+0]
    335          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    336                  return((void*)UsbPass);
   \   000000E8   0020               MOVS     R0,#+0
   \   000000EA   2BE0               B        ??UsbCdcRequest_8
    337                }
    338                break;
    339          
    340          #if CDC_DEVICE_SUPPORT_BREAK > 0
    341              case SEND_BREAK:
    342          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    343                BreakCntr = CdcReqPacket.wValue.Word;
   \                     ??UsbCdcRequest_5:
   \   000000EC   1948               LDR      R0,??UsbCdcRequest_0+0x8  ;; CdcReqPacket + 2
   \   000000EE   0088               LDRH     R0,[R0, #+0]
   \   000000F0   1F49               LDR      R1,??UsbCdcRequest_0+0x24  ;; BreakCntr
   \   000000F2   0860               STR      R0,[R1, #+0]
    344                LineStateDelta = TRUE;
   \   000000F4   1D48               LDR      R0,??UsbCdcRequest_0+0x20  ;; LineStateDelta
   \   000000F6   0121               MOVS     R1,#+1
   \   000000F8   0160               STR      R1,[R0, #+0]
    345                if(BreakCntr != 0 && BreakCntr != 0xFFFF)
   \   000000FA   1D48               LDR      R0,??UsbCdcRequest_0+0x24  ;; BreakCntr
   \   000000FC   0068               LDR      R0,[R0, #+0]
   \   000000FE   0028               CMP      R0,#+0
   \   00000100   18D0               BEQ      ??UsbCdcRequest_9
   \   00000102   1B48               LDR      R0,??UsbCdcRequest_0+0x24  ;; BreakCntr
   \   00000104   0068               LDR      R0,[R0, #+0]
   \   00000106   1B49               LDR      R1,??UsbCdcRequest_0+0x28  ;; 0xffff
   \   00000108   8842               CMP      R0,R1
   \   0000010A   13D0               BEQ      ??UsbCdcRequest_9
    346                {
    347                  // Disable TIM1 counter
    348                  TIM_Cmd(TIM1, DISABLE);
   \   0000010C   0021               MOVS     R1,#+0
   \   0000010E   1A48               LDR      R0,??UsbCdcRequest_0+0x2C  ;; 0xffff9000
   \   00000110   ........           BL       TIM_Cmd
    349                  // Reset TIM1 counter
    350                  TIM_ResetCounter(TIM1);
   \   00000114   1848               LDR      R0,??UsbCdcRequest_0+0x2C  ;; 0xffff9000
   \   00000116   ........           BL       TIM_ResetCounter
    351                  // Clear TIM1 flags
    352                  TIM_ClearFlag(TIM1, TIM_FLAG_Update);
   \   0000011A   0121               MOVS     R1,#+1
   \   0000011C   1648               LDR      R0,??UsbCdcRequest_0+0x2C  ;; 0xffff9000
   \   0000011E   ........           BL       TIM_ClearFlag
    353                  // Enable TIM1 Update interrupt
    354                  TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);
   \   00000122   0122               MOVS     R2,#+1
   \   00000124   0121               MOVS     R1,#+1
   \   00000126   1448               LDR      R0,??UsbCdcRequest_0+0x2C  ;; 0xffff9000
   \   00000128   ........           BL       TIM_ITConfig
    355                  // Enable TIM1 counter
    356                  TIM_Cmd(TIM1, ENABLE);
   \   0000012C   0121               MOVS     R1,#+1
   \   0000012E   1248               LDR      R0,??UsbCdcRequest_0+0x2C  ;; 0xffff9000
   \   00000130   ........           BL       TIM_Cmd
    357                }
    358                // Send AKN
    359                pCdcReqCtrl->Counter = 0;
   \                     ??UsbCdcRequest_9:
   \   00000134   0020               MOVS     R0,#+0
   \   00000136   6860               STR      R0,[R5, #+4]
    360          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    361                return((void*)UsbPass);
   \   00000138   0020               MOVS     R0,#+0
   \   0000013A   03E0               B        ??UsbCdcRequest_8
    362          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
    363              }
    364            }
    365            CdcReqPacket.wLength.Word = 0;
   \                     ??UsbCdcRequest_1:
   \   0000013C   0848               LDR      R0,??UsbCdcRequest_0+0x14  ;; CdcReqPacket + 6
   \   0000013E   0021               MOVS     R1,#+0
   \   00000140   0180               STRH     R1,[R0, #+0]
    366            return((void *)UsbFault);
   \   00000142   0120               MOVS     R0,#+1
   \                     ??UsbCdcRequest_8:
   \   00000144   38BC               POP      {R3-R5}
   \   00000146   02BC               POP      {R1}
   \   00000148   0847               BX       R1               ;; return
   \   0000014A   C046               Nop      
   \                     ??UsbCdcRequest_0:
   \   0000014C   ........           DC32     CdcReqPacket
   \   00000150   ........           DC32     CdcReqPacket + 1
   \   00000154   ........           DC32     CdcReqPacket + 2
   \   00000158   ........           DC32     CdcReqPacket + 4
   \   0000015C   ........           DC32     CdcReqPacket + 7
   \   00000160   ........           DC32     CdcReqPacket + 6
   \   00000164   ........           DC32     CDC_LineCoding
   \   00000168   ........           DC32     CDC_LineState
   \   0000016C   ........           DC32     LineStateDelta
   \   00000170   ........           DC32     BreakCntr
   \   00000174   FFFF0000           DC32     0xffff
   \   00000178   0090FFFF           DC32     0xffff9000
    367          }
    368          
    369          /*************************************************************************
    370           * Function Name: UsbCdcData
    371           * Parameters:  void * pArg
    372           *
    373           * Return: void *
    374           *
    375           * Description: USB Communication Device Class Data receive
    376           *
    377           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    378          void * UsbCdcData (void * pArg)
    379          {
   \                     UsbCdcData:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    380            if ((CdcReqPacket.bRequest == SET_LINE_CODING) &&
    381                (CdcReqPacket.wLength.Word != 0))
   \   00000004   0848               LDR      R0,??UsbCdcData_0  ;; CdcReqPacket + 1
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   2028               CMP      R0,#+32
   \   0000000A   08D1               BNE      ??UsbCdcData_1
   \   0000000C   0748               LDR      R0,??UsbCdcData_0+0x4  ;; CdcReqPacket + 6
   \   0000000E   0088               LDRH     R0,[R0, #+0]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   04D0               BEQ      ??UsbCdcData_1
    382            {
    383          #if CDC_DEVICE_SUPPORT_LINE_CODING > 0
    384              LineCodingDelta = TRUE;
   \   00000014   0648               LDR      R0,??UsbCdcData_0+0x8  ;; LineCodingDelta
   \   00000016   0122               MOVS     R2,#+1
   \   00000018   0260               STR      R2,[R0, #+0]
    385          #endif // CDC_DEVICE_SUPPORT_LINE_CODING > 0
    386              return((void*)UsbPass);
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   00E0               B        ??UsbCdcData_2
    387            }
    388            return((void*)UsbFault);
   \                     ??UsbCdcData_1:
   \   0000001E   0120               MOVS     R0,#+1
   \                     ??UsbCdcData_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   02BC               POP      {R1}
   \   00000024   0847               BX       R1               ;; return
   \   00000026   C046               Nop      
   \                     ??UsbCdcData_0:
   \   00000028   ........           DC32     CdcReqPacket + 1
   \   0000002C   ........           DC32     CdcReqPacket + 6
   \   00000030   ........           DC32     LineCodingDelta
    389          }
    390          
    391          /*************************************************************************
    392           * Function Name: UsbCdcRead
    393           * Parameters: pInt8U pBuffer, Int32U Size
    394           *
    395           * Return: Int32U
    396           *
    397           * Description: USB Communication Device Class data read. Return number
    398           * of received the bytes.
    399           *
    400           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    401          Int32U UsbCdcRead (pInt8U pBuffer, Int32U Size)
    402          {
   \                     UsbCdcRead:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    403            Int32U ReadSize = 0, CurrReadSize = 0, Counter;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0600               MOVS     R6,R0
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0090               STR      R0,[SP, #+0]
    404            FunctionalState cpu_sr;
    405            
    406            while(Size)
   \                     ??UsbCdcRead_0:
   \   0000000E   002D               CMP      R5,#+0
   \   00000010   77D0               BEQ      ??UsbCdcRead_1
    407            {
    408              if(CDC_ReceiveIndx)
   \   00000012   3E48               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   52D0               BEQ      ??UsbCdcRead_3
    409              {
    410                CurrReadSize = MIN((CDC_ReceiveIndx - CDC_ReceiveIndxHold), Size);
   \   0000001A   3C48               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   3C49               LDR      R1,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   00000020   0968               LDR      R1,[R1, #+0]
   \   00000022   401A               SUBS     R0,R0,R1
   \   00000024   A842               CMP      R0,R5
   \   00000026   06D2               BCS      ??UsbCdcRead_4
   \   00000028   3848               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   3849               LDR      R1,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   0000002E   0968               LDR      R1,[R1, #+0]
   \   00000030   401A               SUBS     R0,R0,R1
   \   00000032   0090               STR      R0,[SP, #+0]
   \   00000034   00E0               B        ??UsbCdcRead_5
   \                     ??UsbCdcRead_4:
   \   00000036   0095               STR      R5,[SP, #+0]
    411                Size     -= CurrReadSize;
   \                     ??UsbCdcRead_5:
   \   00000038   0098               LDR      R0,[SP, #+0]
   \   0000003A   2D1A               SUBS     R5,R5,R0
    412                ReadSize += CurrReadSize;
   \   0000003C   0098               LDR      R0,[SP, #+0]
   \   0000003E   3618               ADDS     R6,R6,R0
    413                for(Counter = 0; Counter < CurrReadSize; ++Counter)
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   0700               MOVS     R7,R0
   \                     ??UsbCdcRead_6:
   \   00000044   0098               LDR      R0,[SP, #+0]
   \   00000046   8742               CMP      R7,R0
   \   00000048   0CD2               BCS      ??UsbCdcRead_7
    414                {
    415                  *pBuffer++ = CDC_ReceiveBuffer[CDC_ReceiveIndxHold++];
   \   0000004A   3148               LDR      R0,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   3149               LDR      R1,??UsbCdcRead_2+0x8  ;; CDC_ReceiveBuffer
   \   00000050   085C               LDRB     R0,[R1, R0]
   \   00000052   2070               STRB     R0,[R4, #+0]
   \   00000054   2E48               LDR      R0,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   00000056   0068               LDR      R0,[R0, #+0]
   \   00000058   401C               ADDS     R0,R0,#+1
   \   0000005A   2D49               LDR      R1,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   0000005C   0860               STR      R0,[R1, #+0]
   \   0000005E   641C               ADDS     R4,R4,#+1
    416                }
   \   00000060   7F1C               ADDS     R7,R7,#+1
   \   00000062   EFE7               B        ??UsbCdcRead_6
    417                if(CDC_ReceiveIndxHold == CDC_ReceiveIndx)
   \                     ??UsbCdcRead_7:
   \   00000064   2A48               LDR      R0,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   00000066   0068               LDR      R0,[R0, #+0]
   \   00000068   2849               LDR      R1,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   0000006A   0968               LDR      R1,[R1, #+0]
   \   0000006C   8842               CMP      R0,R1
   \   0000006E   CED1               BNE      ??UsbCdcRead_0
    418                {
    419                  CDC_ReceiveIndxHold = 0;
   \   00000070   2748               LDR      R0,??UsbCdcRead_2+0x4  ;; CDC_ReceiveIndxHold
   \   00000072   0021               MOVS     R1,#+0
   \   00000074   0160               STR      R1,[R0, #+0]
    420                  if (USB_CDC_OutEpBufferNotEmpty)
   \   00000076   2848               LDR      R0,??UsbCdcRead_2+0xC  ;; USB_CDC_OutEpBufferNotEmpty
   \   00000078   0078               LDRB     R0,[R0, #+0]
   \   0000007A   0028               CMP      R0,#+0
   \   0000007C   1CD0               BEQ      ??UsbCdcRead_8
    421                  {
    422                    EIC_IRQDisCmd(cpu_sr);
   \   0000007E   6846               MOV      R0,SP
   \   00000080   2649               LDR      R1,??UsbCdcRead_2+0x10  ;; 0xfffff800
   \   00000082   0968               LDR      R1,[R1, #+0]
   \   00000084   0122               MOVS     R2,#+1
   \   00000086   0A40               ANDS     R2,R2,R1
   \   00000088   0271               STRB     R2,[R0, #+4]
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   ........           BL       EIC_IRQCmd
    423                    CDC_ReceiveIndx = CommOutEpMaxSize;
   \   00000090   1E48               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   00000092   4021               MOVS     R1,#+64
   \   00000094   0160               STR      R1,[R0, #+0]
    424                    USB_EpRead((USB_Endpoint_t)CommOutEp,
    425                                CDC_ReceiveBuffer,
    426                               &CDC_ReceiveIndx);
   \   00000096   1D4A               LDR      R2,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   00000098   1E49               LDR      R1,??UsbCdcRead_2+0x8  ;; CDC_ReceiveBuffer
   \   0000009A   0420               MOVS     R0,#+4
   \   0000009C   ........           BL       USB_EpRead
    427                    USB_EpValidate((USB_Endpoint_t)CommOutEp,
    428                                   TRUE);
   \   000000A0   0121               MOVS     R1,#+1
   \   000000A2   0420               MOVS     R0,#+4
   \   000000A4   ........           BL       USB_EpValidate
    429                    USB_CDC_OutEpBufferNotEmpty = FALSE;
   \   000000A8   1B48               LDR      R0,??UsbCdcRead_2+0xC  ;; USB_CDC_OutEpBufferNotEmpty
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   0170               STRB     R1,[R0, #+0]
    430                    EIC_IRQRestoreCmd(cpu_sr);
   \   000000AE   6846               MOV      R0,SP
   \   000000B0   0079               LDRB     R0,[R0, #+4]
   \   000000B2   ........           BL       EIC_IRQCmd
   \   000000B6   AAE7               B        ??UsbCdcRead_0
    431                  }
    432                  else
    433                  {
    434                    CDC_ReceiveIndx = 0;
   \                     ??UsbCdcRead_8:
   \   000000B8   1448               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   000000BA   0021               MOVS     R1,#+0
   \   000000BC   0160               STR      R1,[R0, #+0]
   \   000000BE   A6E7               B        ??UsbCdcRead_0
    435                  }
    436                }
    437              }
    438              else if (USB_CDC_OutEpBufferNotEmpty)
   \                     ??UsbCdcRead_3:
   \   000000C0   1548               LDR      R0,??UsbCdcRead_2+0xC  ;; USB_CDC_OutEpBufferNotEmpty
   \   000000C2   0078               LDRB     R0,[R0, #+0]
   \   000000C4   0028               CMP      R0,#+0
   \   000000C6   1CD0               BEQ      ??UsbCdcRead_1
    439              {
    440                EIC_IRQDisCmd(cpu_sr);
   \   000000C8   6846               MOV      R0,SP
   \   000000CA   1449               LDR      R1,??UsbCdcRead_2+0x10  ;; 0xfffff800
   \   000000CC   0968               LDR      R1,[R1, #+0]
   \   000000CE   0122               MOVS     R2,#+1
   \   000000D0   0A40               ANDS     R2,R2,R1
   \   000000D2   0271               STRB     R2,[R0, #+4]
   \   000000D4   0020               MOVS     R0,#+0
   \   000000D6   ........           BL       EIC_IRQCmd
    441                CDC_ReceiveIndx = CommOutEpMaxSize;
   \   000000DA   0C48               LDR      R0,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   000000DC   4021               MOVS     R1,#+64
   \   000000DE   0160               STR      R1,[R0, #+0]
    442                USB_EpRead((USB_Endpoint_t)CommOutEp,
    443                            CDC_ReceiveBuffer,
    444                           &CDC_ReceiveIndx);
   \   000000E0   0A4A               LDR      R2,??UsbCdcRead_2  ;; CDC_ReceiveIndx
   \   000000E2   0C49               LDR      R1,??UsbCdcRead_2+0x8  ;; CDC_ReceiveBuffer
   \   000000E4   0420               MOVS     R0,#+4
   \   000000E6   ........           BL       USB_EpRead
    445                USB_EpValidate((USB_Endpoint_t)CommOutEp,
    446                               TRUE);
   \   000000EA   0121               MOVS     R1,#+1
   \   000000EC   0420               MOVS     R0,#+4
   \   000000EE   ........           BL       USB_EpValidate
    447                USB_CDC_OutEpBufferNotEmpty = FALSE;
   \   000000F2   0948               LDR      R0,??UsbCdcRead_2+0xC  ;; USB_CDC_OutEpBufferNotEmpty
   \   000000F4   0021               MOVS     R1,#+0
   \   000000F6   0170               STRB     R1,[R0, #+0]
    448                EIC_IRQRestoreCmd(cpu_sr);
   \   000000F8   6846               MOV      R0,SP
   \   000000FA   0079               LDRB     R0,[R0, #+4]
   \   000000FC   ........           BL       EIC_IRQCmd
   \   00000100   85E7               B        ??UsbCdcRead_0
    449              }
    450              else
    451              {
    452                break;
    453              }
    454            }
    455            return(ReadSize);
   \                     ??UsbCdcRead_1:
   \   00000102   3000               MOVS     R0,R6
   \   00000104   FEBC               POP      {R1-R7}
   \   00000106   02BC               POP      {R1}
   \   00000108   0847               BX       R1               ;; return
   \   0000010A   C046               Nop      
   \                     ??UsbCdcRead_2:
   \   0000010C   ........           DC32     CDC_ReceiveIndx
   \   00000110   ........           DC32     CDC_ReceiveIndxHold
   \   00000114   ........           DC32     CDC_ReceiveBuffer
   \   00000118   ........           DC32     USB_CDC_OutEpBufferNotEmpty
   \   0000011C   00F8FFFF           DC32     0xfffff800
    456          }
    457          
    458          /*************************************************************************
    459           * Function Name: UsbCdcWrite
    460           * Parameters:  pInt8U pBuffer, Int32U Size
    461           *
    462           * Return: CdcStatus_t
    463           *
    464           * Description: USB Communication Device Class data send.
    465           *
    466           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    467          Boolean UsbCdcWrite (pInt8U pBuffer, Int32U Size)
    468          {
   \                     UsbCdcWrite:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    469          Boolean Status = !UsbCdcIsSendProgess();
   \   00000006   ........           BL       UsbCdcIsSendProgess
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   8041               SBCS     R0,R0,R0
   \   0000000E   C00F               LSRS     R0,R0,#+31
   \   00000010   0600               MOVS     R6,R0
    470          Int32U Counter, CurrWriteSize;
    471          FunctionalState cpu_sr;
    472            if(Status == TRUE)
   \   00000012   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000014   360E               LSRS     R6,R6,#+24
   \   00000016   012E               CMP      R6,#+1
   \   00000018   35D1               BNE      ??UsbCdcWrite_0
    473            {
    474              pCDC_TransmitUserBuffer = pBuffer;
   \   0000001A   1E48               LDR      R0,??UsbCdcWrite_1  ;; pCDC_TransmitUserBuffer
   \   0000001C   0460               STR      R4,[R0, #+0]
    475              CDC_TransmitSize = Size;
   \   0000001E   1E48               LDR      R0,??UsbCdcWrite_1+0x4  ;; CDC_TransmitSize
   \   00000020   0560               STR      R5,[R0, #+0]
    476              CurrWriteSize = MIN(CDC_TransmitSize,CommInEpMaxSize);
   \   00000022   1D48               LDR      R0,??UsbCdcWrite_1+0x4  ;; CDC_TransmitSize
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   4028               CMP      R0,#+64
   \   00000028   03D2               BCS      ??UsbCdcWrite_2
   \   0000002A   1B48               LDR      R0,??UsbCdcWrite_1+0x4  ;; CDC_TransmitSize
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   0090               STR      R0,[SP, #+0]
   \   00000030   01E0               B        ??UsbCdcWrite_3
   \                     ??UsbCdcWrite_2:
   \   00000032   4020               MOVS     R0,#+64
   \   00000034   0090               STR      R0,[SP, #+0]
    477              for(Counter = 0; Counter < CurrWriteSize; ++Counter)
   \                     ??UsbCdcWrite_3:
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   0700               MOVS     R7,R0
   \                     ??UsbCdcWrite_4:
   \   0000003A   0098               LDR      R0,[SP, #+0]
   \   0000003C   8742               CMP      R7,R0
   \   0000003E   0AD2               BCS      ??UsbCdcWrite_5
    478              {
    479                CDC_TransmitBuffer[Counter] = *pCDC_TransmitUserBuffer++;
   \   00000040   1448               LDR      R0,??UsbCdcWrite_1  ;; pCDC_TransmitUserBuffer
   \   00000042   0068               LDR      R0,[R0, #+0]
   \   00000044   0100               MOVS     R1,R0
   \   00000046   491C               ADDS     R1,R1,#+1
   \   00000048   124A               LDR      R2,??UsbCdcWrite_1  ;; pCDC_TransmitUserBuffer
   \   0000004A   1160               STR      R1,[R2, #+0]
   \   0000004C   1349               LDR      R1,??UsbCdcWrite_1+0x8  ;; CDC_TransmitBuffer
   \   0000004E   0078               LDRB     R0,[R0, #+0]
   \   00000050   C855               STRB     R0,[R1, R7]
    480              }
   \   00000052   7F1C               ADDS     R7,R7,#+1
   \   00000054   F1E7               B        ??UsbCdcWrite_4
    481              CDC_TransmitSize -= CurrWriteSize;
   \                     ??UsbCdcWrite_5:
   \   00000056   1048               LDR      R0,??UsbCdcWrite_1+0x4  ;; CDC_TransmitSize
   \   00000058   0068               LDR      R0,[R0, #+0]
   \   0000005A   0099               LDR      R1,[SP, #+0]
   \   0000005C   401A               SUBS     R0,R0,R1
   \   0000005E   0E49               LDR      R1,??UsbCdcWrite_1+0x4  ;; CDC_TransmitSize
   \   00000060   0860               STR      R0,[R1, #+0]
    482              EIC_IRQDisCmd(cpu_sr);
   \   00000062   6846               MOV      R0,SP
   \   00000064   0E49               LDR      R1,??UsbCdcWrite_1+0xC  ;; 0xfffff800
   \   00000066   0968               LDR      R1,[R1, #+0]
   \   00000068   0122               MOVS     R2,#+1
   \   0000006A   0A40               ANDS     R2,R2,R1
   \   0000006C   0271               STRB     R2,[R0, #+4]
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   ........           BL       EIC_IRQCmd
    483              USB_EpWrite((USB_Endpoint_t)CommInEp,CDC_TransmitBuffer,&CurrWriteSize);
   \   00000074   6A46               MOV      R2,SP
   \   00000076   0949               LDR      R1,??UsbCdcWrite_1+0x8  ;; CDC_TransmitBuffer
   \   00000078   0520               MOVS     R0,#+5
   \   0000007A   ........           BL       USB_EpWrite
    484              EIC_IRQRestoreCmd(cpu_sr);
   \   0000007E   6846               MOV      R0,SP
   \   00000080   0079               LDRB     R0,[R0, #+4]
   \   00000082   ........           BL       EIC_IRQCmd
    485            }
    486            return(Status);
   \                     ??UsbCdcWrite_0:
   \   00000086   3000               MOVS     R0,R6
   \   00000088   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000008A   000E               LSRS     R0,R0,#+24
   \   0000008C   FEBC               POP      {R1-R7}
   \   0000008E   02BC               POP      {R1}
   \   00000090   0847               BX       R1               ;; return
   \   00000092   C046               Nop      
   \                     ??UsbCdcWrite_1:
   \   00000094   ........           DC32     pCDC_TransmitUserBuffer
   \   00000098   ........           DC32     CDC_TransmitSize
   \   0000009C   ........           DC32     CDC_TransmitBuffer
   \   000000A0   00F8FFFF           DC32     0xfffff800
    487          }
    488          
    489          /*************************************************************************
    490           * Function Name: UsbCdcIsSendProgess
    491           * Parameters:  none
    492           *
    493           * Return: Boolean
    494           *
    495           * Description: Is all data send?
    496           *
    497           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    498          Boolean UsbCdcIsSendProgess (void)
    499          {
   \                     UsbCdcIsSendProgess:
   \   00000000   01B5               PUSH     {R0,LR}
    500            return(pCDC_TransmitUserBuffer != NULL);
   \   00000002   0648               LDR      R0,??UsbCdcIsSendProgess_0  ;; pCDC_TransmitUserBuffer
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   01D0               BEQ      ??UsbCdcIsSendProgess_1
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   00E0               B        ??UsbCdcIsSendProgess_2
   \                     ??UsbCdcIsSendProgess_1:
   \   0000000E   0020               MOVS     R0,#+0
   \                     ??UsbCdcIsSendProgess_2:
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   08BC               POP      {R3}
   \   00000016   02BC               POP      {R1}
   \   00000018   0847               BX       R1               ;; return
   \   0000001A   C046               Nop      
   \                     ??UsbCdcIsSendProgess_0:
   \   0000001C   ........           DC32     pCDC_TransmitUserBuffer
    501          }
    502          
    503          /*************************************************************************
    504           * Function Name: UsbCdcIsCdcConfigure
    505           * Parameters:  none
    506           *
    507           * Return: Boolean
    508           *
    509           * Description:  Is CDC configure yet?
    510           *
    511           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    512          Boolean UsbCdcIsCdcConfigure (void)
    513          {
    514            return(CDC_Configure);
   \                     UsbCdcIsCdcConfigure:
   \   00000000   0148               LDR      R0,??UsbCdcIsCdcConfigure_0  ;; CDC_Configure
   \   00000002   0078               LDRB     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
   \   00000006   C046               Nop      
   \                     ??UsbCdcIsCdcConfigure_0:
   \   00000008   ........           DC32     CDC_Configure
    515          }
    516          
    517          #if CDC_DEVICE_SUPPORT_LINE_STATE > 0
    518          /*************************************************************************
    519           * Function Name: UsbCdcIsNewLineStateSettings
    520           * Parameters:  none
    521           *
    522           * Return: Boolean
    523           *
    524           * Description: Is there a new modem settings received?
    525           * RTS and DTR signals
    526           *
    527           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    528          Boolean UsbCdcIsNewLineStateSettings(void)
    529          {
   \                     UsbCdcIsNewLineStateSettings:
   \   00000000   10B5               PUSH     {R4,LR}
    530          Boolean StateHold;
    531            StateHold = (AtomicExchange(FALSE,(pInt32U)&LineStateDelta) != 0);
   \   00000002   0749               LDR      R1,??UsbCdcIsNewLineStateSettings_0  ;; LineStateDelta
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       AtomicExchange
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   8041               SBCS     R0,R0,R0
   \   0000000E   C043               MVNS     R0,R0
   \   00000010   C00F               LSRS     R0,R0,#+31
   \   00000012   0400               MOVS     R4,R0
    532            return(StateHold);
   \   00000014   2000               MOVS     R0,R4
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   \   0000001A   10BC               POP      {R4}
   \   0000001C   02BC               POP      {R1}
   \   0000001E   0847               BX       R1               ;; return
   \                     ??UsbCdcIsNewLineStateSettings_0:
   \   00000020   ........           DC32     LineStateDelta
    533          }
    534          
    535          /*************************************************************************
    536           * Function Name: UsbCdcGetLineStateSettings
    537           * Parameters:  none
    538           *
    539           * Return: CDC_LineState_t
    540           *
    541           * Description: Return the Line Signals states structure
    542           * RTS and DTR signals
    543           *
    544           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    545          CDC_LineState_t UsbCdcGetLineStateSettings(void)
    546          {
   \                     UsbCdcGetLineStateSettings:
   \   00000000   82B0               SUB      SP,SP,#+8
   \   00000002   0348               LDR      R0,??UsbCdcGetLineStateSettings_0  ;; CDC_LineState
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0090               STR      R0,[SP, #+0]
    547            return(CDC_LineState);
   \   00000008   0098               LDR      R0,[SP, #+0]
   \   0000000A   0CBC               POP      {R2,R3}
   \   0000000C   7047               BX       LR               ;; return
   \   0000000E   C046               Nop      
   \                     ??UsbCdcGetLineStateSettings_0:
   \   00000010   ........           DC32     CDC_LineState
    548          }
    549          
    550          /*************************************************************************
    551           * Function Name: UsbCdcReportSerialCommState
    552           * Parameters: SerialState_t SerialState
    553           *
    554           * Return: none
    555           *
    556           * Description: Report the current state of serial communication channel
    557           * Overrun Error,  Parity Error, Framing Error, Ring Signal, Break,
    558           * Tx Carrier, Rx Carrier
    559           *
    560           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    561          void UsbCdcReportSerialCommState(SerialState_t SerialState)
    562          {
   \                     UsbCdcReportSerialCommState:
   \   00000000   11B5               PUSH     {R0,R4,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    563          FunctionalState cpu_sr;
    564          Int32U Size;
    565          SerialStatePacket_t SerialStatePacket;
    566            if(CDC_Configure == FALSE)
   \   00000004   1C48               LDR      R0,??UsbCdcReportSerialCommState_0  ;; CDC_Configure
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   30D0               BEQ      ??UsbCdcReportSerialCommState_1
    567            {
    568              return;
    569            }
    570            SerialStatePacket.UsbSetupPacket.mRequestType.mRequestTypeData = 0xA1;
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   A121               MOVS     R1,#+161
   \   00000010   0171               STRB     R1,[R0, #+4]
    571            SerialStatePacket.UsbSetupPacket.bRequest = SERIAL_STATE;
   \   00000012   01A8               ADD      R0,SP,#+4
   \   00000014   2021               MOVS     R1,#+32
   \   00000016   4170               STRB     R1,[R0, #+1]
    572            SerialStatePacket.UsbSetupPacket.wValue.Word = 0;
   \   00000018   01A8               ADD      R0,SP,#+4
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   4180               STRH     R1,[R0, #+2]
    573            SerialStatePacket.UsbSetupPacket.wIndex.Word = CDC_DATA_INTERFACE_IND;
   \   0000001E   01A8               ADD      R0,SP,#+4
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   8180               STRH     R1,[R0, #+4]
    574            SerialStatePacket.UsbSetupPacket.wLength.Word = sizeof(SerialState_t);
   \   00000024   01A8               ADD      R0,SP,#+4
   \   00000026   0221               MOVS     R1,#+2
   \   00000028   C180               STRH     R1,[R0, #+6]
    575            SerialStatePacket.SerialState = SerialState;
   \   0000002A   01A8               ADD      R0,SP,#+4
   \   0000002C   0830               ADDS     R0,R0,#+8
   \   0000002E   05A9               ADD      R1,SP,#+20
   \   00000030   0A78               LDRB     R2,[R1, #0]
   \   00000032   0270               STRB     R2,[R0, #0]
   \   00000034   4A78               LDRB     R2,[R1, #+1]
   \   00000036   4270               STRB     R2,[R0, #+1]
    576          
    577            SerialStateDelta = TRUE;
   \   00000038   1048               LDR      R0,??UsbCdcReportSerialCommState_0+0x4  ;; SerialStateDelta
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   0160               STR      R1,[R0, #+0]
    578            Size = sizeof(SerialStatePacket_t);
   \   0000003E   0A20               MOVS     R0,#+10
   \   00000040   0090               STR      R0,[SP, #+0]
    579            // Disable interrupt and save current state of the interrupt flags
    580            EIC_IRQDisCmd(cpu_sr);
   \   00000042   0F48               LDR      R0,??UsbCdcReportSerialCommState_0+0x8  ;; 0xfffff800
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   0140               ANDS     R1,R1,R0
   \   0000004A   0C00               MOVS     R4,R1
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   ........           BL       EIC_IRQCmd
    581            USB_EpWrite((USB_Endpoint_t)ReportEp,(pInt8U)&SerialStatePacket,&Size);
   \   00000052   6A46               MOV      R2,SP
   \   00000054   01A9               ADD      R1,SP,#+4
   \   00000056   0320               MOVS     R0,#+3
   \   00000058   ........           BL       USB_EpWrite
    582            EIC_IRQRestoreCmd(cpu_sr);
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000060   000E               LSRS     R0,R0,#+24
   \   00000062   ........           BL       EIC_IRQCmd
    583            while(SerialStateDelta);
   \                     ??UsbCdcReportSerialCommState_2:
   \   00000066   0548               LDR      R0,??UsbCdcReportSerialCommState_0+0x4  ;; SerialStateDelta
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   FBD1               BNE      ??UsbCdcReportSerialCommState_2
   \                     ??UsbCdcReportSerialCommState_1:
   \   0000006E   06B0               ADD      SP,SP,#+24
   \   00000070   10BC               POP      {R4}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??UsbCdcReportSerialCommState_0:
   \   00000078   ........           DC32     CDC_Configure
   \   0000007C   ........           DC32     SerialStateDelta
   \   00000080   00F8FFFF           DC32     0xfffff800
    584          }
    585          
    586          #endif // CDC_DEVICE_SUPPORT_LINE_STATE > 0
    587          
    588          #if CDC_DEVICE_SUPPORT_BREAK > 0
    589          /*************************************************************************
    590           * Function Name: CDC_BreakCallBack
    591           * Parameters: void* arg
    592           *
    593           * Return: none
    594           *
    595           * Description: Break Timer callback routine that is called form the timer
    596           * interrupt routine after expire of break period.
    597           *
    598           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    599          void CDC_BreakCallBack (void* arg)
    600          {
    601            BreakCntr = 0;
   \                     CDC_BreakCallBack:
   \   00000000   0149               LDR      R1,??CDC_BreakCallBack_0  ;; BreakCntr
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0A60               STR      R2,[R1, #+0]
    602          }
   \   00000006   7047               BX       LR               ;; return
   \                     ??CDC_BreakCallBack_0:
   \   00000008   ........           DC32     BreakCntr
    603          
    604          /*************************************************************************
    605           * Function Name: UsbCdcGetBreakState
    606           * Parameters:  none
    607           *
    608           * Return: Boolean
    609           *
    610           * Description: Return Break event state
    611           *
    612           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    613          Boolean UsbCdcGetBreakState(void)
    614          {
    615            return(BreakCntr != 0);
   \                     UsbCdcGetBreakState:
   \   00000000   0448               LDR      R0,??UsbCdcGetBreakState_0  ;; BreakCntr
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   401E               SUBS     R0,R0,#+1
   \   00000006   8041               SBCS     R0,R0,R0
   \   00000008   C043               MVNS     R0,R0
   \   0000000A   C00F               LSRS     R0,R0,#+31
   \   0000000C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000E   000E               LSRS     R0,R0,#+24
   \   00000010   7047               BX       LR               ;; return
   \   00000012   C046               Nop      
   \                     ??UsbCdcGetBreakState_0:
   \   00000014   ........           DC32     BreakCntr
    616          }
    617          #endif // CDC_DEVICE_SUPPORT_BREAK > 0
    618          
    619          #if CDC_DEVICE_SUPPORT_LINE_CODING > 0
    620          /*************************************************************************
    621           * Function Name: UsbCdcIsNewLineCtrlSettings
    622           * Parameters:  none
    623           *
    624           * Return: Boolean
    625           *
    626           * Description: Is there a new line settings received?
    627           * Baud rate, Data bits, Stop bits and Parity
    628           *
    629           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    630          Boolean UsbCdcIsNewLineCodingSettings(void)
    631          {
   \                     UsbCdcIsNewLineCodingSettings:
   \   00000000   10B5               PUSH     {R4,LR}
    632          Boolean StateHold;
    633            StateHold = (AtomicExchange(FALSE,(pInt32U)&LineCodingDelta) != 0);
   \   00000002   0749               LDR      R1,??UsbCdcIsNewLineCodingSettings_0  ;; LineCodingDelta
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       AtomicExchange
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   8041               SBCS     R0,R0,R0
   \   0000000E   C043               MVNS     R0,R0
   \   00000010   C00F               LSRS     R0,R0,#+31
   \   00000012   0400               MOVS     R4,R0
    634            return(StateHold);
   \   00000014   2000               MOVS     R0,R4
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   \   0000001A   10BC               POP      {R4}
   \   0000001C   02BC               POP      {R1}
   \   0000001E   0847               BX       R1               ;; return
   \                     ??UsbCdcIsNewLineCodingSettings_0:
   \   00000020   ........           DC32     LineCodingDelta
    635          }
    636          
    637          /*************************************************************************
    638           * Function Name: UsbCdcGetLineCodingSettings
    639           * Parameters:  none
    640           *
    641           * Return: CDC_LineCoding_t
    642           *
    643           * Description: Return the Line Coding structure
    644           * Baud rate, Data bits, Stop bits and Parity
    645           *
    646           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    647          CDC_LineCoding_t UsbCdcGetLineCodingSettings(void)
    648          {
   \                     UsbCdcGetLineCodingSettings:
   \   00000000   01B5               PUSH     {R0,LR}
    649            return(CDC_LineCoding);
   \   00000002   0349               LDR      R1,??UsbCdcGetLineCodingSettings_0  ;; CDC_LineCoding
   \   00000004   0722               MOVS     R2,#+7
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   08BC               POP      {R3}
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return
   \                     ??UsbCdcGetLineCodingSettings_0:
   \   00000010   ........           DC32     CDC_LineCoding
    650          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     CDC_LineCoding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     LineCodingDelta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     CDC_LineState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     LineStateDelta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0090FFFF           DC32     0xffff9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     CDC_ReceiveIndxHold

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   ........           DC32     BreakCntr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     CDC_Configure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     SerialStateDelta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   ........           DC32     CDC_ReceiveIndx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   ........           DC32     CDC_ReceiveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   ........           DC32     USB_CDC_OutEpBufferNotEmpty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   ........           DC32     CDC_TransmitSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   ........           DC32     CDC_TransmitBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   ........           DC32     pCDC_TransmitUserBuffer
    651          #endif // CDC_DEVICE_SUPPORT_LINE_CODING > 0

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     AtomicExchange                     0
     CDC_BreakCallBack                  0
     Tim1Handler                        8
     UsbCdcConfigure                   16
     UsbCdcData                         8
     UsbCdcGetBreakState                0
     UsbCdcGetLineCodingSettings        8
     UsbCdcGetLineStateSettings         8
     UsbCdcInHadler                     8
     UsbCdcInit                        72
     UsbCdcIsCdcConfigure               0
     UsbCdcIsNewLineCodingSettings      8
     UsbCdcIsNewLineStateSettings       8
     UsbCdcIsSendProgess                8
     UsbCdcOutHadler                   16
     UsbCdcRead                        32
     UsbCdcReportHadler                 0
     UsbCdcReportSerialCommState       32
     UsbCdcRequest                     16
     UsbCdcWrite                       32


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     AtomicExchange                   8
     CDC_LineCoding                   8
     LineCodingDelta                  4
     CDC_LineState                    4
     SerialStateDelta                 4
     LineStateDelta                   4
     BreakCntr                        4
     CdcReqPacket                     8
     CDC_ReceiveIndx                  4
     CDC_ReceiveIndxHold              4
     CDC_TransmitSize                 4
     USB_CDC_OutEpBufferNotEmpty      1
     pCDC_TransmitUserBuffer          4
     CDC_ReceiveBuffer               64
     CDC_TransmitBuffer              64
     CDC_Configure                    1
     Tim1Handler                     50
     UsbCdcInit                     256
     UsbCdcConfigure                200
     UsbCdcReportHadler               8
     UsbCdcInHadler                  50
     UsbCdcOutHadler                100
     UsbCdcRequest                  380
     UsbCdcData                      52
     UsbCdcRead                     288
     UsbCdcWrite                    164
     UsbCdcIsSendProgess             32
     UsbCdcIsCdcConfigure            12
     UsbCdcIsNewLineStateSettings    36
     UsbCdcGetLineStateSettings      20
     UsbCdcReportSerialCommState    132
     CDC_BreakCallBack               12
     UsbCdcGetBreakState             24
     UsbCdcIsNewLineCodingSettings   36
     UsbCdcGetLineCodingSettings     20
     ??DataTable6                     4
     ??DataTable7                     4
     ??DataTable11                    4
     ??DataTable12                    4
     ??DataTable15                    4
     ??DataTable23                    4
     ??DataTable26                    4
     ??DataTable27                    4
     ??DataTable28                    4
     ??DataTable31                    4
     ??DataTable32                    4
     ??DataTable33                    4
     ??DataTable41                    4
     ??DataTable42                    4
     ??DataTable43                    4

 
   182 bytes in section .bss
 1 940 bytes in section .text
 
 1 932 bytes of CODE memory (+ 8 bytes shared)
   182 bytes of DATA memory

Errors: none
Warnings: none
