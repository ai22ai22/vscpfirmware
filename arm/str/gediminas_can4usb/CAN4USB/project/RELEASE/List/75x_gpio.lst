###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:19 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Program\IAR Systems\Embedded Workbench                #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _gpio.c                                                  #
#    Command line =  "D:\Program\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _gpio.c" -lC D:\development\gediminas\CAN4USB\project\RE #
#                    LEASE\List\ -lA D:\development\gediminas\CAN4USB\project #
#                    \RELEASE\List\ -o D:\development\gediminas\CAN4USB\proje #
#                    ct\RELEASE\Obj\ --no_cse --no_unroll --no_inline         #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian little --cpu            #
#                    ARM7TDMI-S -e --fpu None --dlib_config "D:\Program\IAR   #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I D:\development\gediminas\CAN4USB\project\ -I     #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\75 #
#                    x_gpio.lst                                               #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\75x #
#                    _gpio.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Program\IAR Systems\Embedded Workbench 5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x_gpio.c
      1          /******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
      2          * File Name          : 75x_gpio.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 03/10/2006
      5          * Description        : This file provides all the GPIO software functions.
      6          ********************************************************************************
      7          * History:
      8          * 07/17/2006 : V1.0
      9          * 03/10/2006 : V0.1
     10          ********************************************************************************
     11          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     13          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     14          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     15          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     16          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *******************************************************************************/
     18          
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "75x_gpio.h"
     21          #include "75x_mrcc.h"
     22          
     23          /* Private typedef -----------------------------------------------------------*/
     24          /* Private define ------------------------------------------------------------*/
     25          #define GPIO_Remap_Mask    0x1F       /* GPIO remapping mask */
     26          #define GPIO_Pin_Mask      0x000FFFFF /* GPIO1 and GPIO2 all pins mask */
     27          
     28          /* Private macro -------------------------------------------------------------*/
     29          /* Private variables ---------------------------------------------------------*/
     30          /* Private function prototypes -----------------------------------------------*/
     31          /* Private functions ---------------------------------------------------------*/
     32          
     33          /*******************************************************************************
     34          * Function Name  : GPIO_DeInit
     35          * Description    : Deinitializes the GPIOx peripheral registers to their default
     36          *                  reset values.
     37          *                  The I/O remapping register 0 and 1 are not reset by this function.
     38          * Input          : GPIOx: where x can be 0,1 or 2 to select the GPIO peripheral.
     39          * Output         : None
     40          * Return         : None
     41          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     42          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     43          {
     44            /* Reset the GPIOx registers values */
     45            GPIOx->PC0 = 0xFFFFFFFF;
   \                     GPIO_DeInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   C943               MVNS     R1,R1            ;; #-1
   \   00000004   0160               STR      R1,[R0, #+0]
     46            GPIOx->PC1 = 0x0;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   4160               STR      R1,[R0, #+4]
     47            GPIOx->PC2 = 0x0;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   8160               STR      R1,[R0, #+8]
     48            GPIOx->PM = 0x0;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0161               STR      R1,[R0, #+16]
     49          }
   \   00000012   7047               BX       LR               ;; return
     50          
     51          /*******************************************************************************
     52          * Function Name  : GPIO_Init
     53          * Description    : Initializes the GPIOx peripheral according to the specified
     54          *                  parameters in the GPIO_InitStruct. This function will not
     55          *                  change the configuration for a pin if the corresponding mask
     56          *                  bit is set, except pins configured as input pull-up or pull-down.
     57          *                  These pins are automatically masked after each configuration.
     58          * Input          :- GPIOx: where x can be (0..2) to select the GPIO peripheral.
     59          *                 - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
     60          *                   contains the configuration information for the specified GPIO
     61          *                   peripheral.
     62          * Output         : None
     63          * Return         : None
     64          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     65          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
     66          {
   \                     GPIO_Init:
   \   00000000   01B5               PUSH     {R0,LR}
     67            /* GPIOx Mode and Pins Set */
     68            if((GPIOx != GPIO0) && (GPIO_InitStruct->GPIO_Pin == GPIO_Pin_All))
   \   00000002   574A               LDR      R2,??GPIO_Init_0  ;; 0xffffe400
   \   00000004   9042               CMP      R0,R2
   \   00000006   06D0               BEQ      ??GPIO_Init_1
   \   00000008   0A68               LDR      R2,[R1, #+0]
   \   0000000A   0023               MOVS     R3,#+0
   \   0000000C   DB43               MVNS     R3,R3            ;; #-1
   \   0000000E   9A42               CMP      R2,R3
   \   00000010   01D1               BNE      ??GPIO_Init_1
     69            {
     70              GPIO_InitStruct->GPIO_Pin = GPIO_Pin_Mask;
   \   00000012   544A               LDR      R2,??GPIO_Init_0+0x4  ;; 0xfffff
   \   00000014   0A60               STR      R2,[R1, #+0]
     71            }
     72          
     73            switch(GPIO_InitStruct->GPIO_Mode)
   \                     ??GPIO_Init_1:
   \   00000016   0A79               LDRB     R2,[R1, #+4]
   \   00000018   521E               SUBS     R2,R2,#+1
   \   0000001A   0ED0               BEQ      ??GPIO_Init_2
   \   0000001C   521E               SUBS     R2,R2,#+1
   \   0000001E   19D0               BEQ      ??GPIO_Init_3
   \   00000020   521E               SUBS     R2,R2,#+1
   \   00000022   24D0               BEQ      ??GPIO_Init_4
   \   00000024   521E               SUBS     R2,R2,#+1
   \   00000026   3BD0               BEQ      ??GPIO_Init_5
   \   00000028   521E               SUBS     R2,R2,#+1
   \   0000002A   52D0               BEQ      ??GPIO_Init_6
   \   0000002C   521E               SUBS     R2,R2,#+1
   \   0000002E   5DD0               BEQ      ??GPIO_Init_7
   \   00000030   521E               SUBS     R2,R2,#+1
   \   00000032   68D0               BEQ      ??GPIO_Init_8
   \   00000034   521E               SUBS     R2,R2,#+1
   \   00000036   77D0               BEQ      ??GPIO_Init_9
   \   00000038   83E0               B        ??GPIO_Init_10
     74            {
     75              case GPIO_Mode_AIN:
     76                GPIOx->PC0 &= ~GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_2:
   \   0000003A   0268               LDR      R2,[R0, #+0]
   \   0000003C   0B68               LDR      R3,[R1, #+0]
   \   0000003E   9A43               BICS     R2,R2,R3
   \   00000040   0260               STR      R2,[R0, #+0]
     77                GPIOx->PC1 &= ~GPIO_InitStruct->GPIO_Pin;
   \   00000042   4268               LDR      R2,[R0, #+4]
   \   00000044   0B68               LDR      R3,[R1, #+0]
   \   00000046   9A43               BICS     R2,R2,R3
   \   00000048   4260               STR      R2,[R0, #+4]
     78                GPIOx->PC2 &= ~GPIO_InitStruct->GPIO_Pin;
   \   0000004A   8268               LDR      R2,[R0, #+8]
   \   0000004C   0B68               LDR      R3,[R1, #+0]
   \   0000004E   9A43               BICS     R2,R2,R3
   \   00000050   8260               STR      R2,[R0, #+8]
   \   00000052   82E0               B        ??GPIO_Init_11
     79                break;
     80          
     81              case GPIO_Mode_IN_FLOATING:
     82                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_3:
   \   00000054   0268               LDR      R2,[R0, #+0]
   \   00000056   0B68               LDR      R3,[R1, #+0]
   \   00000058   1343               ORRS     R3,R3,R2
   \   0000005A   0360               STR      R3,[R0, #+0]
     83                GPIOx->PC1 &= ~GPIO_InitStruct->GPIO_Pin;
   \   0000005C   4268               LDR      R2,[R0, #+4]
   \   0000005E   0B68               LDR      R3,[R1, #+0]
   \   00000060   9A43               BICS     R2,R2,R3
   \   00000062   4260               STR      R2,[R0, #+4]
     84                GPIOx->PC2 &= ~GPIO_InitStruct->GPIO_Pin;
   \   00000064   8268               LDR      R2,[R0, #+8]
   \   00000066   0B68               LDR      R3,[R1, #+0]
   \   00000068   9A43               BICS     R2,R2,R3
   \   0000006A   8260               STR      R2,[R0, #+8]
   \   0000006C   75E0               B        ??GPIO_Init_11
     85                break;
     86          
     87              case GPIO_Mode_IPD:
     88                GPIOx->PM  &= ~GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_4:
   \   0000006E   0269               LDR      R2,[R0, #+16]
   \   00000070   0B68               LDR      R3,[R1, #+0]
   \   00000072   9A43               BICS     R2,R2,R3
   \   00000074   0261               STR      R2,[R0, #+16]
     89                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \   00000076   0268               LDR      R2,[R0, #+0]
   \   00000078   0B68               LDR      R3,[R1, #+0]
   \   0000007A   1343               ORRS     R3,R3,R2
   \   0000007C   0360               STR      R3,[R0, #+0]
     90                GPIOx->PC1 |=  GPIO_InitStruct->GPIO_Pin;
   \   0000007E   4268               LDR      R2,[R0, #+4]
   \   00000080   0B68               LDR      R3,[R1, #+0]
   \   00000082   1343               ORRS     R3,R3,R2
   \   00000084   4360               STR      R3,[R0, #+4]
     91                GPIOx->PC2 &= ~GPIO_InitStruct->GPIO_Pin;
   \   00000086   8268               LDR      R2,[R0, #+8]
   \   00000088   0B68               LDR      R3,[R1, #+0]
   \   0000008A   9A43               BICS     R2,R2,R3
   \   0000008C   8260               STR      R2,[R0, #+8]
     92                GPIOx->PD  &= ~GPIO_InitStruct->GPIO_Pin;
   \   0000008E   C268               LDR      R2,[R0, #+12]
   \   00000090   0B68               LDR      R3,[R1, #+0]
   \   00000092   9A43               BICS     R2,R2,R3
   \   00000094   C260               STR      R2,[R0, #+12]
     93                GPIOx->PM  |=  GPIO_InitStruct->GPIO_Pin;
   \   00000096   0269               LDR      R2,[R0, #+16]
   \   00000098   0B68               LDR      R3,[R1, #+0]
   \   0000009A   1343               ORRS     R3,R3,R2
   \   0000009C   0361               STR      R3,[R0, #+16]
   \   0000009E   5CE0               B        ??GPIO_Init_11
     94                break;
     95          
     96              case GPIO_Mode_IPU:
     97                GPIOx->PM  &= ~GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_5:
   \   000000A0   0269               LDR      R2,[R0, #+16]
   \   000000A2   0B68               LDR      R3,[R1, #+0]
   \   000000A4   9A43               BICS     R2,R2,R3
   \   000000A6   0261               STR      R2,[R0, #+16]
     98                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \   000000A8   0268               LDR      R2,[R0, #+0]
   \   000000AA   0B68               LDR      R3,[R1, #+0]
   \   000000AC   1343               ORRS     R3,R3,R2
   \   000000AE   0360               STR      R3,[R0, #+0]
     99                GPIOx->PC1 |=  GPIO_InitStruct->GPIO_Pin;
   \   000000B0   4268               LDR      R2,[R0, #+4]
   \   000000B2   0B68               LDR      R3,[R1, #+0]
   \   000000B4   1343               ORRS     R3,R3,R2
   \   000000B6   4360               STR      R3,[R0, #+4]
    100                GPIOx->PC2 &= ~GPIO_InitStruct->GPIO_Pin;
   \   000000B8   8268               LDR      R2,[R0, #+8]
   \   000000BA   0B68               LDR      R3,[R1, #+0]
   \   000000BC   9A43               BICS     R2,R2,R3
   \   000000BE   8260               STR      R2,[R0, #+8]
    101                GPIOx->PD  |=  GPIO_InitStruct->GPIO_Pin;
   \   000000C0   C268               LDR      R2,[R0, #+12]
   \   000000C2   0B68               LDR      R3,[R1, #+0]
   \   000000C4   1343               ORRS     R3,R3,R2
   \   000000C6   C360               STR      R3,[R0, #+12]
    102                GPIOx->PM  |=  GPIO_InitStruct->GPIO_Pin;
   \   000000C8   0269               LDR      R2,[R0, #+16]
   \   000000CA   0B68               LDR      R3,[R1, #+0]
   \   000000CC   1343               ORRS     R3,R3,R2
   \   000000CE   0361               STR      R3,[R0, #+16]
   \   000000D0   43E0               B        ??GPIO_Init_11
    103                break;
    104          
    105              case GPIO_Mode_Out_OD:
    106                GPIOx->PC0 &= ~GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_6:
   \   000000D2   0268               LDR      R2,[R0, #+0]
   \   000000D4   0B68               LDR      R3,[R1, #+0]
   \   000000D6   9A43               BICS     R2,R2,R3
   \   000000D8   0260               STR      R2,[R0, #+0]
    107                GPIOx->PC1 &= ~GPIO_InitStruct->GPIO_Pin;
   \   000000DA   4268               LDR      R2,[R0, #+4]
   \   000000DC   0B68               LDR      R3,[R1, #+0]
   \   000000DE   9A43               BICS     R2,R2,R3
   \   000000E0   4260               STR      R2,[R0, #+4]
    108                GPIOx->PC2 |=  GPIO_InitStruct->GPIO_Pin;
   \   000000E2   8268               LDR      R2,[R0, #+8]
   \   000000E4   0B68               LDR      R3,[R1, #+0]
   \   000000E6   1343               ORRS     R3,R3,R2
   \   000000E8   8360               STR      R3,[R0, #+8]
   \   000000EA   36E0               B        ??GPIO_Init_11
    109                break;
    110          
    111              case GPIO_Mode_Out_PP:
    112                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_7:
   \   000000EC   0268               LDR      R2,[R0, #+0]
   \   000000EE   0B68               LDR      R3,[R1, #+0]
   \   000000F0   1343               ORRS     R3,R3,R2
   \   000000F2   0360               STR      R3,[R0, #+0]
    113                GPIOx->PC1 &= ~GPIO_InitStruct->GPIO_Pin;
   \   000000F4   4268               LDR      R2,[R0, #+4]
   \   000000F6   0B68               LDR      R3,[R1, #+0]
   \   000000F8   9A43               BICS     R2,R2,R3
   \   000000FA   4260               STR      R2,[R0, #+4]
    114                GPIOx->PC2 |=  GPIO_InitStruct->GPIO_Pin;
   \   000000FC   8268               LDR      R2,[R0, #+8]
   \   000000FE   0B68               LDR      R3,[R1, #+0]
   \   00000100   1343               ORRS     R3,R3,R2
   \   00000102   8360               STR      R3,[R0, #+8]
   \   00000104   29E0               B        ??GPIO_Init_11
    115                break;
    116          
    117              case GPIO_Mode_AF_OD:
    118                GPIOx->PD  |=  GPIO_InitStruct->GPIO_Pin;          
   \                     ??GPIO_Init_8:
   \   00000106   C268               LDR      R2,[R0, #+12]
   \   00000108   0B68               LDR      R3,[R1, #+0]
   \   0000010A   1343               ORRS     R3,R3,R2
   \   0000010C   C360               STR      R3,[R0, #+12]
    119                GPIOx->PC1 |=  GPIO_InitStruct->GPIO_Pin;
   \   0000010E   4268               LDR      R2,[R0, #+4]
   \   00000110   0B68               LDR      R3,[R1, #+0]
   \   00000112   1343               ORRS     R3,R3,R2
   \   00000114   4360               STR      R3,[R0, #+4]
    120                GPIOx->PC0 &= ~GPIO_InitStruct->GPIO_Pin;
   \   00000116   0268               LDR      R2,[R0, #+0]
   \   00000118   0B68               LDR      R3,[R1, #+0]
   \   0000011A   9A43               BICS     R2,R2,R3
   \   0000011C   0260               STR      R2,[R0, #+0]
    121                GPIOx->PC2 |=  GPIO_InitStruct->GPIO_Pin;
   \   0000011E   8268               LDR      R2,[R0, #+8]
   \   00000120   0B68               LDR      R3,[R1, #+0]
   \   00000122   1343               ORRS     R3,R3,R2
   \   00000124   8360               STR      R3,[R0, #+8]
   \   00000126   18E0               B        ??GPIO_Init_11
    122                break;
    123          
    124              case GPIO_Mode_AF_PP:
    125                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_9:
   \   00000128   0268               LDR      R2,[R0, #+0]
   \   0000012A   0B68               LDR      R3,[R1, #+0]
   \   0000012C   1343               ORRS     R3,R3,R2
   \   0000012E   0360               STR      R3,[R0, #+0]
    126                GPIOx->PC1 |=  GPIO_InitStruct->GPIO_Pin;
   \   00000130   4268               LDR      R2,[R0, #+4]
   \   00000132   0B68               LDR      R3,[R1, #+0]
   \   00000134   1343               ORRS     R3,R3,R2
   \   00000136   4360               STR      R3,[R0, #+4]
    127                GPIOx->PC2 |=  GPIO_InitStruct->GPIO_Pin;
   \   00000138   8268               LDR      R2,[R0, #+8]
   \   0000013A   0B68               LDR      R3,[R1, #+0]
   \   0000013C   1343               ORRS     R3,R3,R2
   \   0000013E   8360               STR      R3,[R0, #+8]
   \   00000140   0BE0               B        ??GPIO_Init_11
    128                break;
    129          
    130              default :
    131                GPIOx->PC0 |=  GPIO_InitStruct->GPIO_Pin;
   \                     ??GPIO_Init_10:
   \   00000142   0268               LDR      R2,[R0, #+0]
   \   00000144   0B68               LDR      R3,[R1, #+0]
   \   00000146   1343               ORRS     R3,R3,R2
   \   00000148   0360               STR      R3,[R0, #+0]
    132                GPIOx->PC1 &= ~GPIO_InitStruct->GPIO_Pin;
   \   0000014A   4268               LDR      R2,[R0, #+4]
   \   0000014C   0B68               LDR      R3,[R1, #+0]
   \   0000014E   9A43               BICS     R2,R2,R3
   \   00000150   4260               STR      R2,[R0, #+4]
    133                GPIOx->PC2 &= ~GPIO_InitStruct->GPIO_Pin;
   \   00000152   8268               LDR      R2,[R0, #+8]
   \   00000154   0B68               LDR      R3,[R1, #+0]
   \   00000156   9A43               BICS     R2,R2,R3
   \   00000158   8260               STR      R2,[R0, #+8]
    134                break;
    135            }
    136          }
   \                     ??GPIO_Init_11:
   \   0000015A   08BC               POP      {R3}
   \   0000015C   01BC               POP      {R0}
   \   0000015E   0047               BX       R0               ;; return
   \                     ??GPIO_Init_0:
   \   00000160   00E4FFFF           DC32     0xffffe400
   \   00000164   FFFF0F00           DC32     0xfffff
    137          
    138          /*******************************************************************************
    139          * Function Name  : GPIO_StructInit
    140          * Description    : Fills each GPIO_InitStruct member with its default value.
    141          * Input          : GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
    142          *                  which will be initialized.
    143          * Output         : None
    144          * Return         : None
    145          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    146          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    147          {
    148            /* Reset GPIO init structure parameters values */
    149            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   C943               MVNS     R1,R1            ;; #-1
   \   00000004   0160               STR      R1,[R0, #+0]
    150            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000006   0221               MOVS     R1,#+2
   \   00000008   0171               STRB     R1,[R0, #+4]
    151          }
   \   0000000A   7047               BX       LR               ;; return
    152          
    153          /*******************************************************************************
    154          * Function Name  : GPIO_Read
    155          * Description    : Reads the specified GPIO data port.
    156          * Input          : GPIOx: where x can be 0,1 or 2 to select the GPIO peripheral.
    157          * Output         : None
    158          * Return         : GPIO data port word value.
    159          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    160          u32 GPIO_Read(GPIO_TypeDef* GPIOx)
    161          {
    162            return GPIOx->PD;
   \                     GPIO_Read:
   \   00000000   C068               LDR      R0,[R0, #+12]
   \   00000002   7047               BX       LR               ;; return
    163          }
    164          
    165          /*******************************************************************************
    166          * Function Name  : GPIO_ReadBit
    167          * Description    : Reads the specified data port bit.
    168          * Input          : - GPIOx: where x can be (0..2) to select the GPIO peripheral.
    169          *                : - GPIO_Pin:  specifies the port bit to read.
    170          *                    This parameter can be GPIO_Pin_x where x can be (0..31) for
    171          *                    GPIO0 and x(0..19) for GPIO1 and GPIO2.
    172          * Output         : None
    173          * Return         : The port pin value
    174          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    175          u8 GPIO_ReadBit(GPIO_TypeDef* GPIOx, u32 GPIO_Pin)
    176          {
   \                     GPIO_ReadBit:
   \   00000000   0200               MOVS     R2,R0
    177            if ((GPIOx->PD & GPIO_Pin) != Bit_RESET)
   \   00000002   D068               LDR      R0,[R2, #+12]
   \   00000004   0840               ANDS     R0,R0,R1
   \   00000006   401E               SUBS     R0,R0,#+1
   \   00000008   8041               SBCS     R0,R0,R0
   \   0000000A   C043               MVNS     R0,R0
   \   0000000C   C00F               LSRS     R0,R0,#+31
   \   0000000E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000010   000E               LSRS     R0,R0,#+24
    178            {
    179              return Bit_SET;
    180            }
    181            else
    182            {
    183              return Bit_RESET;
   \   00000012   7047               BX       LR               ;; return
    184            }
    185          }
    186          
    187          /*******************************************************************************
    188          * Function Name  : GPIO_Write
    189          * Description    : Writes data to the specified GPIO data port.
    190          * Input          :- GPIOx: where x can be 0,1 or 2 to select the GPIO peripheral.
    191          *                 - PortVal: specifies the value to be written to the data port
    192          *                   register.
    193          * Output         : None
    194          * Return         : None
    195          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    196          void GPIO_Write(GPIO_TypeDef* GPIOx, u32 PortVal)
    197          {
    198            GPIOx->PD = PortVal;
   \                     GPIO_Write:
   \   00000000   C160               STR      R1,[R0, #+12]
    199          }
   \   00000002   7047               BX       LR               ;; return
    200          
    201          /*******************************************************************************
    202          * Function Name  : GPIO_WriteBit
    203          * Description    : Sets or clears the selected data port bit.
    204          * Input          : - GPIOx: where x can be (0..2) to select the GPIO peripheral.
    205          *                  - GPIO_Pin: specifies the port bit to be written.
    206          *                    This parameter can be GPIO_Pin_x where x can be (0..31) for
    207          *                    GPIO0 and x(0..19) for GPIO1 and GPIO2.
    208          *                  - BitVal: specifies the value to be written to the selected bit.
    209          *                    This parameter must be one of the BitAction enum values:
    210          *                       - Bit_RESET: to clear the port pin
    211          *                       - Bit_SET: to set the port pin
    212          * Output         : None
    213          * Return         : None
    214          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    215          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u32 GPIO_Pin, BitAction BitVal)
    216          {
   \                     GPIO_WriteBit:
   \   00000000   01B5               PUSH     {R0,LR}
    217            if(BitVal != Bit_RESET)
   \   00000002   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000004   120E               LSRS     R2,R2,#+24
   \   00000006   002A               CMP      R2,#+0
   \   00000008   03D0               BEQ      ??GPIO_WriteBit_0
    218            {
    219              GPIOx->PD |= GPIO_Pin;
   \   0000000A   C368               LDR      R3,[R0, #+12]
   \   0000000C   0B43               ORRS     R3,R3,R1
   \   0000000E   C360               STR      R3,[R0, #+12]
   \   00000010   02E0               B        ??GPIO_WriteBit_1
    220            }
    221            else
    222            {
    223              GPIOx->PD &= ~GPIO_Pin;
   \                     ??GPIO_WriteBit_0:
   \   00000012   C368               LDR      R3,[R0, #+12]
   \   00000014   8B43               BICS     R3,R3,R1
   \   00000016   C360               STR      R3,[R0, #+12]
    224            }
    225          }
   \                     ??GPIO_WriteBit_1:
   \   00000018   08BC               POP      {R3}
   \   0000001A   01BC               POP      {R0}
   \   0000001C   0047               BX       R0               ;; return
    226          
    227          /*******************************************************************************
    228          * Function Name  : GPIO_PinMaskConfig
    229          * Description    : Enables or disables write protection to the selected bits in
    230          *                  the I/O port registers (PxC2, PxC1, PxC0 and PxD).
    231          * Input          :- GPIOx: where x can be 0,1 or 2 to select the GPIO peripheral.
    232          *                 - GPIO_Pin: specifies the port bit to be protected.
    233          *                   This parameter can be GPIO_Pin_x where x can be (0..31) for
    234          *                   GPIO0 and x(0..19) for GPIO1 and GPIO2.
    235          *                 - NewState: new state of the port pin.
    236          *                   This parameter can be: ENABLE or DISABLE.
    237          * Output         : None
    238          * Return         : None
    239          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    240          void GPIO_PinMaskConfig(GPIO_TypeDef* GPIOx, u32 GPIO_Pin, FunctionalState NewState)
    241          {
   \                     GPIO_PinMaskConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    242            if(NewState == ENABLE)
   \   00000002   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000004   120E               LSRS     R2,R2,#+24
   \   00000006   012A               CMP      R2,#+1
   \   00000008   03D1               BNE      ??GPIO_PinMaskConfig_0
    243            {
    244              GPIOx->PM |= GPIO_Pin;
   \   0000000A   0369               LDR      R3,[R0, #+16]
   \   0000000C   0B43               ORRS     R3,R3,R1
   \   0000000E   0361               STR      R3,[R0, #+16]
   \   00000010   02E0               B        ??GPIO_PinMaskConfig_1
    245            }
    246            else
    247            {
    248              GPIOx->PM &= ~GPIO_Pin;
   \                     ??GPIO_PinMaskConfig_0:
   \   00000012   0369               LDR      R3,[R0, #+16]
   \   00000014   8B43               BICS     R3,R3,R1
   \   00000016   0361               STR      R3,[R0, #+16]
    249            }
    250          }
   \                     ??GPIO_PinMaskConfig_1:
   \   00000018   08BC               POP      {R3}
   \   0000001A   01BC               POP      {R0}
   \   0000001C   0047               BX       R0               ;; return
    251          
    252          /*******************************************************************************
    253          * Function Name  : GPIO_GetPortMask
    254          * Description    : Gets the GPIOx port mask value.
    255          * Input          : GPIOx: where x can be 0,1 or 2 to select the GPIO peripheral.
    256          * Output         : None
    257          * Return         : GPIO port mask value.
    258          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    259          u32 GPIO_GetPortMask(GPIO_TypeDef* GPIOx)
    260          {
    261            return GPIOx->PM;
   \                     GPIO_GetPortMask:
   \   00000000   0069               LDR      R0,[R0, #+16]
   \   00000002   7047               BX       LR               ;; return
    262          }
    263          
    264          /*******************************************************************************
    265          * Function Name  : GPIO_PinRemapConfig
    266          * Description    : Changes the mapping of the specified pin.
    267          * Input          :- GPIO_Remap: selects the pin to remap.
    268          *                   This parameter can be one of the following values:
    269          *                     - GPIO_Remap_SMI_CS3_EN: Enable SMI CS3 
    270          *                     - GPIO_Remap_SMI_CS2_EN: Enable SMI CS2
    271          *                     - GPIO_Remap_SMI_CS1_EN: Enable SMI CS1
    272          *                     - GPIO_Remap_SMI_EN: Enable SMI Alternate Functions: 
    273          *                       SMI_CS0, SMI_CK, SMI_DIN and SMI_DOUT
    274          *                     - GPIO_Remap_DBGOFF: JTAG Disable
    275          *                     - GPIO_Remap_UART1: UART1 Alternate Function mapping
    276          *                     - GPIO_Remap_UART2: UART2 Alternate Function mapping
    277          *                     - GPIO_Remap_SSP1: SSP1 Alternate Function mapping
    278          *                     - GPIO_Remap_TIM2: TIM2 Alternate Function mapping
    279          *                     - GPIO_Remap_TIM0: TIM0 Alternate Function mapping
    280          *                 - NewState: new state of the port pin.
    281          *                   This parameter can be: ENABLE or DISABLE.
    282          * Output         : None
    283          * Return         : None
    284          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    285          void GPIO_PinRemapConfig(u16 GPIO_Remap, FunctionalState NewState)
    286          {
   \                     GPIO_PinRemapConfig:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    287            u32 GPIOReg = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   2200               MOVS     R2,R4
    288            u32 PinPos = 0;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   2300               MOVS     R3,R4
    289          
    290            /* Get the GPIO register index */
    291            GPIOReg = GPIO_Remap >> 5;
   \   0000000A   0400               MOVS     R4,R0
   \   0000000C   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   0000000E   240C               LSRS     R4,R4,#+16
   \   00000010   6409               LSRS     R4,R4,#+5
   \   00000012   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000014   240C               LSRS     R4,R4,#+16
   \   00000016   2200               MOVS     R2,R4
    292          
    293            /* Get the pin position */
    294            PinPos = GPIO_Remap & GPIO_Remap_Mask;
   \   00000018   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000001A   000C               LSRS     R0,R0,#+16
   \   0000001C   C406               LSLS     R4,R0,#+27       ;; ZeroExtS R4,R0,#+27,#+27
   \   0000001E   E40E               LSRS     R4,R4,#+27
   \   00000020   2300               MOVS     R3,R4
    295          
    296            if(GPIOReg == 1) /* The pin to remap is in REMAP0R register */
   \   00000022   012A               CMP      R2,#+1
   \   00000024   13D1               BNE      ??GPIO_PinRemapConfig_0
    297            {
    298              if(NewState == ENABLE)
   \   00000026   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000028   090E               LSRS     R1,R1,#+24
   \   0000002A   0129               CMP      R1,#+1
   \   0000002C   07D1               BNE      ??GPIO_PinRemapConfig_1
    299              {
    300                GPIOREMAP->REMAP0R |= (1 << PinPos);
   \   0000002E   144C               LDR      R4,??GPIO_PinRemapConfig_2  ;; 0xffffe420
   \   00000030   2468               LDR      R4,[R4, #+0]
   \   00000032   0125               MOVS     R5,#+1
   \   00000034   9D40               LSLS     R5,R5,R3
   \   00000036   2543               ORRS     R5,R5,R4
   \   00000038   114C               LDR      R4,??GPIO_PinRemapConfig_2  ;; 0xffffe420
   \   0000003A   2560               STR      R5,[R4, #+0]
   \   0000003C   1CE0               B        ??GPIO_PinRemapConfig_3
    301              }
    302              else
    303              {
    304                GPIOREMAP->REMAP0R &= ~(1 << PinPos);
   \                     ??GPIO_PinRemapConfig_1:
   \   0000003E   104C               LDR      R4,??GPIO_PinRemapConfig_2  ;; 0xffffe420
   \   00000040   2468               LDR      R4,[R4, #+0]
   \   00000042   0125               MOVS     R5,#+1
   \   00000044   9D40               LSLS     R5,R5,R3
   \   00000046   AC43               BICS     R4,R4,R5
   \   00000048   0D4D               LDR      R5,??GPIO_PinRemapConfig_2  ;; 0xffffe420
   \   0000004A   2C60               STR      R4,[R5, #+0]
   \   0000004C   14E0               B        ??GPIO_PinRemapConfig_3
    305              }
    306            }
    307            else if(GPIOReg == 2) /* The pin to remap is in REMAP1R register */
   \                     ??GPIO_PinRemapConfig_0:
   \   0000004E   022A               CMP      R2,#+2
   \   00000050   12D1               BNE      ??GPIO_PinRemapConfig_3
    308            {
    309              if(NewState == ENABLE)
   \   00000052   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000054   090E               LSRS     R1,R1,#+24
   \   00000056   0129               CMP      R1,#+1
   \   00000058   07D1               BNE      ??GPIO_PinRemapConfig_4
    310              {
    311                GPIOREMAP->REMAP1R |= (1 << PinPos);
   \   0000005A   0A4C               LDR      R4,??GPIO_PinRemapConfig_2+0x4  ;; 0xffffe424
   \   0000005C   2468               LDR      R4,[R4, #+0]
   \   0000005E   0125               MOVS     R5,#+1
   \   00000060   9D40               LSLS     R5,R5,R3
   \   00000062   2543               ORRS     R5,R5,R4
   \   00000064   074C               LDR      R4,??GPIO_PinRemapConfig_2+0x4  ;; 0xffffe424
   \   00000066   2560               STR      R5,[R4, #+0]
   \   00000068   06E0               B        ??GPIO_PinRemapConfig_3
    312              }
    313              else
    314              {
    315                GPIOREMAP->REMAP1R &= ~(1 << PinPos);
   \                     ??GPIO_PinRemapConfig_4:
   \   0000006A   064C               LDR      R4,??GPIO_PinRemapConfig_2+0x4  ;; 0xffffe424
   \   0000006C   2468               LDR      R4,[R4, #+0]
   \   0000006E   0125               MOVS     R5,#+1
   \   00000070   9D40               LSLS     R5,R5,R3
   \   00000072   AC43               BICS     R4,R4,R5
   \   00000074   034D               LDR      R5,??GPIO_PinRemapConfig_2+0x4  ;; 0xffffe424
   \   00000076   2C60               STR      R4,[R5, #+0]
    316              }
    317            }
    318          }
   \                     ??GPIO_PinRemapConfig_3:
   \   00000078   38BC               POP      {R3-R5}
   \   0000007A   01BC               POP      {R0}
   \   0000007C   0047               BX       R0               ;; return
   \   0000007E   C046               Nop      
   \                     ??GPIO_PinRemapConfig_2:
   \   00000080   20E4FFFF           DC32     0xffffe420
   \   00000084   24E4FFFF           DC32     0xffffe424
    319          
    320          /******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function            .cstack
     --------            -------
     GPIO_DeInit              0
     GPIO_GetPortMask         0
     GPIO_Init                8
     GPIO_PinMaskConfig       8
     GPIO_PinRemapConfig     16
     GPIO_Read                0
     GPIO_ReadBit             0
     GPIO_StructInit          0
     GPIO_Write               0
     GPIO_WriteBit            8


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     GPIO_DeInit           20
     GPIO_Init            360
     GPIO_StructInit       12
     GPIO_Read              4
     GPIO_ReadBit          20
     GPIO_Write             4
     GPIO_WriteBit         30
     GPIO_PinMaskConfig    30
     GPIO_GetPortMask       4
     GPIO_PinRemapConfig  136

 
 620 bytes in section .text
 
 620 bytes of CODE memory

Errors: none
Warnings: none
