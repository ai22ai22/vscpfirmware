###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:43 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\development\vscp\firmware\common\vscp_serial.c        #
#    Command line =  D:\development\vscp\firmware\common\vscp_serial.c -lC    #
#                    D:\development\gediminas\CAN4USB\project\RELEASE\List\   #
#                    -lA D:\development\gediminas\CAN4USB\project\RELEASE\Lis #
#                    t\ -o D:\development\gediminas\CAN4USB\project\RELEASE\O #
#                    bj\ --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian little --cpu ARM7TDMI-S -e --fpu None           #
#                    --dlib_config "D:\Program\IAR Systems\Embedded           #
#                    Workbench 5.0\ARM\INC\DLib_Config_Normal.h" -I           #
#                    D:\development\gediminas\CAN4USB\project\ -I             #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\vs #
#                    cp_serial.lst                                            #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\vsc #
#                    p_serial.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\development\vscp\firmware\common\vscp_serial.c
      1           /**
      2           * @brief           VSCP Serial Protocol
      3           * @file            vscp_serial.c
      4           * @author          Ake Hedman, D of Scandinavia, www.vscp.org
      5           *
      6           * @section description Description
      7           **********************************
      8           * This module contains the code that implements the
      9           * VSCP serial protocol.
     10           *********************************************************************/
     11          
     12          /* ******************************************************************************
     13           * VSCP (Very Simple Control Protocol) 
     14           * http://www.vscp.org
     15           *
     16           * Copyright (C) 1995-2008 Ake Hedman, 
     17           * D of Scandinavia, <akhe@dofscandinavia.com>
     18           *
     19           * This software is provided 'as-is', without any express or implied
     20           * warranty.  In no event will the authors be held liable for any damages
     21           * arising from the use of this software.
     22           *
     23           * Permission is granted to anyone to use this software for any purpose,
     24           * including commercial applications, and to alter it and redistribute it
     25           * freely, subject to the following restrictions:
     26           *
     27           * 1. The origin of this software must not be misrepresented; you must not
     28           *    claim that you wrote the original software. If you use this software
     29           *    in a product, an acknowledgment in the product documentation would be
     30           *    appreciated but is not required.
     31           * 2. Altered source versions must be plainly marked as such, and must not be
     32           *    misrepresented as being the original software.
     33           * 3. This notice may not be removed or altered from any source distribution.
     34           * 
     35           *  This file is part of VSCP - Very Simple Control Protocol 	
     36           *  http://www.vscp.org
     37           *
     38           * ******************************************************************************
     39          */
     40          
     41          #include <stdio.h>
     42          #include <string.h>

   \                                 In section .text, align 4
   \   __??Code16?? __intrinsic __code __interwork void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
   \   00000008   3200               MOVS     R2,R6
   \   0000000A   2900               MOVS     R1,R5
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       __aeabi_memcpy
   \   00000012   2000               MOVS     R0,R4
   \   00000014   70BC               POP      {R4-R6}
   \   00000016   02BC               POP      {R1}
   \   00000018   0847               BX       R1               ;; return
     43          #include "vscp.h"
     44          #include "vscp_projdefs.h"
     45          #include "vscp_serial.h"
     46          #include "crc.h"
     47          
     48          // Globals

   \                                 In section .bss, align 1
     49          uint8_t vs_main_state;     // state for the state machine
   \                     vs_main_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     50          uint8_t vs_sub_state;      // substate for the state machine
   \                     vs_sub_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     51          uint8_t vs_msgbuffer[ VSCP_SERIAL_BUFFER_SIZE ];  // Buffer for current event 
   \                     vs_msgbuffer:
   \   00000000                      DS8 48

   \                                 In section .bss, align 1
     52          uint8_t vs_buffer_cnt;     // Character count for buffer
   \                     vs_buffer_cnt:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     53          uint8_t vs_checksum;       // Packet checksum
   \                     vs_checksum:
   \   00000000                      DS8 1
     54          
     55          #ifdef VSCP_SERIAL_ENABLE_SLIDING_WINDOWS 
     56          
     57          // Flying windows frames

   \                                 In section .bss, align 1
     58          uint8_t vs_cntSlidingWndFrames;   // Number of outstanding sliding window frames
   \                     vs_cntSlidingWndFrames:
   \   00000000                      DS8 1
     59          
     60          // Array with info about outstanding flying window frames 
     61          //vscp_serial_SlidingWndStruct slidingWndFrames[ VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES ];   
     62          
     63          #endif
     64          
     65          
     66          
     67          ///////////////////////////////////////////////////////////////////////////////
     68          // vs_sendchar_subst
     69          //
     70          

   \                                 In section .text, align 4, keep-with-next
     71          void vs_bufferSerialByte( uint8_t b )
     72          {
   \                     vs_bufferSerialByte:
   \   00000000   01B5               PUSH     {R0,LR}
     73            if ( vs_buffer_cnt >= VSCP_SERIAL_BUFFER_SIZE ) return;
   \   00000002   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   00000004   0978               LDRB     R1,[R1, #+0]
   \   00000006   2E29               CMP      R1,#+46
   \   00000008   08D2               BCS      ??vs_bufferSerialByte_0
     74            vs_msgbuffer[ vs_buffer_cnt++ ] = b;
   \   0000000A   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   0000000C   0978               LDRB     R1,[R1, #+0]
   \   0000000E   ....               LDR      R2,??DataTable53  ;; vs_msgbuffer
   \   00000010   5054               STRB     R0,[R2, R1]
   \   00000012   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   00000014   0978               LDRB     R1,[R1, #+0]
   \   00000016   491C               ADDS     R1,R1,#+1
   \   00000018   ....               LDR      R2,??DataTable50  ;; vs_buffer_cnt
   \   0000001A   1170               STRB     R1,[R2, #+0]
     75          }
   \                     ??vs_bufferSerialByte_0:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
     76          
     77          
     78          ///////////////////////////////////////////////////////////////////////////////
     79          // vs_sendchar_subst
     80          //
     81          

   \                                 In section .text, align 4, keep-with-next
     82          BOOL vs_bufferSerialByteSubst( uint8_t *pcsum, uint8_t b )
     83          {
   \                     vs_bufferSerialByteSubst:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
     84            if ( DLE == b ) {
   \   00000006   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000008   2D0E               LSRS     R5,R5,#+24
   \   0000000A   102D               CMP      R5,#+16
   \   0000000C   0AD1               BNE      ??vs_bufferSerialByteSubst_0
     85              vs_bufferSerialByte( DLE );
   \   0000000E   1020               MOVS     R0,#+16
   \   00000010   ........           BL       vs_bufferSerialByte
     86              vs_bufferSerialByte( DLE );
   \   00000014   1020               MOVS     R0,#+16
   \   00000016   ........           BL       vs_bufferSerialByte
     87              *pcsum ^= DLE; // Only one is used for checksum calculations
   \   0000001A   2078               LDRB     R0,[R4, #+0]
   \   0000001C   1021               MOVS     R1,#+16
   \   0000001E   4140               EORS     R1,R1,R0
   \   00000020   2170               STRB     R1,[R4, #+0]
   \   00000022   07E0               B        ??vs_bufferSerialByteSubst_1
     88            }
     89            else {
     90              vs_bufferSerialByte( b );	
   \                     ??vs_bufferSerialByteSubst_0:
   \   00000024   2800               MOVS     R0,R5
   \   00000026   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000028   000E               LSRS     R0,R0,#+24
   \   0000002A   ........           BL       vs_bufferSerialByte
     91              *pcsum ^= b;
   \   0000002E   2078               LDRB     R0,[R4, #+0]
   \   00000030   6840               EORS     R0,R0,R5
   \   00000032   2070               STRB     R0,[R4, #+0]
     92            }
     93            
     94            return TRUE;
   \                     ??vs_bufferSerialByteSubst_1:
   \   00000034   0120               MOVS     R0,#+1
   \   00000036   38BC               POP      {R3-R5}
   \   00000038   02BC               POP      {R1}
   \   0000003A   0847               BX       R1               ;; return
     95          }
     96          
     97          
     98          ///////////////////////////////////////////////////////////////////////////////
     99          // vscp_serial_init
    100          //
    101          

   \                                 In section .text, align 4, keep-with-next
    102          void vs_init( void ) 
    103          {
    104             vs_main_state = VSCP_SERIAL_PROTOCOL_STATE_NONE;
   \                     vs_init:
   \   00000000   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0170               STRB     R1,[R0, #+0]
    105             vs_sub_state = VSCP_SERIAL_PROTOCOL_SUBSTATE_NONE; 
   \   00000006   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0170               STRB     R1,[R0, #+0]
    106             vs_buffer_cnt = 0;
   \   0000000C   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0170               STRB     R1,[R0, #+0]
    107             vs_checksum = 0;
   \   00000012   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0170               STRB     R1,[R0, #+0]
    108          }
   \   00000018   7047               BX       LR               ;; return
    109          
    110          ///////////////////////////////////////////////////////////////////////////////
    111          // vscp_serial_feed
    112          //
    113          

   \                                 In section .text, align 4, keep-with-next
    114          BOOL vs_feed( uint8_t b )
    115          {
   \                     vs_feed:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    116            BOOL rv = FALSE;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0500               MOVS     R5,R0
    117            
    118            switch ( b ) {
   \   00000008   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000000A   240E               LSRS     R4,R4,#+24
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   2BD0               BEQ      ??vs_feed_0
   \   00000012   401E               SUBS     R0,R0,#+1
   \   00000014   55D0               BEQ      ??vs_feed_1
   \   00000016   0E38               SUBS     R0,R0,#+14
   \   00000018   77D1               BNE      ??vs_feed_2
    119            
    120              case DLE: // escape
    121                if ( VSCP_SERIAL_PROTOCOL_STATE_NONE == vs_main_state ) {
   \                     ??vs_feed_3:
   \   0000001A   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   03D1               BNE      ??vs_feed_4
    122                  vs_sub_state = VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE;  
   \   00000022   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000024   0121               MOVS     R1,#+1
   \   00000026   0170               STRB     R1,[R0, #+0]
   \   00000028   81E0               B        ??vs_feed_5
    123                }
    124                else if ( VSCP_SERIAL_PROTOCOL_STATE_PACKET == vs_main_state ) {
   \                     ??vs_feed_4:
   \   0000002A   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   0128               CMP      R0,#+1
   \   00000030   7DD1               BNE      ??vs_feed_5
    125                  
    126                  if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE == vs_sub_state ) {
   \   00000032   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000034   0078               LDRB     R0,[R0, #+0]
   \   00000036   0128               CMP      R0,#+1
   \   00000038   13D1               BNE      ??vs_feed_6
    127                    // Second DLE => it's a DLE character
    128                    vs_checksum ^= DLE;
   \   0000003A   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   0000003C   0078               LDRB     R0,[R0, #+0]
   \   0000003E   1021               MOVS     R1,#+16
   \   00000040   4140               EORS     R1,R1,R0
   \   00000042   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   00000044   0170               STRB     R1,[R0, #+0]
    129                    vs_msgbuffer[ vs_buffer_cnt++ ] = DLE;
   \   00000046   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   00000048   0078               LDRB     R0,[R0, #+0]
   \   0000004A   ....               LDR      R1,??DataTable53  ;; vs_msgbuffer
   \   0000004C   1022               MOVS     R2,#+16
   \   0000004E   0A54               STRB     R2,[R1, R0]
   \   00000050   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   00000052   0078               LDRB     R0,[R0, #+0]
   \   00000054   401C               ADDS     R0,R0,#+1
   \   00000056   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   00000058   0870               STRB     R0,[R1, #+0]
    130                    vs_sub_state = VSCP_SERIAL_PROTOCOL_SUBSTATE_NONE; 
   \   0000005A   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0170               STRB     R1,[R0, #+0]
   \   00000060   65E0               B        ??vs_feed_5
    131                  }
    132                  else {
    133                    vs_sub_state = VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE;
   \                     ??vs_feed_6:
   \   00000062   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   0170               STRB     R1,[R0, #+0]
   \   00000068   61E0               B        ??vs_feed_5
    134                  }
    135                  
    136                }
    137                break;
    138               
    139              case STX: // start
    140                if ( VSCP_SERIAL_PROTOCOL_STATE_NONE == vs_main_state ) {
   \                     ??vs_feed_0:
   \   0000006A   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   0000006C   0078               LDRB     R0,[R0, #+0]
   \   0000006E   0028               CMP      R0,#+0
   \   00000070   09D1               BNE      ??vs_feed_7
    141                  
    142                  if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE == vs_sub_state ) {
   \   00000072   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000074   0078               LDRB     R0,[R0, #+0]
   \   00000076   0128               CMP      R0,#+1
   \   00000078   59D1               BNE      ??vs_feed_5
    143                    // Here if waiting for packet and escape has been received.
    144                    // Start to receive a package    
    145                    vs_init();
   \   0000007A   ........           BL       vs_init
    146                    vs_main_state = VSCP_SERIAL_PROTOCOL_STATE_PACKET; 
   \   0000007E   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   0170               STRB     R1,[R0, #+0]
   \   00000084   53E0               B        ??vs_feed_5
    147                  }
    148                  
    149                }
    150                else if ( VSCP_SERIAL_PROTOCOL_STATE_PACKET == vs_main_state ) {
   \                     ??vs_feed_7:
   \   00000086   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   00000088   0078               LDRB     R0,[R0, #+0]
   \   0000008A   0128               CMP      R0,#+1
   \   0000008C   4FD1               BNE      ??vs_feed_5
    151                  
    152                  if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE == vs_sub_state ) {
   \   0000008E   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   0128               CMP      R0,#+1
   \   00000094   02D1               BNE      ??vs_feed_8
    153                    // DLE STX in package - Start all over
    154                    vs_init();
   \   00000096   ........           BL       vs_init
   \   0000009A   48E0               B        ??vs_feed_5
    155                  }
    156                  else if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_NONE == vs_sub_state ) {
   \                     ??vs_feed_8:
   \   0000009C   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   0000009E   0078               LDRB     R0,[R0, #+0]
   \   000000A0   0028               CMP      R0,#+0
   \   000000A2   44D1               BNE      ??vs_feed_5
    157                    // Just a stray STX
    158                    vs_checksum ^= b;
   \   000000A4   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   000000A6   0078               LDRB     R0,[R0, #+0]
   \   000000A8   6040               EORS     R0,R0,R4
   \   000000AA   ....               LDR      R1,??DataTable45  ;; vs_checksum
   \   000000AC   0870               STRB     R0,[R1, #+0]
    159                    vs_msgbuffer[ vs_buffer_cnt++ ] = b; 
   \   000000AE   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   000000B0   0078               LDRB     R0,[R0, #+0]
   \   000000B2   ....               LDR      R1,??DataTable53  ;; vs_msgbuffer
   \   000000B4   0C54               STRB     R4,[R1, R0]
   \   000000B6   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   000000B8   0078               LDRB     R0,[R0, #+0]
   \   000000BA   401C               ADDS     R0,R0,#+1
   \   000000BC   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   000000BE   0870               STRB     R0,[R1, #+0]
   \   000000C0   35E0               B        ??vs_feed_5
    160                  }
    161                  
    162                }
    163                break;
    164                
    165              case ETX: // End
    166                if ( VSCP_SERIAL_PROTOCOL_STATE_PACKET == vs_main_state ) {
   \                     ??vs_feed_1:
   \   000000C2   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   000000C4   0078               LDRB     R0,[R0, #+0]
   \   000000C6   0128               CMP      R0,#+1
   \   000000C8   31D1               BNE      ??vs_feed_5
    167                  
    168                  if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_ESCAPE == vs_sub_state ) {
   \   000000CA   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   000000CC   0078               LDRB     R0,[R0, #+0]
   \   000000CE   0128               CMP      R0,#+1
   \   000000D0   08D1               BNE      ??vs_feed_9
    169                    
    170                    // DLE ETX in package - We have received a packet
    171                    // Check the packet checksum and return OK
    172                    
    173                  if ( 0 == vs_checksum ) {
   \   000000D2   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   000000D4   0078               LDRB     R0,[R0, #+0]
   \   000000D6   0028               CMP      R0,#+0
   \   000000D8   01D1               BNE      ??vs_feed_10
    174                      rv = TRUE;
   \   000000DA   0120               MOVS     R0,#+1
   \   000000DC   0500               MOVS     R5,R0
    175                      // Ack the frame
    176                      if (  ( VSCP_SERIAL_OPCODE_ACK != vs_msgbuffer[ 0 ] ) && 
    177                          ( VSCP_SERIAL_OPCODE_SENT_ACK != vs_msgbuffer[ 0 ] ) ) {
    178          							//vs_sendAck( vs_msgbuffer[ 2 ], vs_msgbuffer[ 3 ] );
    179                      }
    180                    }
    181                    else {
    182                      // Nack the frame
    183                      if (  ( VSCP_SERIAL_OPCODE_NACK != vs_msgbuffer[ 0 ] ) && 
    184                          ( VSCP_SERIAL_OPCODE_SENT_NACK != vs_msgbuffer[ 0 ] ) ) {
    185          							//vs_sendNack( vs_msgbuffer[ 2 ], vs_msgbuffer[ 3 ] );
    186                      }
    187                    }
    188                  
    189                    vs_init();
   \                     ??vs_feed_10:
   \   000000DE   ........           BL       vs_init
   \   000000E2   24E0               B        ??vs_feed_5
    190                    
    191                  }
    192                  else if ( VSCP_SERIAL_PROTOCOL_SUBSTATE_NONE == vs_sub_state ) {
   \                     ??vs_feed_9:
   \   000000E4   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   000000E6   0078               LDRB     R0,[R0, #+0]
   \   000000E8   0028               CMP      R0,#+0
   \   000000EA   20D1               BNE      ??vs_feed_5
    193                    // Just a stray ETX
    194                    vs_checksum ^= b;
   \   000000EC   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   000000EE   0078               LDRB     R0,[R0, #+0]
   \   000000F0   6040               EORS     R0,R0,R4
   \   000000F2   ....               LDR      R1,??DataTable45  ;; vs_checksum
   \   000000F4   0870               STRB     R0,[R1, #+0]
    195                    vs_msgbuffer[ vs_buffer_cnt++ ] = b; 
   \   000000F6   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   000000F8   0078               LDRB     R0,[R0, #+0]
   \   000000FA   ....               LDR      R1,??DataTable53  ;; vs_msgbuffer
   \   000000FC   0C54               STRB     R4,[R1, R0]
   \   000000FE   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   00000100   0078               LDRB     R0,[R0, #+0]
   \   00000102   401C               ADDS     R0,R0,#+1
   \   00000104   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   00000106   0870               STRB     R0,[R1, #+0]
   \   00000108   11E0               B        ??vs_feed_5
    196                  }
    197                  
    198                }
    199                break;
    200                
    201              default:
    202                // Receiving packet
    203                if ( VSCP_SERIAL_PROTOCOL_STATE_PACKET == vs_main_state ) {
   \                     ??vs_feed_2:
   \   0000010A   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   0000010C   0078               LDRB     R0,[R0, #+0]
   \   0000010E   0128               CMP      R0,#+1
   \   00000110   0DD1               BNE      ??vs_feed_5
    204                  vs_checksum ^= b;
   \   00000112   ....               LDR      R0,??DataTable45  ;; vs_checksum
   \   00000114   0078               LDRB     R0,[R0, #+0]
   \   00000116   6040               EORS     R0,R0,R4
   \   00000118   ....               LDR      R1,??DataTable45  ;; vs_checksum
   \   0000011A   0870               STRB     R0,[R1, #+0]
    205                  vs_msgbuffer[ vs_buffer_cnt++ ] = b;
   \   0000011C   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   0000011E   0078               LDRB     R0,[R0, #+0]
   \   00000120   ....               LDR      R1,??DataTable53  ;; vs_msgbuffer
   \   00000122   0C54               STRB     R4,[R1, R0]
   \   00000124   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   00000126   0078               LDRB     R0,[R0, #+0]
   \   00000128   401C               ADDS     R0,R0,#+1
   \   0000012A   ....               LDR      R1,??DataTable50  ;; vs_buffer_cnt
   \   0000012C   0870               STRB     R0,[R1, #+0]
    206                }
    207                break;
    208            }
    209            
    210            // Check for buffer overflow
    211            if ( vs_buffer_cnt > VSCP_SERIAL_FRAME_SIZE ) {
   \                     ??vs_feed_5:
   \   0000012E   ....               LDR      R0,??DataTable50  ;; vs_buffer_cnt
   \   00000130   0078               LDRB     R0,[R0, #+0]
   \   00000132   1828               CMP      R0,#+24
   \   00000134   05D3               BCC      ??vs_feed_11
    212              // Start all over
    213              vs_main_state = VSCP_SERIAL_PROTOCOL_STATE_NONE;
   \   00000136   ....               LDR      R0,??DataTable51  ;; vs_main_state
   \   00000138   0021               MOVS     R1,#+0
   \   0000013A   0170               STRB     R1,[R0, #+0]
    214              vs_sub_state = VSCP_SERIAL_PROTOCOL_SUBSTATE_NONE;
   \   0000013C   ....               LDR      R0,??DataTable52  ;; vs_sub_state
   \   0000013E   0021               MOVS     R1,#+0
   \   00000140   0170               STRB     R1,[R0, #+0]
    215            }
    216            
    217            return rv;
   \                     ??vs_feed_11:
   \   00000142   2800               MOVS     R0,R5
   \   00000144   38BC               POP      {R3-R5}
   \   00000146   02BC               POP      {R1}
   \   00000148   0847               BX       R1               ;; return
    218          }
    219                       
    220          
    221          ///////////////////////////////////////////////////////////////////////////////
    222          // vs_getFrame
    223          // 
    224                       

   \                                 In section .text, align 4, keep-with-next
    225          BOOL vs_getFrame( vs_frame *pFrame )
    226          {     
   \                     vs_getFrame:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    227            // Check pointer
    228            if ( NULL == pFrame ) return FALSE; 
   \   00000004   002C               CMP      R4,#+0
   \   00000006   01D1               BNE      ??vs_getFrame_0
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   18E0               B        ??vs_getFrame_1
    229            
    230            pFrame->opcode = vs_msgbuffer[ 0 ];
   \                     ??vs_getFrame_0:
   \   0000000C   ....               LDR      R0,??DataTable53  ;; vs_msgbuffer
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   2070               STRB     R0,[R4, #+0]
    231            pFrame->flags = vs_msgbuffer[ 1 ];
   \   00000012   0C48               LDR      R0,??vs_getFrame_2  ;; vs_msgbuffer + 1
   \   00000014   0078               LDRB     R0,[R0, #+0]
   \   00000016   6070               STRB     R0,[R4, #+1]
    232            pFrame->channel = vs_msgbuffer[ 2 ];
   \   00000018   0B48               LDR      R0,??vs_getFrame_2+0x4  ;; vs_msgbuffer + 2
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   A070               STRB     R0,[R4, #+2]
    233            pFrame->seqnumber = vs_msgbuffer[ 3 ];
   \   0000001E   0B48               LDR      R0,??vs_getFrame_2+0x8  ;; vs_msgbuffer + 3
   \   00000020   0078               LDRB     R0,[R0, #+0]
   \   00000022   E070               STRB     R0,[R4, #+3]
    234            pFrame->vscpclass = vs_msgbuffer[ 4 ];
   \   00000024   0A48               LDR      R0,??vs_getFrame_2+0xC  ;; vs_msgbuffer + 4
   \   00000026   0078               LDRB     R0,[R0, #+0]
   \   00000028   2071               STRB     R0,[R4, #+4]
    235            pFrame->vscptype = vs_msgbuffer [ 5 ];
   \   0000002A   0A48               LDR      R0,??vs_getFrame_2+0x10  ;; vs_msgbuffer + 5
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   6071               STRB     R0,[R4, #+5]
    236            memcpy( pFrame->data, ( vs_msgbuffer + 6 ), 16 );
   \   00000030   1022               MOVS     R2,#+16
   \   00000032   0949               LDR      R1,??vs_getFrame_2+0x14  ;; vs_msgbuffer + 6
   \   00000034   2000               MOVS     R0,R4
   \   00000036   801D               ADDS     R0,R0,#+6
   \   00000038   ........           BL       memcpy
    237          
    238            return TRUE;
   \   0000003C   0120               MOVS     R0,#+1
   \                     ??vs_getFrame_1:
   \   0000003E   10BC               POP      {R4}
   \   00000040   02BC               POP      {R1}
   \   00000042   0847               BX       R1               ;; return
   \                     ??vs_getFrame_2:
   \   00000044   ........           DC32     vs_msgbuffer + 1
   \   00000048   ........           DC32     vs_msgbuffer + 2
   \   0000004C   ........           DC32     vs_msgbuffer + 3
   \   00000050   ........           DC32     vs_msgbuffer + 4
   \   00000054   ........           DC32     vs_msgbuffer + 5
   \   00000058   ........           DC32     vs_msgbuffer + 6
    239          }
    240                       
    241          
    242          ///////////////////////////////////////////////////////////////////////////////
    243          // vs_sendResponse
    244          //
    245          // Sent inline so it can be used inside frame feed routine
    246          //
    247          

   \                                 In section .text, align 4, keep-with-next
    248          BOOL vs_sendResponse( uint8_t opcode, uint8_t channel, uint8_t seqnumber )
    249          {
   \                     vs_sendResponse:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    250            uint8_t checksum = 0;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0700               MOVS     R7,R0
    251           
    252            // Start of frame
    253          	if ( !vs_sendSerialByte( DLE ) ) {
   \   0000000C   1020               MOVS     R0,#+16
   \   0000000E   ........           BL       vs_sendSerialByte
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D1               BNE      ??vs_sendResponse_0
    254          		return FALSE;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   5DE0               B        ??vs_sendResponse_1
    255          	}
    256          	if ( !vs_sendSerialByte( STX ) ) {
   \                     ??vs_sendResponse_0:
   \   0000001A   0120               MOVS     R0,#+1
   \   0000001C   ........           BL       vs_sendSerialByte
   \   00000020   0028               CMP      R0,#+0
   \   00000022   01D1               BNE      ??vs_sendResponse_2
    257          		return FALSE;
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   56E0               B        ??vs_sendResponse_1
    258          	}
    259            
    260            // opcode Code
    261          	if ( !vs_sendSerialByte( opcode ) ) {
   \                     ??vs_sendResponse_2:
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   \   0000002E   ........           BL       vs_sendSerialByte
   \   00000032   0028               CMP      R0,#+0
   \   00000034   01D1               BNE      ??vs_sendResponse_3
    262          		return FALSE;
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   4DE0               B        ??vs_sendResponse_1
    263          	}
    264          	checksum ^= opcode;
   \                     ??vs_sendResponse_3:
   \   0000003A   6740               EORS     R7,R7,R4
    265          
    266          	// Flags
    267          	if ( !vs_sendSerialByte( 0 ) ) {
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ........           BL       vs_sendSerialByte
   \   00000042   0028               CMP      R0,#+0
   \   00000044   01D1               BNE      ??vs_sendResponse_4
    268          		return FALSE;
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   45E0               B        ??vs_sendResponse_1
    269          	}
    270          	checksum ^= 0;
    271            
    272            // Channel
    273          	if ( DLE == channel ) {
   \                     ??vs_sendResponse_4:
   \   0000004A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000004C   2D0E               LSRS     R5,R5,#+24
   \   0000004E   102D               CMP      R5,#+16
   \   00000050   09D1               BNE      ??vs_sendResponse_5
    274              vs_sendSerialByte( DLE );
   \   00000052   1020               MOVS     R0,#+16
   \   00000054   ........           BL       vs_sendSerialByte
    275              vs_sendSerialByte( DLE );
   \   00000058   1020               MOVS     R0,#+16
   \   0000005A   ........           BL       vs_sendSerialByte
    276              checksum ^= DLE; // Only one is used for checksum calculations
   \   0000005E   3800               MOVS     R0,R7
   \   00000060   1027               MOVS     R7,#+16
   \   00000062   4740               EORS     R7,R7,R0
   \   00000064   05E0               B        ??vs_sendResponse_6
    277            }
    278            else {
    279              vs_sendSerialByte( channel );	
   \                     ??vs_sendResponse_5:
   \   00000066   2800               MOVS     R0,R5
   \   00000068   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000006A   000E               LSRS     R0,R0,#+24
   \   0000006C   ........           BL       vs_sendSerialByte
    280              checksum ^= channel;
   \   00000070   6F40               EORS     R7,R7,R5
    281            }
    282            
    283            // Counter
    284          	if ( DLE == seqnumber ) {
   \                     ??vs_sendResponse_6:
   \   00000072   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000074   360E               LSRS     R6,R6,#+24
   \   00000076   102E               CMP      R6,#+16
   \   00000078   09D1               BNE      ??vs_sendResponse_7
    285              vs_sendSerialByte( DLE );
   \   0000007A   1020               MOVS     R0,#+16
   \   0000007C   ........           BL       vs_sendSerialByte
    286              vs_sendSerialByte( DLE );
   \   00000080   1020               MOVS     R0,#+16
   \   00000082   ........           BL       vs_sendSerialByte
    287              checksum ^= DLE; // Only one is used for checksum calculations
   \   00000086   3800               MOVS     R0,R7
   \   00000088   1027               MOVS     R7,#+16
   \   0000008A   4740               EORS     R7,R7,R0
   \   0000008C   05E0               B        ??vs_sendResponse_8
    288            }
    289            else {
    290              vs_sendSerialByte( seqnumber );	
   \                     ??vs_sendResponse_7:
   \   0000008E   3000               MOVS     R0,R6
   \   00000090   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000092   000E               LSRS     R0,R0,#+24
   \   00000094   ........           BL       vs_sendSerialByte
    291              checksum ^= seqnumber;
   \   00000098   7740               EORS     R7,R7,R6
    292            }
    293            
    294            // Checksum
    295          	if ( DLE == checksum ) {
   \                     ??vs_sendResponse_8:
   \   0000009A   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000009C   3F0E               LSRS     R7,R7,#+24
   \   0000009E   102F               CMP      R7,#+16
   \   000000A0   06D1               BNE      ??vs_sendResponse_9
    296              vs_sendSerialByte( DLE );
   \   000000A2   1020               MOVS     R0,#+16
   \   000000A4   ........           BL       vs_sendSerialByte
    297              vs_sendSerialByte( DLE );
   \   000000A8   1020               MOVS     R0,#+16
   \   000000AA   ........           BL       vs_sendSerialByte
   \   000000AE   04E0               B        ??vs_sendResponse_10
    298            }
    299            else {
    300              vs_sendSerialByte( checksum );	
   \                     ??vs_sendResponse_9:
   \   000000B0   3800               MOVS     R0,R7
   \   000000B2   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000B4   000E               LSRS     R0,R0,#+24
   \   000000B6   ........           BL       vs_sendSerialByte
    301            }
    302            
    303            // End of frame
    304          	if ( !vs_sendSerialByte( DLE ) ) {
   \                     ??vs_sendResponse_10:
   \   000000BA   1020               MOVS     R0,#+16
   \   000000BC   ........           BL       vs_sendSerialByte
   \   000000C0   0028               CMP      R0,#+0
   \   000000C2   01D1               BNE      ??vs_sendResponse_11
    305          		return FALSE;
   \   000000C4   0020               MOVS     R0,#+0
   \   000000C6   06E0               B        ??vs_sendResponse_1
    306          	}
    307          	if ( !vs_sendSerialByte( ETX ) ) {
   \                     ??vs_sendResponse_11:
   \   000000C8   0220               MOVS     R0,#+2
   \   000000CA   ........           BL       vs_sendSerialByte
   \   000000CE   401E               SUBS     R0,R0,#+1
   \   000000D0   8041               SBCS     R0,R0,R0
   \   000000D2   C043               MVNS     R0,R0
   \   000000D4   C00F               LSRS     R0,R0,#+31
    308          		return FALSE;
   \                     ??vs_sendResponse_1:
   \   000000D6   F8BC               POP      {R3-R7}
   \   000000D8   02BC               POP      {R1}
   \   000000DA   0847               BX       R1               ;; return
    309          	}
    310            
    311            return TRUE; 		
    312          }
    313          
    314          ///////////////////////////////////////////////////////////////////////////////
    315          // vs_sendAck
    316          //
    317          // Sent inline so it can be used inside frame feed routine
    318          //
    319          

   \                                 In section .text, align 4, keep-with-next
    320          BOOL vs_sendAck( uint8_t channel, uint8_t seqnumber )
    321          {
   \                     vs_sendAck:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    322          	return vs_sendResponse( VSCP_SERIAL_OPCODE_ACK,
    323          														channel,
    324          														seqnumber );
   \   00000006   2A00               MOVS     R2,R5
   \   00000008   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   0000000A   120E               LSRS     R2,R2,#+24
   \   0000000C   2100               MOVS     R1,R4
   \   0000000E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000010   090E               LSRS     R1,R1,#+24
   \   00000012   FB20               MOVS     R0,#+251
   \   00000014   ........           BL       vs_sendResponse
   \   00000018   38BC               POP      {R3-R5}
   \   0000001A   02BC               POP      {R1}
   \   0000001C   0847               BX       R1               ;; return
    325          }
    326                       
    327          ///////////////////////////////////////////////////////////////////////////////
    328          // vs_sendNack
    329          //             
    330          

   \                                 In section .text, align 4, keep-with-next
    331          BOOL vs_sendNack( uint8_t channel, uint8_t seqnumber )
    332          {
   \                     vs_sendNack:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    333          	return vs_sendResponse( VSCP_SERIAL_OPCODE_NACK,
    334          														channel,
    335          														seqnumber );
   \   00000006   2A00               MOVS     R2,R5
   \   00000008   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   0000000A   120E               LSRS     R2,R2,#+24
   \   0000000C   2100               MOVS     R1,R4
   \   0000000E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000010   090E               LSRS     R1,R1,#+24
   \   00000012   FC20               MOVS     R0,#+252
   \   00000014   ........           BL       vs_sendResponse
   \   00000018   38BC               POP      {R3-R5}
   \   0000001A   02BC               POP      {R1}
   \   0000001C   0847               BX       R1               ;; return
    336          }
    337                 
    338          ///////////////////////////////////////////////////////////////////////////////
    339          // vs_sendFrame
    340          //             
    341          

   \                                 In section .text, align 4, keep-with-next
    342          BOOL vs_sendFrame( vs_frame *pFrame )
    343          {
   \                     vs_sendFrame:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    344            int i;
    345            uint8_t checksum = 0;
   \   00000004   6846               MOV      R0,SP
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0170               STRB     R1,[R0, #+0]
    346            
    347            vs_buffer_cnt = 0;
   \   0000000A   2948               LDR      R0,??vs_sendFrame_0  ;; vs_buffer_cnt
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0170               STRB     R1,[R0, #+0]
    348                
    349            // Check pointer
    350            if ( NULL == pFrame ) return FALSE; 
   \   00000010   002C               CMP      R4,#+0
   \   00000012   01D1               BNE      ??vs_sendFrame_1
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   48E0               B        ??vs_sendFrame_2
    351            
    352            // Start of frame
    353            vs_bufferSerialByte( DLE );
   \                     ??vs_sendFrame_1:
   \   00000018   1020               MOVS     R0,#+16
   \   0000001A   ........           BL       vs_bufferSerialByte
    354            vs_bufferSerialByte( STX );
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   ........           BL       vs_bufferSerialByte
    355                 
    356            // Operation     
    357            vs_bufferSerialByteSubst( &checksum, pFrame->opcode );    
   \   00000024   2178               LDRB     R1,[R4, #+0]
   \   00000026   6846               MOV      R0,SP
   \   00000028   ........           BL       vs_bufferSerialByteSubst
    358                 
    359            // Flags     
    360            vs_bufferSerialByteSubst( &checksum, pFrame->flags ); 
   \   0000002C   6178               LDRB     R1,[R4, #+1]
   \   0000002E   6846               MOV      R0,SP
   \   00000030   ........           BL       vs_bufferSerialByteSubst
    361            
    362            // Channel
    363            vs_bufferSerialByteSubst( &checksum, pFrame->channel );
   \   00000034   A178               LDRB     R1,[R4, #+2]
   \   00000036   6846               MOV      R0,SP
   \   00000038   ........           BL       vs_bufferSerialByteSubst
    364            
    365            // Counter
    366            vs_bufferSerialByteSubst( &checksum, pFrame->seqnumber );
   \   0000003C   E178               LDRB     R1,[R4, #+3]
   \   0000003E   6846               MOV      R0,SP
   \   00000040   ........           BL       vs_bufferSerialByteSubst
    367            
    368            // VSCP Class
    369            vs_bufferSerialByteSubst( &checksum, pFrame->vscpclass );
   \   00000044   2179               LDRB     R1,[R4, #+4]
   \   00000046   6846               MOV      R0,SP
   \   00000048   ........           BL       vs_bufferSerialByteSubst
    370            
    371            //  VSCP type
    372            vs_bufferSerialByteSubst( &checksum, pFrame->vscptype );
   \   0000004C   6179               LDRB     R1,[R4, #+5]
   \   0000004E   6846               MOV      R0,SP
   \   00000050   ........           BL       vs_bufferSerialByteSubst
    373          
    374            // data
    375            for ( i=0; i < ( pFrame->flags & 0x1f ); i++ ) {
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   0500               MOVS     R5,R0
   \                     ??vs_sendFrame_3:
   \   00000058   6078               LDRB     R0,[R4, #+1]
   \   0000005A   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000005C   C00E               LSRS     R0,R0,#+27
   \   0000005E   8542               CMP      R5,R0
   \   00000060   06DA               BGE      ??vs_sendFrame_4
    376          		vs_bufferSerialByteSubst( &checksum, pFrame->data[ i ] );
   \   00000062   6019               ADDS     R0,R4,R5
   \   00000064   8179               LDRB     R1,[R0, #+6]
   \   00000066   6846               MOV      R0,SP
   \   00000068   ........           BL       vs_bufferSerialByteSubst
    377            }
   \   0000006C   6D1C               ADDS     R5,R5,#+1
   \   0000006E   F3E7               B        ??vs_sendFrame_3
    378          
    379            //  Checksum - Note: checksum byte(s) sent before checksum calcuulated so OK
    380            vs_bufferSerialByteSubst( &checksum, checksum );
   \                     ??vs_sendFrame_4:
   \   00000070   6846               MOV      R0,SP
   \   00000072   0178               LDRB     R1,[R0, #+0]
   \   00000074   6846               MOV      R0,SP
   \   00000076   ........           BL       vs_bufferSerialByteSubst
    381            
    382            // End of frame
    383            vs_bufferSerialByte( DLE );
   \   0000007A   1020               MOVS     R0,#+16
   \   0000007C   ........           BL       vs_bufferSerialByte
    384            vs_bufferSerialByte( ETX );     
   \   00000080   0220               MOVS     R0,#+2
   \   00000082   ........           BL       vs_bufferSerialByte
    385            
    386            // Send the buffer content
    387            if ( !vs_sendBuffer(  vs_msgbuffer, vs_buffer_cnt  ) ) {
   \   00000086   0A48               LDR      R0,??vs_sendFrame_0  ;; vs_buffer_cnt
   \   00000088   0178               LDRB     R1,[R0, #+0]
   \   0000008A   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000008C   090C               LSRS     R1,R1,#+16
   \   0000008E   0948               LDR      R0,??vs_sendFrame_0+0x4  ;; vs_msgbuffer
   \   00000090   ........           BL       vs_sendBuffer
   \   00000094   0028               CMP      R0,#+0
   \   00000096   04D1               BNE      ??vs_sendFrame_5
    388              vs_buffer_cnt = 0;
   \   00000098   0548               LDR      R0,??vs_sendFrame_0  ;; vs_buffer_cnt
   \   0000009A   0021               MOVS     R1,#+0
   \   0000009C   0170               STRB     R1,[R0, #+0]
    389              return FALSE;
   \   0000009E   0020               MOVS     R0,#+0
   \   000000A0   03E0               B        ??vs_sendFrame_2
    390            }
    391          
    392            vs_buffer_cnt = 0;
   \                     ??vs_sendFrame_5:
   \   000000A2   0348               LDR      R0,??vs_sendFrame_0  ;; vs_buffer_cnt
   \   000000A4   0021               MOVS     R1,#+0
   \   000000A6   0170               STRB     R1,[R0, #+0]
    393            
    394            return TRUE;
   \   000000A8   0120               MOVS     R0,#+1
   \                     ??vs_sendFrame_2:
   \   000000AA   38BC               POP      {R3-R5}
   \   000000AC   02BC               POP      {R1}
   \   000000AE   0847               BX       R1               ;; return
   \                     ??vs_sendFrame_0:
   \   000000B0   ........           DC32     vs_buffer_cnt
   \   000000B4   ........           DC32     vs_msgbuffer
    395          }
    396          
    397          
    398          ///////////////////////////////////////////////////////////////////////////////
    399          // vs_sendCommandFrame
    400          //             
    401          

   \                                 In section .text, align 4, keep-with-next
    402          BOOL vs_sendCommandFrame( uint8_t channel, 
    403                                      uint8_t seqnumber, 
    404          														uint16_t command,
    405                                      uint8_t count,  
    406                                      uint8_t *pData  )
    407          {
   \                     vs_sendCommandFrame:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1400               MOVS     R4,R2
   \   00000006   1D00               MOVS     R5,R3
   \   00000008   089E               LDR      R6,[SP, #+32]
    408            int i;
    409            uint8_t checksum = 0;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0170               STRB     R1,[R0, #+0]
    410            
    411            vs_buffer_cnt = 0;
   \   00000010   2E48               LDR      R0,??vs_sendCommandFrame_0  ;; vs_buffer_cnt
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0170               STRB     R1,[R0, #+0]
    412            
    413            // Check pointer - Must be at least command byte
    414            if ( NULL == pData ) return FALSE;
   \   00000016   002E               CMP      R6,#+0
   \   00000018   01D1               BNE      ??vs_sendCommandFrame_1
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   53E0               B        ??vs_sendCommandFrame_2
    415            
    416            count &= 0x1f;  // Max 16 bytes
   \                     ??vs_sendCommandFrame_1:
   \   0000001E   ED06               LSLS     R5,R5,#+27       ;; ZeroExtS R5,R5,#+27,#+27
   \   00000020   ED0E               LSRS     R5,R5,#+27
    417            
    418            // Start of frame
    419            vs_bufferSerialByte( DLE );
   \   00000022   1020               MOVS     R0,#+16
   \   00000024   ........           BL       vs_bufferSerialByte
    420            vs_bufferSerialByte( STX );
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   ........           BL       vs_bufferSerialByte
    421            
    422            // ACK Code
    423            vs_bufferSerialByteSubst( &checksum, VSCP_SERIAL_OPCODE_COMMAND );
   \   0000002E   FF21               MOVS     R1,#+255
   \   00000030   6846               MOV      R0,SP
   \   00000032   ........           BL       vs_bufferSerialByteSubst
    424            
    425            // Flags: Data byte count
    426            vs_bufferSerialByteSubst( &checksum, count );
   \   00000036   2900               MOVS     R1,R5
   \   00000038   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000003A   090E               LSRS     R1,R1,#+24
   \   0000003C   6846               MOV      R0,SP
   \   0000003E   ........           BL       vs_bufferSerialByteSubst
    427            
    428            // Channel
    429            vs_bufferSerialByteSubst( &checksum, channel );
   \   00000042   6846               MOV      R0,SP
   \   00000044   0179               LDRB     R1,[R0, #+4]
   \   00000046   6846               MOV      R0,SP
   \   00000048   ........           BL       vs_bufferSerialByteSubst
    430          
    431          	// Counter
    432            vs_bufferSerialByteSubst( &checksum, seqnumber );
   \   0000004C   6846               MOV      R0,SP
   \   0000004E   017A               LDRB     R1,[R0, #+8]
   \   00000050   6846               MOV      R0,SP
   \   00000052   ........           BL       vs_bufferSerialByteSubst
    433          
    434          	// Command
    435          	vs_bufferSerialByteSubst( &checksum, ( ( command >> 8 ) & 0xff ) );
   \   00000056   2100               MOVS     R1,R4
   \   00000058   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000005A   090C               LSRS     R1,R1,#+16
   \   0000005C   090A               LSRS     R1,R1,#+8
   \   0000005E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000060   090E               LSRS     R1,R1,#+24
   \   00000062   6846               MOV      R0,SP
   \   00000064   ........           BL       vs_bufferSerialByteSubst
    436          	vs_bufferSerialByteSubst( &checksum, ( command & 0xff ) );
   \   00000068   2100               MOVS     R1,R4
   \   0000006A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000006C   090E               LSRS     R1,R1,#+24
   \   0000006E   6846               MOV      R0,SP
   \   00000070   ........           BL       vs_bufferSerialByteSubst
    437            
    438            for ( i = 0; i<count; i++ ) {
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   0700               MOVS     R7,R0
   \                     ??vs_sendCommandFrame_3:
   \   00000078   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000007A   2D0E               LSRS     R5,R5,#+24
   \   0000007C   AF42               CMP      R7,R5
   \   0000007E   05DA               BGE      ??vs_sendCommandFrame_4
    439              vs_bufferSerialByteSubst( &checksum, pData[ i ] );
   \   00000080   F15D               LDRB     R1,[R6, R7]
   \   00000082   6846               MOV      R0,SP
   \   00000084   ........           BL       vs_bufferSerialByteSubst
    440            }
   \   00000088   7F1C               ADDS     R7,R7,#+1
   \   0000008A   F5E7               B        ??vs_sendCommandFrame_3
    441            
    442            // Checksum
    443            vs_bufferSerialByteSubst( &checksum, checksum );
   \                     ??vs_sendCommandFrame_4:
   \   0000008C   6846               MOV      R0,SP
   \   0000008E   0178               LDRB     R1,[R0, #+0]
   \   00000090   6846               MOV      R0,SP
   \   00000092   ........           BL       vs_bufferSerialByteSubst
    444            
    445            // End of frame
    446            vs_bufferSerialByte( DLE );
   \   00000096   1020               MOVS     R0,#+16
   \   00000098   ........           BL       vs_bufferSerialByte
    447            vs_bufferSerialByte( ETX );
   \   0000009C   0220               MOVS     R0,#+2
   \   0000009E   ........           BL       vs_bufferSerialByte
    448            
    449            // Send the buffer content
    450          	if ( !vs_sendBuffer(  vs_msgbuffer, vs_buffer_cnt  ) ) {
   \   000000A2   0A48               LDR      R0,??vs_sendCommandFrame_0  ;; vs_buffer_cnt
   \   000000A4   0178               LDRB     R1,[R0, #+0]
   \   000000A6   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000A8   090C               LSRS     R1,R1,#+16
   \   000000AA   0948               LDR      R0,??vs_sendCommandFrame_0+0x4  ;; vs_msgbuffer
   \   000000AC   ........           BL       vs_sendBuffer
   \   000000B0   0028               CMP      R0,#+0
   \   000000B2   04D1               BNE      ??vs_sendCommandFrame_5
    451          	  vs_buffer_cnt = 0;
   \   000000B4   0548               LDR      R0,??vs_sendCommandFrame_0  ;; vs_buffer_cnt
   \   000000B6   0021               MOVS     R1,#+0
   \   000000B8   0170               STRB     R1,[R0, #+0]
    452          	  return FALSE;
   \   000000BA   0020               MOVS     R0,#+0
   \   000000BC   03E0               B        ??vs_sendCommandFrame_2
    453            }
    454          
    455            vs_buffer_cnt = 0;
   \                     ??vs_sendCommandFrame_5:
   \   000000BE   0348               LDR      R0,??vs_sendCommandFrame_0  ;; vs_buffer_cnt
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   0170               STRB     R1,[R0, #+0]
    456              
    457            return TRUE;  
   \   000000C4   0120               MOVS     R0,#+1
   \                     ??vs_sendCommandFrame_2:
   \   000000C6   FEBC               POP      {R1-R7}
   \   000000C8   02BC               POP      {R1}
   \   000000CA   0847               BX       R1               ;; return
   \                     ??vs_sendCommandFrame_0:
   \   000000CC   ........           DC32     vs_buffer_cnt
   \   000000D0   ........           DC32     vs_msgbuffer
    458          }
    459          
    460          
    461          ///////////////////////////////////////////////////////////////////////////////
    462          // vs_sendErrorFrame
    463          //             
    464          

   \                                 In section .text, align 4, keep-with-next
    465          BOOL vs_sendErrorFrame( uint8_t channel, 
    466                                    uint8_t seqnumber, 
    467          													uint16_t errorcode,
    468                                    uint8_t count,  
    469                                    uint8_t *pData  )
    470          {
   \                     vs_sendErrorFrame:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1400               MOVS     R4,R2
   \   00000006   1D00               MOVS     R5,R3
   \   00000008   089E               LDR      R6,[SP, #+32]
    471            int i;
    472            uint8_t checksum = 0;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0170               STRB     R1,[R0, #+0]
    473            
    474            vs_buffer_cnt = 0;
   \   00000010   2E48               LDR      R0,??vs_sendErrorFrame_0  ;; vs_buffer_cnt
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0170               STRB     R1,[R0, #+0]
    475            
    476            // Check pointer - must at least be error byte
    477            if ( NULL == pData ) return FALSE;
   \   00000016   002E               CMP      R6,#+0
   \   00000018   01D1               BNE      ??vs_sendErrorFrame_1
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   53E0               B        ??vs_sendErrorFrame_2
    478            
    479            count &= 0x1f;  // Max 16 bytes
   \                     ??vs_sendErrorFrame_1:
   \   0000001E   ED06               LSLS     R5,R5,#+27       ;; ZeroExtS R5,R5,#+27,#+27
   \   00000020   ED0E               LSRS     R5,R5,#+27
    480            
    481            // Start of frame
    482            vs_bufferSerialByte( DLE );
   \   00000022   1020               MOVS     R0,#+16
   \   00000024   ........           BL       vs_bufferSerialByte
    483            vs_bufferSerialByte( STX );
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   ........           BL       vs_bufferSerialByte
    484            
    485            // ACK Code
    486            vs_bufferSerialByteSubst( &checksum, VSCP_SERIAL_OPCODE_ERROR );
   \   0000002E   FD21               MOVS     R1,#+253
   \   00000030   6846               MOV      R0,SP
   \   00000032   ........           BL       vs_bufferSerialByteSubst
    487            
    488            // Flags: Data byte count
    489            vs_bufferSerialByteSubst( &checksum, count );
   \   00000036   2900               MOVS     R1,R5
   \   00000038   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000003A   090E               LSRS     R1,R1,#+24
   \   0000003C   6846               MOV      R0,SP
   \   0000003E   ........           BL       vs_bufferSerialByteSubst
    490            
    491            // Channel
    492            vs_bufferSerialByteSubst( &checksum, channel );
   \   00000042   6846               MOV      R0,SP
   \   00000044   0179               LDRB     R1,[R0, #+4]
   \   00000046   6846               MOV      R0,SP
   \   00000048   ........           BL       vs_bufferSerialByteSubst
    493            
    494            // Counter
    495            vs_bufferSerialByteSubst( &checksum, seqnumber );
   \   0000004C   6846               MOV      R0,SP
   \   0000004E   017A               LDRB     R1,[R0, #+8]
   \   00000050   6846               MOV      R0,SP
   \   00000052   ........           BL       vs_bufferSerialByteSubst
    496          
    497          	// Errorcode
    498          	vs_bufferSerialByteSubst( &checksum, ( ( errorcode >> 8 ) & 0xff ) );
   \   00000056   2100               MOVS     R1,R4
   \   00000058   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000005A   090C               LSRS     R1,R1,#+16
   \   0000005C   090A               LSRS     R1,R1,#+8
   \   0000005E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000060   090E               LSRS     R1,R1,#+24
   \   00000062   6846               MOV      R0,SP
   \   00000064   ........           BL       vs_bufferSerialByteSubst
    499          	vs_bufferSerialByteSubst( &checksum, ( errorcode & 0xff ) );
   \   00000068   2100               MOVS     R1,R4
   \   0000006A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000006C   090E               LSRS     R1,R1,#+24
   \   0000006E   6846               MOV      R0,SP
   \   00000070   ........           BL       vs_bufferSerialByteSubst
    500            
    501            for ( i = 0; i<count; i++ ) {
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   0700               MOVS     R7,R0
   \                     ??vs_sendErrorFrame_3:
   \   00000078   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000007A   2D0E               LSRS     R5,R5,#+24
   \   0000007C   AF42               CMP      R7,R5
   \   0000007E   05DA               BGE      ??vs_sendErrorFrame_4
    502              vs_bufferSerialByteSubst( &checksum, pData[ i ] );
   \   00000080   F15D               LDRB     R1,[R6, R7]
   \   00000082   6846               MOV      R0,SP
   \   00000084   ........           BL       vs_bufferSerialByteSubst
    503            }
   \   00000088   7F1C               ADDS     R7,R7,#+1
   \   0000008A   F5E7               B        ??vs_sendErrorFrame_3
    504            
    505            // Checksum
    506            vs_bufferSerialByteSubst( &checksum, checksum );
   \                     ??vs_sendErrorFrame_4:
   \   0000008C   6846               MOV      R0,SP
   \   0000008E   0178               LDRB     R1,[R0, #+0]
   \   00000090   6846               MOV      R0,SP
   \   00000092   ........           BL       vs_bufferSerialByteSubst
    507            
    508            // End of frame
    509            vs_bufferSerialByte( DLE );
   \   00000096   1020               MOVS     R0,#+16
   \   00000098   ........           BL       vs_bufferSerialByte
    510            vs_bufferSerialByte( ETX );
   \   0000009C   0220               MOVS     R0,#+2
   \   0000009E   ........           BL       vs_bufferSerialByte
    511            
    512            // Send the buffer content
    513            if ( !vs_sendBuffer(  vs_msgbuffer, vs_buffer_cnt  ) ) {
   \   000000A2   0A48               LDR      R0,??vs_sendErrorFrame_0  ;; vs_buffer_cnt
   \   000000A4   0178               LDRB     R1,[R0, #+0]
   \   000000A6   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000A8   090C               LSRS     R1,R1,#+16
   \   000000AA   0948               LDR      R0,??vs_sendErrorFrame_0+0x4  ;; vs_msgbuffer
   \   000000AC   ........           BL       vs_sendBuffer
   \   000000B0   0028               CMP      R0,#+0
   \   000000B2   04D1               BNE      ??vs_sendErrorFrame_5
    514          	  vs_buffer_cnt = 0;
   \   000000B4   0548               LDR      R0,??vs_sendErrorFrame_0  ;; vs_buffer_cnt
   \   000000B6   0021               MOVS     R1,#+0
   \   000000B8   0170               STRB     R1,[R0, #+0]
    515          	  return FALSE;
   \   000000BA   0020               MOVS     R0,#+0
   \   000000BC   03E0               B        ??vs_sendErrorFrame_2
    516            }
    517          
    518            vs_buffer_cnt = 0;
   \                     ??vs_sendErrorFrame_5:
   \   000000BE   0348               LDR      R0,??vs_sendErrorFrame_0  ;; vs_buffer_cnt
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   0170               STRB     R1,[R0, #+0]
    519              
    520            return TRUE;  
   \   000000C4   0120               MOVS     R0,#+1
   \                     ??vs_sendErrorFrame_2:
   \   000000C6   FEBC               POP      {R1-R7}
   \   000000C8   02BC               POP      {R1}
   \   000000CA   0847               BX       R1               ;; return
   \                     ??vs_sendErrorFrame_0:
   \   000000CC   ........           DC32     vs_buffer_cnt
   \   000000D0   ........           DC32     vs_msgbuffer
    521          }
    522          
    523          ///////////////////////////////////////////////////////////////////////////////
    524          // vs_sendReplyFrame
    525          
    526          //             
    527          

   \                                 In section .text, align 4, keep-with-next
    528          BOOL vs_sendReplyFrame( uint8_t channel, 
    529                                    uint8_t seqnumber, 
    530          													uint16_t replycode,
    531                                    uint8_t count,  
    532                                    uint8_t *pData  )
    533          {
   \                     vs_sendReplyFrame:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1400               MOVS     R4,R2
   \   00000006   1D00               MOVS     R5,R3
   \   00000008   089E               LDR      R6,[SP, #+32]
    534            int i;
    535            uint8_t checksum = 0;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0170               STRB     R1,[R0, #+0]
    536            
    537            vs_buffer_cnt = 0;
   \   00000010   2E48               LDR      R0,??vs_sendReplyFrame_0  ;; vs_buffer_cnt
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0170               STRB     R1,[R0, #+0]
    538            
    539            // Check pointer - must at least be error byte
    540            if ( NULL == pData ) return FALSE;
   \   00000016   002E               CMP      R6,#+0
   \   00000018   01D1               BNE      ??vs_sendReplyFrame_1
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   53E0               B        ??vs_sendReplyFrame_2
    541            
    542            count &= 0x1f;  // Max 16 bytes
   \                     ??vs_sendReplyFrame_1:
   \   0000001E   ED06               LSLS     R5,R5,#+27       ;; ZeroExtS R5,R5,#+27,#+27
   \   00000020   ED0E               LSRS     R5,R5,#+27
    543            
    544            // Start of frame
    545            vs_bufferSerialByte( DLE );
   \   00000022   1020               MOVS     R0,#+16
   \   00000024   ........           BL       vs_bufferSerialByte
    546            vs_bufferSerialByte( STX );
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   ........           BL       vs_bufferSerialByte
    547            
    548            // ACK Code
    549            vs_bufferSerialByteSubst( &checksum, VSCP_SERIAL_OPCODE_ERROR );
   \   0000002E   FD21               MOVS     R1,#+253
   \   00000030   6846               MOV      R0,SP
   \   00000032   ........           BL       vs_bufferSerialByteSubst
    550            
    551            // Flags: Data byte count
    552            vs_bufferSerialByteSubst( &checksum, count );
   \   00000036   2900               MOVS     R1,R5
   \   00000038   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000003A   090E               LSRS     R1,R1,#+24
   \   0000003C   6846               MOV      R0,SP
   \   0000003E   ........           BL       vs_bufferSerialByteSubst
    553            
    554            // Channel
    555            vs_bufferSerialByteSubst( &checksum, channel );
   \   00000042   6846               MOV      R0,SP
   \   00000044   0179               LDRB     R1,[R0, #+4]
   \   00000046   6846               MOV      R0,SP
   \   00000048   ........           BL       vs_bufferSerialByteSubst
    556            
    557            // Counter
    558            vs_bufferSerialByteSubst( &checksum, seqnumber );
   \   0000004C   6846               MOV      R0,SP
   \   0000004E   017A               LDRB     R1,[R0, #+8]
   \   00000050   6846               MOV      R0,SP
   \   00000052   ........           BL       vs_bufferSerialByteSubst
    559          
    560          	// Replycode
    561          	vs_bufferSerialByteSubst( &checksum, ( ( replycode >> 8 ) & 0xff ) );
   \   00000056   2100               MOVS     R1,R4
   \   00000058   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000005A   090C               LSRS     R1,R1,#+16
   \   0000005C   090A               LSRS     R1,R1,#+8
   \   0000005E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000060   090E               LSRS     R1,R1,#+24
   \   00000062   6846               MOV      R0,SP
   \   00000064   ........           BL       vs_bufferSerialByteSubst
    562          	vs_bufferSerialByteSubst( &checksum, ( replycode & 0xff ) );
   \   00000068   2100               MOVS     R1,R4
   \   0000006A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000006C   090E               LSRS     R1,R1,#+24
   \   0000006E   6846               MOV      R0,SP
   \   00000070   ........           BL       vs_bufferSerialByteSubst
    563            
    564            for ( i = 0; i<count; i++ ) {
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   0700               MOVS     R7,R0
   \                     ??vs_sendReplyFrame_3:
   \   00000078   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000007A   2D0E               LSRS     R5,R5,#+24
   \   0000007C   AF42               CMP      R7,R5
   \   0000007E   05DA               BGE      ??vs_sendReplyFrame_4
    565              vs_bufferSerialByteSubst( &checksum, pData[ i ] );
   \   00000080   F15D               LDRB     R1,[R6, R7]
   \   00000082   6846               MOV      R0,SP
   \   00000084   ........           BL       vs_bufferSerialByteSubst
    566            }
   \   00000088   7F1C               ADDS     R7,R7,#+1
   \   0000008A   F5E7               B        ??vs_sendReplyFrame_3
    567            
    568            // Checksum
    569            vs_bufferSerialByteSubst( &checksum, checksum );
   \                     ??vs_sendReplyFrame_4:
   \   0000008C   6846               MOV      R0,SP
   \   0000008E   0178               LDRB     R1,[R0, #+0]
   \   00000090   6846               MOV      R0,SP
   \   00000092   ........           BL       vs_bufferSerialByteSubst
    570            
    571            // End of frame
    572            vs_bufferSerialByte( DLE );
   \   00000096   1020               MOVS     R0,#+16
   \   00000098   ........           BL       vs_bufferSerialByte
    573            vs_bufferSerialByte( ETX );
   \   0000009C   0220               MOVS     R0,#+2
   \   0000009E   ........           BL       vs_bufferSerialByte
    574            
    575            // Send the buffer content
    576            if ( !vs_sendBuffer(  vs_msgbuffer, vs_buffer_cnt  ) ) {
   \   000000A2   0A48               LDR      R0,??vs_sendReplyFrame_0  ;; vs_buffer_cnt
   \   000000A4   0178               LDRB     R1,[R0, #+0]
   \   000000A6   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000A8   090C               LSRS     R1,R1,#+16
   \   000000AA   0948               LDR      R0,??vs_sendReplyFrame_0+0x4  ;; vs_msgbuffer
   \   000000AC   ........           BL       vs_sendBuffer
   \   000000B0   0028               CMP      R0,#+0
   \   000000B2   04D1               BNE      ??vs_sendReplyFrame_5
    577          	  vs_buffer_cnt = 0;
   \   000000B4   0548               LDR      R0,??vs_sendReplyFrame_0  ;; vs_buffer_cnt
   \   000000B6   0021               MOVS     R1,#+0
   \   000000B8   0170               STRB     R1,[R0, #+0]
    578          	  return FALSE;
   \   000000BA   0020               MOVS     R0,#+0
   \   000000BC   03E0               B        ??vs_sendReplyFrame_2
    579            }
    580          
    581            vs_buffer_cnt = 0;
   \                     ??vs_sendReplyFrame_5:
   \   000000BE   0348               LDR      R0,??vs_sendReplyFrame_0  ;; vs_buffer_cnt
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   0170               STRB     R1,[R0, #+0]
    582              
    583            return TRUE;  
   \   000000C4   0120               MOVS     R0,#+1
   \                     ??vs_sendReplyFrame_2:
   \   000000C6   FEBC               POP      {R1-R7}
   \   000000C8   02BC               POP      {R1}
   \   000000CA   0847               BX       R1               ;; return
   \                     ??vs_sendReplyFrame_0:
   \   000000CC   ........           DC32     vs_buffer_cnt
   \   000000D0   ........           DC32     vs_msgbuffer
    584          }
    585          
    586          ///////////////////////////////////////////////////////////////////////////////
    587          ///////////////////////////////////////////////////////////////////////////////
    588          ///////////////////////////////////////////////////////////////////////////////
    589          
    590          
    591          
    592          #ifdef VSCP_SERIAL_ENABLE_SLIDING_WINDOWS 
    593          
    594          
    595          ///////////////////////////////////////////////////////////////////////////////
    596          // vs_initSlidingWndFrames
    597          //
    598          

   \                                 In section .text, align 4, keep-with-next
    599          void vs_initSlidingWndFrames( vs_swStruct *pSlide, 
    600          								uint32_t timeout,
    601          								uint8_t resend ) 
    602          {
   \                     vs_initSlidingWndFrames:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    603            int i;
    604            
    605            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   2300               MOVS     R3,R4
   \                     ??vs_initSlidingWndFrames_0:
   \   00000006   0A2B               CMP      R3,#+10
   \   00000008   0CDA               BGE      ??vs_initSlidingWndFrames_1
    606              pSlide->Frames[ i ].timestamp = 0;
   \   0000000A   1C24               MOVS     R4,#+28
   \   0000000C   5C43               MULS     R4,R3,R4
   \   0000000E   0419               ADDS     R4,R0,R4
   \   00000010   0025               MOVS     R5,#+0
   \   00000012   E560               STR      R5,[R4, #+12]
    607              pSlide->Frames[ i ].send_count = 0;
   \   00000014   1C24               MOVS     R4,#+28
   \   00000016   5C43               MULS     R4,R3,R4
   \   00000018   0419               ADDS     R4,R0,R4
   \   0000001A   2634               ADDS     R4,R4,#+38
   \   0000001C   0025               MOVS     R5,#+0
   \   0000001E   2570               STRB     R5,[R4, #+0]
    608            }
   \   00000020   5B1C               ADDS     R3,R3,#+1
   \   00000022   F0E7               B        ??vs_initSlidingWndFrames_0
    609          
    610            pSlide->cntOutstanding = 0;
   \                     ??vs_initSlidingWndFrames_1:
   \   00000024   0024               MOVS     R4,#+0
   \   00000026   0470               STRB     R4,[R0, #+0]
    611            pSlide->maxresend = resend;
   \   00000028   0272               STRB     R2,[R0, #+8]
    612            pSlide->maxtime = timeout;
   \   0000002A   4160               STR      R1,[R0, #+4]
    613          }
   \   0000002C   38BC               POP      {R3-R5}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
    614          
    615          
    616          
    617          ///////////////////////////////////////////////////////////////////////////////
    618          // vs_findFlyingFrame
    619          //
    620          

   \                                 In section .text, align 4, keep-with-next
    621          vs_swFrameStruct *
    622          vs_findFlyingFrame( vs_swStruct *pSlide, 
    623                                  uint8_t channel, 
    624                                  uint8_t seqnumber ) 
    625          {
   \                     vs_findFlyingFrame:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0300               MOVS     R3,R0
    626            int i;
    627            
    628            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
   \                     ??vs_findFlyingFrame_0:
   \   00000008   0A2C               CMP      R4,#+10
   \   0000000A   16DA               BGE      ??vs_findFlyingFrame_1
    629              if ( ( channel == pSlide->Frames[ i ].frame.channel ) &&
    630                  ( seqnumber == pSlide->Frames[ i ].frame.seqnumber ) ) {
   \   0000000C   1C20               MOVS     R0,#+28
   \   0000000E   6043               MULS     R0,R4,R0
   \   00000010   1818               ADDS     R0,R3,R0
   \   00000012   807C               LDRB     R0,[R0, #+18]
   \   00000014   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000016   090E               LSRS     R1,R1,#+24
   \   00000018   8142               CMP      R1,R0
   \   0000001A   0CD1               BNE      ??vs_findFlyingFrame_2
   \   0000001C   1C20               MOVS     R0,#+28
   \   0000001E   6043               MULS     R0,R4,R0
   \   00000020   1818               ADDS     R0,R3,R0
   \   00000022   C07C               LDRB     R0,[R0, #+19]
   \   00000024   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000026   120E               LSRS     R2,R2,#+24
   \   00000028   8242               CMP      R2,R0
   \   0000002A   04D1               BNE      ??vs_findFlyingFrame_2
    631                return &( pSlide->Frames[ i ] );      
   \   0000002C   1C20               MOVS     R0,#+28
   \   0000002E   4443               MULS     R4,R0,R4
   \   00000030   1819               ADDS     R0,R3,R4
   \   00000032   0C30               ADDS     R0,R0,#+12
   \   00000034   02E0               B        ??vs_findFlyingFrame_3
    632              }
    633            }
   \                     ??vs_findFlyingFrame_2:
   \   00000036   641C               ADDS     R4,R4,#+1
   \   00000038   E6E7               B        ??vs_findFlyingFrame_0
    634            
    635            return NULL;
   \                     ??vs_findFlyingFrame_1:
   \   0000003A   0020               MOVS     R0,#+0
   \                     ??vs_findFlyingFrame_3:
   \   0000003C   10BC               POP      {R4}
   \   0000003E   02BC               POP      {R1}
   \   00000040   0847               BX       R1               ;; return
    636          }
    637          
    638          ///////////////////////////////////////////////////////////////////////////////
    639          // vs_findFreeFlyingFrame
    640          //
    641          

   \                                 In section .text, align 4, keep-with-next
    642          vs_swFrameStruct *
    643          vs_findFreeFlyingFrame( vs_swStruct *pSlide ) 
    644          {
   \                     vs_findFreeFlyingFrame:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    645            int i;
    646            
    647            if ( pSlide->cntOutstanding >= VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES ) {
   \   00000004   0878               LDRB     R0,[R1, #+0]
   \   00000006   0A28               CMP      R0,#+10
   \   00000008   01D3               BCC      ??vs_findFreeFlyingFrame_0
    648          		return NULL;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   18E0               B        ??vs_findFreeFlyingFrame_1
    649            }
    650          
    651            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \                     ??vs_findFreeFlyingFrame_0:
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   0200               MOVS     R2,R0
   \                     ??vs_findFreeFlyingFrame_2:
   \   00000012   0A2A               CMP      R2,#+10
   \   00000014   13DA               BGE      ??vs_findFreeFlyingFrame_3
    652              if ( ( 0 == pSlide->Frames[ i ].timestamp ) &&
    653                  ( 0 == pSlide->Frames[ i ].send_count ) ) {
   \   00000016   1C20               MOVS     R0,#+28
   \   00000018   5043               MULS     R0,R2,R0
   \   0000001A   0818               ADDS     R0,R1,R0
   \   0000001C   C068               LDR      R0,[R0, #+12]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   0BD1               BNE      ??vs_findFreeFlyingFrame_4
   \   00000022   1C20               MOVS     R0,#+28
   \   00000024   5043               MULS     R0,R2,R0
   \   00000026   0818               ADDS     R0,R1,R0
   \   00000028   2630               ADDS     R0,R0,#+38
   \   0000002A   0078               LDRB     R0,[R0, #+0]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   04D1               BNE      ??vs_findFreeFlyingFrame_4
    654                return &( pSlide->Frames[ i ] );      
   \   00000030   1C20               MOVS     R0,#+28
   \   00000032   4243               MULS     R2,R0,R2
   \   00000034   8818               ADDS     R0,R1,R2
   \   00000036   0C30               ADDS     R0,R0,#+12
   \   00000038   02E0               B        ??vs_findFreeFlyingFrame_1
    655              }
    656            }
   \                     ??vs_findFreeFlyingFrame_4:
   \   0000003A   521C               ADDS     R2,R2,#+1
   \   0000003C   E9E7               B        ??vs_findFreeFlyingFrame_2
    657            
    658            return NULL;
   \                     ??vs_findFreeFlyingFrame_3:
   \   0000003E   0020               MOVS     R0,#+0
   \                     ??vs_findFreeFlyingFrame_1:
   \   00000040   08BC               POP      {R3}
   \   00000042   02BC               POP      {R1}
   \   00000044   0847               BX       R1               ;; return
    659          }
    660          
    661          ///////////////////////////////////////////////////////////////////////////////
    662          // vs_addSlidingWndFrame
    663          //
    664          

   \                                 In section .text, align 4, keep-with-next
    665          BOOL vs_addSlidingWndFrame( vs_swStruct *pSlide,
    666                                          vs_frame *pFrame,
    667                                          uint32_t now ) 
    668          {
   \                     vs_addSlidingWndFrame:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    669            int i;
    670            
    671            // Check pointer
    672            if ( NULL == pSlide ) return FALSE;
   \   00000008   002C               CMP      R4,#+0
   \   0000000A   01D1               BNE      ??vs_addSlidingWndFrame_0
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   28E0               B        ??vs_addSlidingWndFrame_1
    673            
    674            // Check if there is room for another frame
    675            if ( pSlide->cntOutstanding >= VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES ) return FALSE;
   \                     ??vs_addSlidingWndFrame_0:
   \   00000010   2078               LDRB     R0,[R4, #+0]
   \   00000012   0A28               CMP      R0,#+10
   \   00000014   01D3               BCC      ??vs_addSlidingWndFrame_2
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   23E0               B        ??vs_addSlidingWndFrame_1
    676            
    677            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \                     ??vs_addSlidingWndFrame_2:
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   0700               MOVS     R7,R0
   \                     ??vs_addSlidingWndFrame_3:
   \   0000001E   0A2F               CMP      R7,#+10
   \   00000020   1EDA               BGE      ??vs_addSlidingWndFrame_4
    678              if ( 0 == pSlide->Frames[ i ].timestamp   ) {
   \   00000022   1C20               MOVS     R0,#+28
   \   00000024   7843               MULS     R0,R7,R0
   \   00000026   2018               ADDS     R0,R4,R0
   \   00000028   C068               LDR      R0,[R0, #+12]
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   16D1               BNE      ??vs_addSlidingWndFrame_5
    679                memcpy( &pSlide->Frames[ i ].frame,
    680                            pFrame,
    681                            sizeof( vs_frame  ) );
   \   0000002E   1622               MOVS     R2,#+22
   \   00000030   2900               MOVS     R1,R5
   \   00000032   1C20               MOVS     R0,#+28
   \   00000034   7843               MULS     R0,R7,R0
   \   00000036   2018               ADDS     R0,R4,R0
   \   00000038   1030               ADDS     R0,R0,#+16
   \   0000003A   ........           BL       memcpy
    682                pSlide->Frames[ i ].timestamp = now;
   \   0000003E   1C20               MOVS     R0,#+28
   \   00000040   7843               MULS     R0,R7,R0
   \   00000042   2018               ADDS     R0,R4,R0
   \   00000044   C660               STR      R6,[R0, #+12]
    683                pSlide->Frames[ i ].send_count = 0;
   \   00000046   1C20               MOVS     R0,#+28
   \   00000048   7843               MULS     R0,R7,R0
   \   0000004A   2018               ADDS     R0,R4,R0
   \   0000004C   2630               ADDS     R0,R0,#+38
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   0170               STRB     R1,[R0, #+0]
    684                pSlide->cntOutstanding++; // Another frame added
   \   00000052   2078               LDRB     R0,[R4, #+0]
   \   00000054   401C               ADDS     R0,R0,#+1
   \   00000056   2070               STRB     R0,[R4, #+0]
    685                return TRUE;
   \   00000058   0120               MOVS     R0,#+1
   \   0000005A   02E0               B        ??vs_addSlidingWndFrame_1
    686              }
    687            }  
   \                     ??vs_addSlidingWndFrame_5:
   \   0000005C   7F1C               ADDS     R7,R7,#+1
   \   0000005E   DEE7               B        ??vs_addSlidingWndFrame_3
    688            
    689            // No room for a new frame found - strange!!!
    690            return FALSE;
   \                     ??vs_addSlidingWndFrame_4:
   \   00000060   0020               MOVS     R0,#+0
   \                     ??vs_addSlidingWndFrame_1:
   \   00000062   F8BC               POP      {R3-R7}
   \   00000064   02BC               POP      {R1}
   \   00000066   0847               BX       R1               ;; return
    691          }
    692          
    693          
    694          ///////////////////////////////////////////////////////////////////////////////
    695          // vs_removeSlidingWndFrame
    696          //
    697          

   \                                 In section .text, align 4, keep-with-next
    698          BOOL vs_removeSlidingWndFrame( vs_swStruct *pSlide, 
    699                                            uint8_t channel, 
    700                                            uint8_t seqnumber ) 
    701          {
   \                     vs_removeSlidingWndFrame:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0300               MOVS     R3,R0
    702            int i;
    703            
    704            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
   \                     ??vs_removeSlidingWndFrame_0:
   \   00000008   0A2C               CMP      R4,#+10
   \   0000000A   27DA               BGE      ??vs_removeSlidingWndFrame_1
    705              if ( ( 0 != pSlide->Frames[ i ].timestamp ) &&
    706          					( channel == pSlide->Frames[ i ].frame.channel ) &&
    707          					( seqnumber == pSlide->Frames[ i ].frame.seqnumber ) ) {
   \   0000000C   1C20               MOVS     R0,#+28
   \   0000000E   6043               MULS     R0,R4,R0
   \   00000010   1818               ADDS     R0,R3,R0
   \   00000012   C068               LDR      R0,[R0, #+12]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   1FD0               BEQ      ??vs_removeSlidingWndFrame_2
   \   00000018   1C20               MOVS     R0,#+28
   \   0000001A   6043               MULS     R0,R4,R0
   \   0000001C   1818               ADDS     R0,R3,R0
   \   0000001E   807C               LDRB     R0,[R0, #+18]
   \   00000020   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000022   090E               LSRS     R1,R1,#+24
   \   00000024   8142               CMP      R1,R0
   \   00000026   17D1               BNE      ??vs_removeSlidingWndFrame_2
   \   00000028   1C20               MOVS     R0,#+28
   \   0000002A   6043               MULS     R0,R4,R0
   \   0000002C   1818               ADDS     R0,R3,R0
   \   0000002E   C07C               LDRB     R0,[R0, #+19]
   \   00000030   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000032   120E               LSRS     R2,R2,#+24
   \   00000034   8242               CMP      R2,R0
   \   00000036   0FD1               BNE      ??vs_removeSlidingWndFrame_2
    708                pSlide->Frames[ i ].timestamp = 0;
   \   00000038   1C20               MOVS     R0,#+28
   \   0000003A   6043               MULS     R0,R4,R0
   \   0000003C   1818               ADDS     R0,R3,R0
   \   0000003E   0025               MOVS     R5,#+0
   \   00000040   C560               STR      R5,[R0, #+12]
    709                pSlide->Frames[ i ].send_count = 0;
   \   00000042   1C20               MOVS     R0,#+28
   \   00000044   6043               MULS     R0,R4,R0
   \   00000046   1818               ADDS     R0,R3,R0
   \   00000048   2630               ADDS     R0,R0,#+38
   \   0000004A   0025               MOVS     R5,#+0
   \   0000004C   0570               STRB     R5,[R0, #+0]
    710                pSlide->cntOutstanding--; // Another frame removed
   \   0000004E   1878               LDRB     R0,[R3, #+0]
   \   00000050   401E               SUBS     R0,R0,#+1
   \   00000052   1870               STRB     R0,[R3, #+0]
    711                return TRUE;      
   \   00000054   0120               MOVS     R0,#+1
   \   00000056   02E0               B        ??vs_removeSlidingWndFrame_3
    712              }
    713            }  
   \                     ??vs_removeSlidingWndFrame_2:
   \   00000058   641C               ADDS     R4,R4,#+1
   \   0000005A   D5E7               B        ??vs_removeSlidingWndFrame_0
    714            
    715            return FALSE;
   \                     ??vs_removeSlidingWndFrame_1:
   \   0000005C   0020               MOVS     R0,#+0
   \                     ??vs_removeSlidingWndFrame_3:
   \   0000005E   38BC               POP      {R3-R5}
   \   00000060   02BC               POP      {R1}
   \   00000062   0847               BX       R1               ;; return
    716          }
    717          
    718          
    719          ///////////////////////////////////////////////////////////////////////////////
    720          // vs_timeoutSlidingWndFrame
    721          //
    722          

   \                                 In section .text, align 4, keep-with-next
    723          void vs_timeoutSlidingWndFrame( vs_swStruct *pSlide, 
    724                                            uint32_t now ) 
    725          {
   \                     vs_timeoutSlidingWndFrame:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    726            int i;
    727            uint32_t diff;
    728            
    729            for ( i=0; i<VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES; i++ ) {
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0600               MOVS     R6,R0
   \                     ??vs_timeoutSlidingWndFrame_0:
   \   0000000A   0A2E               CMP      R6,#+10
   \   0000000C   3BDA               BGE      ??vs_timeoutSlidingWndFrame_1
    730          
    731          	// Skip unused positions
    732          	if ( 0 == pSlide->Frames[ i ].timestamp ) continue;
   \   0000000E   1C20               MOVS     R0,#+28
   \   00000010   7043               MULS     R0,R6,R0
   \   00000012   2018               ADDS     R0,R4,R0
   \   00000014   C068               LDR      R0,[R0, #+12]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   33D0               BEQ      ??vs_timeoutSlidingWndFrame_2
    733          
    734              diff = now - pSlide->Frames[ i ].timestamp;
   \   0000001A   1C20               MOVS     R0,#+28
   \   0000001C   7043               MULS     R0,R6,R0
   \   0000001E   2018               ADDS     R0,R4,R0
   \   00000020   C068               LDR      R0,[R0, #+12]
   \   00000022   281A               SUBS     R0,R5,R0
   \   00000024   0700               MOVS     R7,R0
    735              if ( diff > pSlide->maxtime  ) {
   \   00000026   6068               LDR      R0,[R4, #+4]
   \   00000028   B842               CMP      R0,R7
   \   0000002A   2AD2               BCS      ??vs_timeoutSlidingWndFrame_2
    736                if ( pSlide->Frames[ i ].send_count > pSlide->maxresend ) {
   \   0000002C   207A               LDRB     R0,[R4, #+8]
   \   0000002E   1C21               MOVS     R1,#+28
   \   00000030   7143               MULS     R1,R6,R1
   \   00000032   6118               ADDS     R1,R4,R1
   \   00000034   2631               ADDS     R1,R1,#+38
   \   00000036   0978               LDRB     R1,[R1, #+0]
   \   00000038   8842               CMP      R0,R1
   \   0000003A   0BD2               BCS      ??vs_timeoutSlidingWndFrame_3
    737                  // Abort sending of this frame
    738                  vs_removeSlidingWndFrame( pSlide, 
    739                                              pSlide->Frames[ i ].frame.channel,
    740                                              pSlide->Frames[ i ].frame.seqnumber );
   \   0000003C   1C20               MOVS     R0,#+28
   \   0000003E   7043               MULS     R0,R6,R0
   \   00000040   2018               ADDS     R0,R4,R0
   \   00000042   C27C               LDRB     R2,[R0, #+19]
   \   00000044   1C20               MOVS     R0,#+28
   \   00000046   7043               MULS     R0,R6,R0
   \   00000048   2018               ADDS     R0,R4,R0
   \   0000004A   817C               LDRB     R1,[R0, #+18]
   \   0000004C   2000               MOVS     R0,R4
   \   0000004E   ........           BL       vs_removeSlidingWndFrame
   \   00000052   16E0               B        ??vs_timeoutSlidingWndFrame_2
    741                }
    742                else {
    743                  // Retransmit the frame
    744                  if ( vs_sendFrame( &pSlide->Frames[ i ].frame ) ) {
   \                     ??vs_timeoutSlidingWndFrame_3:
   \   00000054   1C20               MOVS     R0,#+28
   \   00000056   7043               MULS     R0,R6,R0
   \   00000058   2018               ADDS     R0,R4,R0
   \   0000005A   1030               ADDS     R0,R0,#+16
   \   0000005C   ........           BL       vs_sendFrame
   \   00000060   0028               CMP      R0,#+0
   \   00000062   0ED0               BEQ      ??vs_timeoutSlidingWndFrame_2
    745                    pSlide->Frames[ i ].timestamp = now;
   \   00000064   1C20               MOVS     R0,#+28
   \   00000066   7043               MULS     R0,R6,R0
   \   00000068   2018               ADDS     R0,R4,R0
   \   0000006A   C560               STR      R5,[R0, #+12]
    746                    pSlide->Frames[ i ].send_count++;
   \   0000006C   1C20               MOVS     R0,#+28
   \   0000006E   7043               MULS     R0,R6,R0
   \   00000070   2018               ADDS     R0,R4,R0
   \   00000072   2630               ADDS     R0,R0,#+38
   \   00000074   0078               LDRB     R0,[R0, #+0]
   \   00000076   401C               ADDS     R0,R0,#+1
   \   00000078   1C21               MOVS     R1,#+28
   \   0000007A   7143               MULS     R1,R6,R1
   \   0000007C   6118               ADDS     R1,R4,R1
   \   0000007E   2631               ADDS     R1,R1,#+38
   \   00000080   0870               STRB     R0,[R1, #+0]
    747                  }
    748                }
    749              }
    750            }  
   \                     ??vs_timeoutSlidingWndFrame_2:
   \   00000082   761C               ADDS     R6,R6,#+1
   \   00000084   C1E7               B        ??vs_timeoutSlidingWndFrame_0
    751          }
   \                     ??vs_timeoutSlidingWndFrame_1:
   \   00000086   F8BC               POP      {R3-R7}
   \   00000088   01BC               POP      {R0}
   \   0000008A   0047               BX       R0               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   ........           DC32     vs_checksum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   ........           DC32     vs_buffer_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   ........           DC32     vs_main_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \   00000000   ........           DC32     vs_sub_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \   00000000   ........           DC32     vs_msgbuffer
    752          
    753          
    754          #endif  // Sliding winow

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     memcpy                        16
     vs_addSlidingWndFrame         24
     vs_bufferSerialByte            8
     vs_bufferSerialByteSubst      16
     vs_feed                       16
     vs_findFlyingFrame             8
     vs_findFreeFlyingFrame         8
     vs_getFrame                    8
     vs_init                        0
     vs_initSlidingWndFrames       16
     vs_removeSlidingWndFrame      16
     vs_sendAck                    16
     vs_sendCommandFrame           32
     vs_sendErrorFrame             32
     vs_sendFrame                  16
     vs_sendNack                   16
     vs_sendReplyFrame             32
     vs_sendResponse               24
     vs_timeoutSlidingWndFrame     24


   Section sizes:

     Function/Label            Bytes
     --------------            -----
     memcpy                      26
     vs_main_state                1
     vs_sub_state                 1
     vs_msgbuffer                48
     vs_buffer_cnt                1
     vs_checksum                  1
     vs_cntSlidingWndFrames       1
     vs_bufferSerialByte         34
     vs_bufferSerialByteSubst    60
     vs_init                     26
     vs_feed                    330
     vs_getFrame                 92
     vs_sendResponse            220
     vs_sendAck                  30
     vs_sendNack                 30
     vs_sendFrame               184
     vs_sendCommandFrame        212
     vs_sendErrorFrame          212
     vs_sendReplyFrame          212
     vs_initSlidingWndFrames     50
     vs_findFlyingFrame          66
     vs_findFreeFlyingFrame      70
     vs_addSlidingWndFrame      104
     vs_removeSlidingWndFrame   100
     vs_timeoutSlidingWndFrame  140
     ??DataTable45                4
     ??DataTable50                4
     ??DataTable51                4
     ??DataTable52                4
     ??DataTable53                4

 
    53 bytes in section .bss
 2 218 bytes in section .text
 
 2 192 bytes of CODE memory (+ 26 bytes shared)
    53 bytes of DATA memory

Errors: none
Warnings: none
