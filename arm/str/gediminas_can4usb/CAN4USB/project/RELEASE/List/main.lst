###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:39 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\development\gediminas\CAN4USB\project\app\main.c      #
#    Command line =  D:\development\gediminas\CAN4USB\project\app\main.c -lC  #
#                    D:\development\gediminas\CAN4USB\project\RELEASE\List\   #
#                    -lA D:\development\gediminas\CAN4USB\project\RELEASE\Lis #
#                    t\ -o D:\development\gediminas\CAN4USB\project\RELEASE\O #
#                    bj\ --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian little --cpu ARM7TDMI-S -e --fpu None           #
#                    --dlib_config "D:\Program\IAR Systems\Embedded           #
#                    Workbench 5.0\ARM\INC\DLib_Config_Normal.h" -I           #
#                    D:\development\gediminas\CAN4USB\project\ -I             #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\ma #
#                    in.lst                                                   #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\mai #
#                    n.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\development\gediminas\CAN4USB\project\app\main.c
      1          /*************************************************************************
      2           *
      3           *    Used with ICCARM and AARM.
      4           *
      5           *    (c) Copyright IAR Systems 2006
      6           *
      7           *    File name   : main.c
      8           *    Description : main module
      9           *
     10           *    History :
     11           *    1. Date        : August 26, 2006
     12           *       Author      : Stanimir Bonev
     13           *       Description : Create
     14           *
     15           *  This example project shows how to use the IAR Embedded Workbench for ARM
     16           * to develop code for the IAR STR750-SK evaluation boards. It implements USB
     17           * CDC (Communication Device Class) device and install it like a Virtual COM
     18           * port. The UART1 is used for physical implementation of the RS232 port.
     19           *
     20           * Jumpers:
     21           *  PWR_SEL   - depend of power source
     22           *  VRE       - Absence
     23           *  BOOT0     - 0
     24           *  BOOT1     - 0
     25           *
     26           *    $Revision: 18265 $
     27           *
     28           **************************************************************************/
     29          #include "includes.h"

   \                                 In section .text, align 4
   \   __??Code16?? __intrinsic __code __interwork void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
   \   00000008   3200               MOVS     R2,R6
   \   0000000A   2900               MOVS     R1,R5
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       __aeabi_memcpy
   \   00000012   2000               MOVS     R0,R4
   \   00000014   70BC               POP      {R4-R6}
   \   00000016   02BC               POP      {R1}
   \   00000018   0847               BX       R1               ;; return
     30          #include <inttypes.h>       // Set environment with setenv_vscp.bat in vscp folder
     31          #include "vscp_compiler.h"
     32          #include "vscp_projdefs.h"
     33          #include "75x_conf.h"
     34          #include "75x_lib.h"
     35          #include "systime.h"
     36          #include "delay.h"
     37          #include "vscp_serial.h"    // Set environment with setenv_vscp.bat in vscp folder
     38          #include "canusb.h"
     39          
     40          #define UART  UART_1
     41          
     42          // LED Defines
     43          #define GREEN   0
     44          #define RED     1
     45          
     46          // buffer for receive messages 

   \                                 In section .bss, align 4
     47          canmsg RxCanMsg;
   \                     RxCanMsg:
   \   00000000                      DS8 20
     48          
     49          // Serial output buffer

   \                                 In section .bss, align 4
     50          uint32_t serial_out_pos;
   \                     serial_out_pos:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     51          uint8_t serial_out_buf[ SERIAL_OUT_BUFFE_SIZE ];
   \                     serial_out_buf:
   \   00000000                      DS8 256
     52          
     53          // CAN output FIFO -- serial to CAN

   \                                 In section .bss, align 2
     54          uint16_t cntOutFrames;
   \                     cntOutFrames:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     55          uint16_t posOutFetch;
   \                     posOutFetch:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     56          uint16_t posOutPut;
   \                     posOutPut:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     57          canmsg outputFrames[ MAX_OUT_FRAMES ];
   \                     outputFrames:
   \   00000000                      DS8 320
     58          
     59          // CAN input FIFO -- CAN to serial

   \                                 In section .bss, align 2
     60          uint16_t cntInFrames;
   \                     cntInFrames:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     61          uint16_t posInFetch;
   \                     posInFetch:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     62          uint16_t posInPut;
   \                     posInPut:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     63          canmsg inputFrames[ MAX_IN_FRAMES ];
   \                     inputFrames:
   \   00000000                      DS8 320
     64          
     65          // Sliding Windows on serial channel

   \                                 In section .bss, align 1
     66          uint8_t lastAck;  // Sequence # for last ACK'ed frame
   \                     lastAck:
   \   00000000                      DS8 1
     67          
     68          // Statistics

   \                                 In section .bss, align 4
     69          uint32_t cntSentFrames;
   \                     cntSentFrames:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          uint32_t cntReceivedFrames;
   \                     cntReceivedFrames:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     71          uint32_t cntSentData;
   \                     cntSentData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     72          uint32_t cntReceivedData;
   \                     cntReceivedData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     73          uint32_t cntBusWarnings;
   \                     cntBusWarnings:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     74          uint32_t cntBusOff;
   \                     cntBusOff:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     75          uint32_t cntReceiveOverruns;  // Lost RX frames
   \                     cntReceiveOverruns:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     76          uint32_t cntTransmitOverruns; // Lost TX frames
   \                     cntTransmitOverruns:
   \   00000000                      DS8 4
     77          
     78          // error states

   \                                 In section .bss, align 4
     79          volatile BOOL bBusOff;
   \                     bBusOff:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     80          volatile BOOL bBusWarn;
   \                     bBusWarn:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     81          volatile BOOL bErrorPassive;
   \                     bErrorPassive:
   \   00000000                      DS8 4
     82          
     83          // blink

   \                                 In section .bss, align 4
     84          uint32_t blink_state_time = 0;
   \                     blink_state_time:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     85          uint8_t blink_state = 0;
   \                     blink_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     86          uint8_t blink_type = LED_OFF;
   \                     blink_type:
   \   00000000                      DS8 1
     87          
     88          // last read CAN traceiver status

   \                                 In section .bss, align 1
     89          volatile uint8_t canstatus;
   \                     canstatus:
   \   00000000                      DS8 1
     90          
     91          // Sliding window CAN receive

   \                                 In section .bss, align 4
     92          vs_swFrameStruct swReceiveFrames[ VSCP_SERIAL_MAX_SLIDING_WINDOW_FRAMES ];
   \                     swReceiveFrames:
   \   00000000                      DS8 280

   \                                 In section .bss, align 4
     93          vs_swStruct swReceive;
   \                     swReceive:
   \   00000000                      DS8 292
     94          
     95          // used message object numbers 
     96          #define CAN_TX_MSGOBJ       0
     97          #define CAN_RX_MSGOBJ0      1
     98          
     99          // CAN Adapter varaible

   \                                 In section .bss, align 4
    100          BOOL CANAdapter_bOpen = FALSE;              // No open
   \                     CANAdapter_bOpen:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          BOOL CANAdapter_bSendErrorFrames = FALSE;   // No error frames as default
   \                     CANAdapter_bSendErrorFrames:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    102          uint8_t CANAdapter_modeOpen;
   \                     CANAdapter_modeOpen:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    103          volatile uint8_t CANAdapter_stateChange = TRUE;
   \                     CANAdapter_stateChange:
   \   00000000   01                 DC8 1
    104          
    105          // array of pre-defined transmit messages 

   \                                 In section .data, align 4
    106          canmsg TxCanMsg[3] = {
   \                     TxCanMsg:
   \   00000000   000000002301       DC32 0, 291
   \              0000        
   \   00000008   040102040800       DC8 4, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \   00000014   000000000007       DC32 0, 1792
   \              0000        
   \   0000001C   04AA55AA5500       DC8 4, 170, 85, 170, 85, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \   00000028   010000007856       DC32 1, 305419896
   \              3412        
   \   00000030   081011121314       DC8 8, 16, 17, 18, 19, 20, 21, 22, 23, 0, 0, 0
   \              151617000000
    107            { CAN_STD_ID,      0x123, 4, { 0x01, 0x02, 0x04, 0x08 } },
    108            { CAN_STD_ID,      0x700, 4, { 0xAA, 0x55, 0xAA, 0x55 } },
    109            { CAN_EXT_ID, 0x12345678, 8, { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 } }
    110          };
    111          
    112          // Prototypes
    113          void InitClock ( void );
    114          volatile uint32_t DlyCount;
    115          void InitDlyTimer( uint32_t IntrPriority );
    116          void Dly100us( void *arg );
    117          void IO_Init( void );
    118          void init_CAN( void );
    119          void sendMessage( void );
    120          void CAN_ISR( void );
    121          void ledOn( uint8_t nled );
    122          void LedOff( uint8_t nled );
    123          void setBlinkType( uint8_t type  );
    124          void blink( void );
    125          void sendMessage( void );
    126          Boolean UsbCdcWriteTimeout( uint8_t *Buffer, uint16_t count, uint32_t timeout );
    127          
    128          /*************************************************************************
    129           * Function Name: InitClock
    130           * Parameters: none
    131           *
    132           * Return: none
    133           *
    134           * Description: Init MCU clock
    135           *
    136           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    137          void InitClock ( void )
    138          {
   \                     InitClock:
   \   00000000   01B5               PUSH     {R0,LR}
    139            // Clock
    140            // MRCC system reset(for debug purpose)
    141            MRCC_DeInit();
   \   00000002   ........           BL       MRCC_DeInit
    142            
    143            // Wait for OSC4M start-up
    144            MRCC_WaitForOSC4MStartUp();
   \   00000006   ........           BL       MRCC_WaitForOSC4MStartUp
    145            
    146            // Set HCLK = 64
    147            MRCC_HCLKConfig( MRCC_CKSYS_Div1 ); // Original div 1  60 MHZ 30
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   ........           BL       MRCC_HCLKConfig
    148            
    149            // Set CKTIM = 16 (TB clock etc)
    150            MRCC_CKTIMConfig( MRCC_HCLK_Div4 ); // Original div 1  60 MHZ 15
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   ........           BL       MRCC_CKTIMConfig
    151            
    152            // Set PCLK = 8
    153            MRCC_PCLKConfig( MRCC_CKTIM_Div2 ); // Original div 2  30 MHz 7.5
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   ........           BL       MRCC_PCLKConfig
    154            
    155            // Set CKSYS
    156            MRCC_CKSYSConfig( MRCC_CKSYS_OSC4MPLL, MRCC_PLL_Mul_16 ); // Original 15
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   0320               MOVS     R0,#+3
   \   00000020   ........           BL       MRCC_CKSYSConfig
    157            
    158            // GPIO pins optimized for 3V3 operation
    159            MRCC_IOVoltageRangeConfig( MRCC_IOVoltageRange_3V3 );
   \   00000024   8020               MOVS     R0,#+128
   \   00000026   4002               LSLS     R0,R0,#+9        ;; #+65536
   \   00000028   ........           BL       MRCC_IOVoltageRangeConfig
    160          }
   \   0000002C   08BC               POP      {R3}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
    161          

   \                                 In section .bss, align 4
    162          volatile uint32_t DlyCount;
   \                     DlyCount:
   \   00000000                      DS8 4
    163          /*************************************************************************
    164           * Function Name: Tim0Handler
    165           * Parameters: none
    166           *
    167           * Return: none
    168           *
    169           * Description: Timer 0 interrupt handler
    170           *
    171           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    172          void Tim0Handler (void)
    173          {
   \                     Tim0Handler:
   \   00000000   01B5               PUSH     {R0,LR}
    174            if ( DlyCount ) {
   \   00000002   ....               LDR      R0,??DataTable9  ;; DlyCount
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   04D0               BEQ      ??Tim0Handler_0
    175              --DlyCount;
   \   0000000A   ....               LDR      R0,??DataTable9  ;; DlyCount
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   ....               LDR      R1,??DataTable9  ;; DlyCount
   \   00000012   0860               STR      R0,[R1, #+0]
    176            }
    177            
    178            // Clear the Update pending Bit
    179            TIM_ClearITPendingBit( TIM0, TIM_IT_Update );
   \                     ??Tim0Handler_0:
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   00000018   ........           BL       TIM_ClearITPendingBit
    180          }
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    181          
    182          /*************************************************************************
    183           * Function Name: InitDlyTimer
    184           * Parameters: Int32U IntrPriority
    185           *
    186           * Return: none
    187           *
    188           * Description: Init Delay Timer (TIM 0)
    189           *
    190           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    191          void InitDlyTimer( uint32_t IntrPriority )
    192          {
   \                     InitDlyTimer:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   90B0               SUB      SP,SP,#+64
   \   00000004   0400               MOVS     R4,R0
    193            MRCC_ClocksTypeDef MRCC_Clocks;
    194            TIM_InitTypeDef TIM_InitStructure;
    195            EIC_IRQInitTypeDef EIC_IRQInitStructure;
    196          
    197            // Enable TIM0 clocks
    198            MRCC_PeripheralClockConfig(MRCC_Peripheral_TIM0, ENABLE);
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   0420               MOVS     R0,#+4
   \   0000000A   ........           BL       MRCC_PeripheralClockConfig
    199            
    200            // Release TIM0 reset
    201            MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM0,DISABLE);
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0420               MOVS     R0,#+4
   \   00000012   ........           BL       MRCC_PeripheralSWResetConfig
    202          
    203            // Timer 0
    204            // TIM Configuration in Output Compare Timing Mode period 100us
    205            // Calculate counter value
    206            MRCC_GetClocksStatus(&MRCC_Clocks);
   \   00000016   0AA8               ADD      R0,SP,#+40
   \   00000018   ........           BL       MRCC_GetClocksStatus
    207          
    208            TIM_InitStructure.TIM_Period = ( MRCC_Clocks.CKTIM_Frequency / 10000 );
   \   0000001C   0E98               LDR      R0,[SP, #+56]
   \   0000001E   1449               LDR      R1,??InitDlyTimer_0  ;; 0x2710
   \   00000020   ........           BL       __aeabi_uidivmod
   \   00000024   01A9               ADD      R1,SP,#+4
   \   00000026   4881               STRH     R0,[R1, #+10]
    209            TIM_InitStructure.TIM_Prescaler = 0;
   \   00000028   01A8               ADD      R0,SP,#+4
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   4180               STRH     R1,[R0, #+2]
    210            TIM_InitStructure.TIM_Mode = TIM_Mode_OCTiming;
   \   0000002E   6846               MOV      R0,SP
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   8180               STRH     R1,[R0, #+4]
    211            TIM_InitStructure.TIM_ClockSource = TIM_ClockSource_Internal;
   \   00000034   01A8               ADD      R0,SP,#+4
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   8180               STRH     R1,[R0, #+4]
    212            TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000003A   01A8               ADD      R0,SP,#+4
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   0181               STRH     R1,[R0, #+8]
    213            TIM_InitStructure.TIM_Channel = TIM_Channel_2;
   \   00000040   01A8               ADD      R0,SP,#+4
   \   00000042   0221               MOVS     R1,#+2
   \   00000044   8181               STRH     R1,[R0, #+12]
    214            TIM_Init( TIM0, &TIM_InitStructure );
   \   00000046   01A9               ADD      R1,SP,#+4
   \   00000048   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   0000004A   ........           BL       TIM_Init
    215          
    216            // Enable and configure the priority of the TIM0 Output compare IRQ Channel
    217            EIC_IRQInitStructure.EIC_IRQChannel = TIM0_UP_IRQChannel;
   \   0000004E   6846               MOV      R0,SP
   \   00000050   0C21               MOVS     R1,#+12
   \   00000052   0170               STRB     R1,[R0, #+0]
    218            EIC_IRQInitStructure.EIC_IRQChannelPriority = IntrPriority;
   \   00000054   6846               MOV      R0,SP
   \   00000056   2100               MOVS     R1,R4
   \   00000058   4170               STRB     R1,[R0, #+1]
    219            EIC_IRQInitStructure.EIC_IRQChannelCmd = ENABLE;
   \   0000005A   6846               MOV      R0,SP
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   8170               STRB     R1,[R0, #+2]
    220            EIC_IRQInit( &EIC_IRQInitStructure );
   \   00000060   6846               MOV      R0,SP
   \   00000062   ........           BL       EIC_IRQInit
    221          }
   \   00000066   10B0               ADD      SP,SP,#+64
   \   00000068   10BC               POP      {R4}
   \   0000006A   01BC               POP      {R0}
   \   0000006C   0047               BX       R0               ;; return
   \   0000006E   C046               Nop      
   \                     ??InitDlyTimer_0:
   \   00000070   10270000           DC32     0x2710
    222          
    223          /*************************************************************************
    224           * Function Name: Dly100us
    225           * Parameters: void *arg
    226           *
    227           * Return: none
    228           *
    229           * Description: Delay 100us * arg
    230           *
    231           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    232          void Dly100us( void *arg )
    233          {
   \                     Dly100us:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    234            DlyCount = (uint32_t)arg;
   \   00000004   ....               LDR      R0,??DataTable9  ;; DlyCount
   \   00000006   0460               STR      R4,[R0, #+0]
    235          
    236            // Clear TIM0 flags
    237            TIM_ClearFlag( TIM0, TIM_FLAG_Update );
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   0000000C   ........           BL       TIM_ClearFlag
    238          
    239            // Enable TIM0 Update interrupt
    240            TIM_ITConfig( TIM0, TIM_IT_Update, ENABLE );
   \   00000010   0122               MOVS     R2,#+1
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   00000016   ........           BL       TIM_ITConfig
    241          
    242            // Enable TIM0 counter
    243            TIM_Cmd( TIM0, ENABLE );
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   0000001E   ........           BL       TIM_Cmd
    244            
    245            while ( DlyCount > 0 );
   \                     ??Dly100us_0:
   \   00000022   ....               LDR      R0,??DataTable9  ;; DlyCount
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   0028               CMP      R0,#+0
   \   00000028   FBD1               BNE      ??Dly100us_0
    246          
    247            // Disable TIM0 Update interrupt
    248            TIM_ITConfig( TIM0, TIM_IT_Update, DISABLE );
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   00000030   ........           BL       TIM_ITConfig
    249          
    250            // Disable TIM0 counter
    251            TIM_Cmd( TIM0, DISABLE );
   \   00000034   0021               MOVS     R1,#+0
   \   00000036   ....               LDR      R0,??DataTable11  ;; 0xffff8c00
   \   00000038   ........           BL       TIM_Cmd
    252          }
   \   0000003C   10BC               POP      {R4}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
    253          
    254          
    255          
    256          ///////////////////////////////////////////////////////////////////////////////
    257          // IO_Init
    258          //
    259          

   \                                 In section .text, align 4, keep-with-next
    260          void IO_Init( void )
    261          {
   \                     IO_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    262            GPIO_InitTypeDef  GPIO_InitStructure;
    263            GPIO_InitTypeDef  CAN_RX;
    264            GPIO_InitTypeDef  CAN_TX;
    265            
    266            GPIO_StructInit( &GPIO_InitStructure );
   \   00000004   6846               MOV      R0,SP
   \   00000006   ........           BL       GPIO_StructInit
    267            GPIO_StructInit( &CAN_TX );
   \   0000000A   02A8               ADD      R0,SP,#+8
   \   0000000C   ........           BL       GPIO_StructInit
    268            GPIO_StructInit( &CAN_RX );
   \   00000010   04A8               ADD      R0,SP,#+16
   \   00000012   ........           BL       GPIO_StructInit
    269          
    270            // Enable GPIO clocks + CAN clocks
    271            MRCC_PeripheralClockConfig( MRCC_Peripheral_GPIO | MRCC_Peripheral_CAN, 
    272                                          ENABLE );
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   1F48               LDR      R0,??IO_Init_0   ;; 0x1010000
   \   0000001A   ........           BL       MRCC_PeripheralClockConfig
    273            
    274            // Release GPIO reset
    275            MRCC_PeripheralSWResetConfig( MRCC_Peripheral_GPIO, DISABLE );
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   8020               MOVS     R0,#+128
   \   00000022   4004               LSLS     R0,R0,#+17       ;; #+16777216
   \   00000024   ........           BL       MRCC_PeripheralSWResetConfig
    276          
    277            // IO configure 
    278            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000028   6846               MOV      R0,SP
   \   0000002A   0621               MOVS     R1,#+6
   \   0000002C   0171               STRB     R1,[R0, #+4]
    279            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;
   \   0000002E   0620               MOVS     R0,#+6
   \   00000030   0090               STR      R0,[SP, #+0]
    280            GPIO_Init( GPIO0, &GPIO_InitStructure );
   \   00000032   6946               MOV      R1,SP
   \   00000034   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000036   ........           BL       GPIO_Init
    281            
    282            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000003A   6846               MOV      R0,SP
   \   0000003C   0621               MOVS     R1,#+6
   \   0000003E   0171               STRB     R1,[R0, #+4]
    283            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 
   \   00000040   0120               MOVS     R0,#+1
   \   00000042   0090               STR      R0,[SP, #+0]
    284            GPIO_Init( GPIO1, &GPIO_InitStructure );
   \   00000044   6946               MOV      R1,SP
   \   00000046   1548               LDR      R0,??IO_Init_0+0x4  ;; 0xffffe440
   \   00000048   ........           BL       GPIO_Init
    285            
    286            // CAN TX
    287            CAN_TX.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000004C   02A8               ADD      R0,SP,#+8
   \   0000004E   0821               MOVS     R1,#+8
   \   00000050   0171               STRB     R1,[R0, #+4]
    288            CAN_TX.GPIO_Pin = GPIO_Pin_15;
   \   00000052   8020               MOVS     R0,#+128
   \   00000054   0002               LSLS     R0,R0,#+8        ;; #+32768
   \   00000056   0290               STR      R0,[SP, #+8]
    289            GPIO_Init( GPIO0, &CAN_TX );
   \   00000058   02A9               ADD      R1,SP,#+8
   \   0000005A   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   0000005C   ........           BL       GPIO_Init
    290          
    291            // CAN RX
    292            CAN_RX.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000060   04A8               ADD      R0,SP,#+16
   \   00000062   0221               MOVS     R1,#+2
   \   00000064   0171               STRB     R1,[R0, #+4]
    293            CAN_RX.GPIO_Pin = GPIO_Pin_14;
   \   00000066   8020               MOVS     R0,#+128
   \   00000068   C001               LSLS     R0,R0,#+7        ;; #+16384
   \   0000006A   0490               STR      R0,[SP, #+16]
    294            GPIO_Init( GPIO0, &CAN_RX );
   \   0000006C   04A9               ADD      R1,SP,#+16
   \   0000006E   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000070   ........           BL       GPIO_Init
    295            
    296            GPIO_WriteBit( GPIO0, GPIO_Pin_1, Bit_RESET );  // Turn LED off (Red)
   \   00000074   0022               MOVS     R2,#+0
   \   00000076   0221               MOVS     R1,#+2
   \   00000078   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   0000007A   ........           BL       GPIO_WriteBit
    297            GPIO_WriteBit( GPIO0, GPIO_Pin_2, Bit_SET );    // Turn LED on (Green)
   \   0000007E   0122               MOVS     R2,#+1
   \   00000080   0421               MOVS     R1,#+4
   \   00000082   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000084   ........           BL       GPIO_WriteBit
    298            GPIO_WriteBit( GPIO1, GPIO_Pin_0, Bit_RESET );  // USB reset  
   \   00000088   0022               MOVS     R2,#+0
   \   0000008A   0121               MOVS     R1,#+1
   \   0000008C   0348               LDR      R0,??IO_Init_0+0x4  ;; 0xffffe440
   \   0000008E   ........           BL       GPIO_WriteBit
    299          }
   \   00000092   07B0               ADD      SP,SP,#+28
   \   00000094   01BC               POP      {R0}
   \   00000096   0047               BX       R0               ;; return
   \                     ??IO_Init_0:
   \   00000098   00000101           DC32     0x1010000
   \   0000009C   40E4FFFF           DC32     0xffffe440
    300          
    301          ///////////////////////////////////////////////////////////////////////////////
    302          // ledOn
    303          //
    304          

   \                                 In section .text, align 4, keep-with-next
    305          void ledOn( uint8_t nled )
    306          {
   \                     ledOn:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    307            switch ( nled ) {
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   07D0               BEQ      ??ledOn_0
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   0AD1               BNE      ??ledOn_1
    308              case RED:   GPIO_WriteBit( GPIO0, GPIO_Pin_1, Bit_SET );  
   \                     ??ledOn_2:
   \   00000012   0122               MOVS     R2,#+1
   \   00000014   0221               MOVS     R1,#+2
   \   00000016   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000018   ........           BL       GPIO_WriteBit
   \   0000001C   04E0               B        ??ledOn_1
    309                break;
    310              case GREEN: GPIO_WriteBit( GPIO0, GPIO_Pin_2, Bit_SET );  
   \                     ??ledOn_0:
   \   0000001E   0122               MOVS     R2,#+1
   \   00000020   0421               MOVS     R1,#+4
   \   00000022   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000024   ........           BL       GPIO_WriteBit
    311                break;
    312            }
    313          }
   \                     ??ledOn_1:
   \   00000028   10BC               POP      {R4}
   \   0000002A   01BC               POP      {R0}
   \   0000002C   0047               BX       R0               ;; return
    314          
    315          ///////////////////////////////////////////////////////////////////////////////
    316          // ledOff
    317          //
    318          

   \                                 In section .text, align 4, keep-with-next
    319          void ledOff( uint8_t nled )
    320          {
   \                     ledOff:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    321            switch ( nled ) {
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   07D0               BEQ      ??ledOff_0
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   0AD1               BNE      ??ledOff_1
    322              case RED:   GPIO_WriteBit( GPIO0, GPIO_Pin_1, Bit_RESET );  
   \                     ??ledOff_2:
   \   00000012   0022               MOVS     R2,#+0
   \   00000014   0221               MOVS     R1,#+2
   \   00000016   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000018   ........           BL       GPIO_WriteBit
   \   0000001C   04E0               B        ??ledOff_1
    323                break;
    324              case GREEN: GPIO_WriteBit( GPIO0, GPIO_Pin_2, Bit_RESET );  
   \                     ??ledOff_0:
   \   0000001E   0022               MOVS     R2,#+0
   \   00000020   0421               MOVS     R1,#+4
   \   00000022   ....               LDR      R0,??DataTable20  ;; 0xffffe400
   \   00000024   ........           BL       GPIO_WriteBit
    325                break;
    326            }
    327          }
   \                     ??ledOff_1:
   \   00000028   10BC               POP      {R4}
   \   0000002A   01BC               POP      {R0}
   \   0000002C   0047               BX       R0               ;; return
    328          
    329          ///////////////////////////////////////////////////////////////////////////////
    330          // setBlinkType
    331          //
    332          

   \                                 In section .text, align 4, keep-with-next
    333          void setBlinkType( uint8_t type  )
    334          {
    335            blink_state_time = 0;
   \                     setBlinkType:
   \   00000000   ....               LDR      R1,??DataTable21  ;; blink_state_time
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0A60               STR      R2,[R1, #+0]
    336            blink_type = type;
   \   00000006   ....               LDR      R1,??DataTable22  ;; blink_type
   \   00000008   0870               STRB     R0,[R1, #+0]
    337            CANAdapter_stateChange = TRUE;
   \   0000000A   ....               LDR      R1,??DataTable23  ;; CANAdapter_stateChange
   \   0000000C   0122               MOVS     R2,#+1
   \   0000000E   0A70               STRB     R2,[R1, #+0]
    338          }
   \   00000010   7047               BX       LR               ;; return
    339          
    340          ///////////////////////////////////////////////////////////////////////////////
    341          // ledOff
    342          //
    343          // This routine is called from the 1 ms interrupt and blink
    344          // lamp in the selected patters
    345          //
    346          
    347          

   \                                 In section .text, align 4, keep-with-next
    348          void blink( void ) 
    349          {
   \                     blink:
   \   00000000   01B5               PUSH     {R0,LR}
    350            blink_state_time++;
   \   00000002   9248               LDR      R0,??blink_0     ;; blink_state_time
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   401C               ADDS     R0,R0,#+1
   \   00000008   9049               LDR      R1,??blink_0     ;; blink_state_time
   \   0000000A   0860               STR      R0,[R1, #+0]
    351            
    352            switch( blink_type ) {
   \   0000000C   9048               LDR      R0,??blink_0+0x4  ;; blink_type
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   13D0               BEQ      ??blink_1
   \   00000014   401E               SUBS     R0,R0,#+1
   \   00000016   18D0               BEQ      ??blink_2
   \   00000018   401E               SUBS     R0,R0,#+1
   \   0000001A   1DD0               BEQ      ??blink_3
   \   0000001C   401E               SUBS     R0,R0,#+1
   \   0000001E   22D0               BEQ      ??blink_4
   \   00000020   401E               SUBS     R0,R0,#+1
   \   00000022   49D0               BEQ      ??blink_5
   \   00000024   401E               SUBS     R0,R0,#+1
   \   00000026   6ED0               BEQ      ??blink_6
   \   00000028   401E               SUBS     R0,R0,#+1
   \   0000002A   00D1               BNE      .+4
   \   0000002C   94E0               B        ??blink_7
   \   0000002E   401E               SUBS     R0,R0,#+1
   \   00000030   00D1               BNE      .+4
   \   00000032   E0E0               B        ??blink_8
   \   00000034   401E               SUBS     R0,R0,#+1
   \   00000036   00D1               BNE      .+4
   \   00000038   B3E0               B        ??blink_9
   \   0000003A   03E1               B        ??blink_10
    353            
    354              case LED_OFF:
    355                ledOff( RED );
   \                     ??blink_1:
   \   0000003C   0120               MOVS     R0,#+1
   \   0000003E   ........           BL       ledOff
    356                ledOff( GREEN );
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   ........           BL       ledOff
   \   00000048   FCE0               B        ??blink_10
    357                break;
    358              
    359              case LED_RED_STEADY: 
    360                ledOn( RED );
   \                     ??blink_2:
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   ........           BL       ledOn
    361                ledOff( GREEN );
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   ........           BL       ledOff
   \   00000056   F5E0               B        ??blink_10
    362                break;
    363              
    364              case LED_GREEN_STEADY: 
    365                ledOn( GREEN );
   \                     ??blink_3:
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   ........           BL       ledOn
    366                ledOff( RED );
   \   0000005E   0120               MOVS     R0,#+1
   \   00000060   ........           BL       ledOff
   \   00000064   EEE0               B        ??blink_10
    367                break;
    368              
    369              case LED_RED_BLINK_FAST:
    370                ledOff( GREEN );
   \                     ??blink_4:
   \   00000066   0020               MOVS     R0,#+0
   \   00000068   ........           BL       ledOff
    371                if ( 0 == blink_state ) {
   \   0000006C   7948               LDR      R0,??blink_0+0x8  ;; blink_state
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   0028               CMP      R0,#+0
   \   00000072   10D1               BNE      ??blink_11
    372                  if (  blink_state_time > 500 ) {
   \   00000074   7548               LDR      R0,??blink_0     ;; blink_state_time
   \   00000076   0068               LDR      R0,[R0, #+0]
   \   00000078   FF21               MOVS     R1,#+255
   \   0000007A   F631               ADDS     R1,R1,#+246      ;; #+501
   \   0000007C   8842               CMP      R0,R1
   \   0000007E   00D2               BCS      .+4
   \   00000080   E0E0               B        ??blink_10
    373                    blink_state_time = 0;
   \   00000082   7248               LDR      R0,??blink_0     ;; blink_state_time
   \   00000084   0021               MOVS     R1,#+0
   \   00000086   0160               STR      R1,[R0, #+0]
    374                    ledOff( RED );
   \   00000088   0120               MOVS     R0,#+1
   \   0000008A   ........           BL       ledOff
    375                    blink_state = 1;
   \   0000008E   7148               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000090   0121               MOVS     R1,#+1
   \   00000092   0170               STRB     R1,[R0, #+0]
   \   00000094   D6E0               B        ??blink_10
    376                  }
    377                }
    378                else {
    379                  if (  blink_state_time > 500 ) {
   \                     ??blink_11:
   \   00000096   6D48               LDR      R0,??blink_0     ;; blink_state_time
   \   00000098   0068               LDR      R0,[R0, #+0]
   \   0000009A   FF21               MOVS     R1,#+255
   \   0000009C   F631               ADDS     R1,R1,#+246      ;; #+501
   \   0000009E   8842               CMP      R0,R1
   \   000000A0   00D2               BCS      .+4
   \   000000A2   CFE0               B        ??blink_10
    380                    blink_state_time = 0;
   \   000000A4   6948               LDR      R0,??blink_0     ;; blink_state_time
   \   000000A6   0021               MOVS     R1,#+0
   \   000000A8   0160               STR      R1,[R0, #+0]
    381                    ledOn( RED );
   \   000000AA   0120               MOVS     R0,#+1
   \   000000AC   ........           BL       ledOn
    382                    blink_state = 0;
   \   000000B0   6848               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000000B2   0021               MOVS     R1,#+0
   \   000000B4   0170               STRB     R1,[R0, #+0]
   \   000000B6   C5E0               B        ??blink_10
    383                  }  
    384                }
    385                break;
    386              
    387              case LED_RED_BLINK_SLOW: 
    388                ledOff( GREEN );
   \                     ??blink_5:
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   ........           BL       ledOff
    389                if ( 0 == blink_state ) {
   \   000000BE   6548               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000000C0   0078               LDRB     R0,[R0, #+0]
   \   000000C2   0028               CMP      R0,#+0
   \   000000C4   0FD1               BNE      ??blink_12
    390                  if (  blink_state_time > 1000 ) {
   \   000000C6   6148               LDR      R0,??blink_0     ;; blink_state_time
   \   000000C8   0068               LDR      R0,[R0, #+0]
   \   000000CA   6349               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   000000CC   8842               CMP      R0,R1
   \   000000CE   00D2               BCS      .+4
   \   000000D0   B8E0               B        ??blink_10
    391                    blink_state_time = 0;
   \   000000D2   5E48               LDR      R0,??blink_0     ;; blink_state_time
   \   000000D4   0021               MOVS     R1,#+0
   \   000000D6   0160               STR      R1,[R0, #+0]
    392                    ledOff( RED );
   \   000000D8   0120               MOVS     R0,#+1
   \   000000DA   ........           BL       ledOff
    393                    blink_state = 1;
   \   000000DE   5D48               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000000E0   0121               MOVS     R1,#+1
   \   000000E2   0170               STRB     R1,[R0, #+0]
   \   000000E4   AEE0               B        ??blink_10
    394                  }
    395                }
    396                else {
    397                  if (  blink_state_time > 1000 ) {
   \                     ??blink_12:
   \   000000E6   5948               LDR      R0,??blink_0     ;; blink_state_time
   \   000000E8   0068               LDR      R0,[R0, #+0]
   \   000000EA   5B49               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   000000EC   8842               CMP      R0,R1
   \   000000EE   00D2               BCS      .+4
   \   000000F0   A8E0               B        ??blink_10
    398                    blink_state_time = 0;
   \   000000F2   5648               LDR      R0,??blink_0     ;; blink_state_time
   \   000000F4   0021               MOVS     R1,#+0
   \   000000F6   0160               STR      R1,[R0, #+0]
    399                    ledOn( RED );
   \   000000F8   0120               MOVS     R0,#+1
   \   000000FA   ........           BL       ledOn
    400                    blink_state = 0;
   \   000000FE   5548               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000100   0021               MOVS     R1,#+0
   \   00000102   0170               STRB     R1,[R0, #+0]
   \   00000104   9EE0               B        ??blink_10
    401                  }  
    402                }
    403                break;
    404              
    405              case LED_GREEN_BLINK_FAST: 
    406                ledOff( RED );
   \                     ??blink_6:
   \   00000106   0120               MOVS     R0,#+1
   \   00000108   ........           BL       ledOff
    407                if ( 0 == blink_state ) {
   \   0000010C   5148               LDR      R0,??blink_0+0x8  ;; blink_state
   \   0000010E   0078               LDRB     R0,[R0, #+0]
   \   00000110   0028               CMP      R0,#+0
   \   00000112   10D1               BNE      ??blink_13
    408                  if (  blink_state_time > 500 ) {
   \   00000114   4D48               LDR      R0,??blink_0     ;; blink_state_time
   \   00000116   0068               LDR      R0,[R0, #+0]
   \   00000118   FF21               MOVS     R1,#+255
   \   0000011A   F631               ADDS     R1,R1,#+246      ;; #+501
   \   0000011C   8842               CMP      R0,R1
   \   0000011E   00D2               BCS      .+4
   \   00000120   90E0               B        ??blink_10
    409                    blink_state_time = 0;
   \   00000122   4A48               LDR      R0,??blink_0     ;; blink_state_time
   \   00000124   0021               MOVS     R1,#+0
   \   00000126   0160               STR      R1,[R0, #+0]
    410                    ledOff( GREEN );
   \   00000128   0020               MOVS     R0,#+0
   \   0000012A   ........           BL       ledOff
    411                    blink_state = 1;
   \   0000012E   4948               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000130   0121               MOVS     R1,#+1
   \   00000132   0170               STRB     R1,[R0, #+0]
   \   00000134   86E0               B        ??blink_10
    412                  }
    413                }
    414                else {
    415                  if (  blink_state_time > 500 ) {
   \                     ??blink_13:
   \   00000136   4548               LDR      R0,??blink_0     ;; blink_state_time
   \   00000138   0068               LDR      R0,[R0, #+0]
   \   0000013A   FF21               MOVS     R1,#+255
   \   0000013C   F631               ADDS     R1,R1,#+246      ;; #+501
   \   0000013E   8842               CMP      R0,R1
   \   00000140   00D2               BCS      .+4
   \   00000142   7FE0               B        ??blink_10
    416                    blink_state_time = 0;
   \   00000144   4148               LDR      R0,??blink_0     ;; blink_state_time
   \   00000146   0021               MOVS     R1,#+0
   \   00000148   0160               STR      R1,[R0, #+0]
    417                    ledOn( GREEN );
   \   0000014A   0020               MOVS     R0,#+0
   \   0000014C   ........           BL       ledOn
    418                    blink_state = 0;
   \   00000150   4048               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000152   0021               MOVS     R1,#+0
   \   00000154   0170               STRB     R1,[R0, #+0]
   \   00000156   75E0               B        ??blink_10
    419                  }  
    420                }
    421                break;
    422              
    423              case LED_GREEN_BLINK_SLOW: 
    424                ledOff( RED );
   \                     ??blink_7:
   \   00000158   0120               MOVS     R0,#+1
   \   0000015A   ........           BL       ledOff
    425                if ( 0 == blink_state ) {
   \   0000015E   3D48               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000160   0078               LDRB     R0,[R0, #+0]
   \   00000162   0028               CMP      R0,#+0
   \   00000164   0ED1               BNE      ??blink_14
    426                  if (  blink_state_time > 1000 ) {
   \   00000166   3948               LDR      R0,??blink_0     ;; blink_state_time
   \   00000168   0068               LDR      R0,[R0, #+0]
   \   0000016A   3B49               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   0000016C   8842               CMP      R0,R1
   \   0000016E   69D3               BCC      ??blink_10
    427                    blink_state_time = 0;
   \   00000170   3648               LDR      R0,??blink_0     ;; blink_state_time
   \   00000172   0021               MOVS     R1,#+0
   \   00000174   0160               STR      R1,[R0, #+0]
    428                    ledOff( GREEN );
   \   00000176   0020               MOVS     R0,#+0
   \   00000178   ........           BL       ledOff
    429                    blink_state = 1;
   \   0000017C   3548               LDR      R0,??blink_0+0x8  ;; blink_state
   \   0000017E   0121               MOVS     R1,#+1
   \   00000180   0170               STRB     R1,[R0, #+0]
   \   00000182   5FE0               B        ??blink_10
    430                  }
    431                }
    432                else {
    433                  if (  blink_state_time > 1000 ) {
   \                     ??blink_14:
   \   00000184   3148               LDR      R0,??blink_0     ;; blink_state_time
   \   00000186   0068               LDR      R0,[R0, #+0]
   \   00000188   3349               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   0000018A   8842               CMP      R0,R1
   \   0000018C   5AD3               BCC      ??blink_10
    434                    blink_state_time = 0;
   \   0000018E   2F48               LDR      R0,??blink_0     ;; blink_state_time
   \   00000190   0021               MOVS     R1,#+0
   \   00000192   0160               STR      R1,[R0, #+0]
    435                    ledOn( GREEN );
   \   00000194   0020               MOVS     R0,#+0
   \   00000196   ........           BL       ledOn
    436                    blink_state = 0;
   \   0000019A   2E48               LDR      R0,??blink_0+0x8  ;; blink_state
   \   0000019C   0021               MOVS     R1,#+0
   \   0000019E   0170               STRB     R1,[R0, #+0]
   \   000001A0   50E0               B        ??blink_10
    437                  }  
    438                }
    439                break;
    440              
    441              case LED_RED_GREEN_BLINK_FAST:
    442                if ( 0 == blink_state ) {
   \                     ??blink_9:
   \   000001A2   2C48               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000001A4   0078               LDRB     R0,[R0, #+0]
   \   000001A6   0028               CMP      R0,#+0
   \   000001A8   12D1               BNE      ??blink_15
    443                  if (  blink_state_time > 500 ) {
   \   000001AA   2848               LDR      R0,??blink_0     ;; blink_state_time
   \   000001AC   0068               LDR      R0,[R0, #+0]
   \   000001AE   FF21               MOVS     R1,#+255
   \   000001B0   F631               ADDS     R1,R1,#+246      ;; #+501
   \   000001B2   8842               CMP      R0,R1
   \   000001B4   46D3               BCC      ??blink_10
    444                    blink_state_time = 0;
   \   000001B6   2548               LDR      R0,??blink_0     ;; blink_state_time
   \   000001B8   0021               MOVS     R1,#+0
   \   000001BA   0160               STR      R1,[R0, #+0]
    445                    ledOff( RED );
   \   000001BC   0120               MOVS     R0,#+1
   \   000001BE   ........           BL       ledOff
    446                    ledOn( GREEN );
   \   000001C2   0020               MOVS     R0,#+0
   \   000001C4   ........           BL       ledOn
    447                    blink_state = 1;
   \   000001C8   2248               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000001CA   0121               MOVS     R1,#+1
   \   000001CC   0170               STRB     R1,[R0, #+0]
   \   000001CE   39E0               B        ??blink_10
    448                  }
    449                }
    450                else {
    451                  if (  blink_state_time > 500 ) {
   \                     ??blink_15:
   \   000001D0   1E48               LDR      R0,??blink_0     ;; blink_state_time
   \   000001D2   0068               LDR      R0,[R0, #+0]
   \   000001D4   FF21               MOVS     R1,#+255
   \   000001D6   F631               ADDS     R1,R1,#+246      ;; #+501
   \   000001D8   8842               CMP      R0,R1
   \   000001DA   33D3               BCC      ??blink_10
    452                    blink_state_time = 0;
   \   000001DC   1B48               LDR      R0,??blink_0     ;; blink_state_time
   \   000001DE   0021               MOVS     R1,#+0
   \   000001E0   0160               STR      R1,[R0, #+0]
    453                    ledOff( GREEN );
   \   000001E2   0020               MOVS     R0,#+0
   \   000001E4   ........           BL       ledOff
    454                    ledOn( RED );
   \   000001E8   0120               MOVS     R0,#+1
   \   000001EA   ........           BL       ledOn
    455                    blink_state = 0;
   \   000001EE   1948               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000001F0   0021               MOVS     R1,#+0
   \   000001F2   0170               STRB     R1,[R0, #+0]
   \   000001F4   26E0               B        ??blink_10
    456                  }  
    457                }
    458                break;
    459                
    460              case LED_RED_GREEN_BLINK_SLOW:
    461                if ( 0 == blink_state ) {
   \                     ??blink_8:
   \   000001F6   1748               LDR      R0,??blink_0+0x8  ;; blink_state
   \   000001F8   0078               LDRB     R0,[R0, #+0]
   \   000001FA   0028               CMP      R0,#+0
   \   000001FC   11D1               BNE      ??blink_16
    462                  if (  blink_state_time > 1000 ) {
   \   000001FE   1348               LDR      R0,??blink_0     ;; blink_state_time
   \   00000200   0068               LDR      R0,[R0, #+0]
   \   00000202   1549               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   00000204   8842               CMP      R0,R1
   \   00000206   1DD3               BCC      ??blink_10
    463                    blink_state_time = 0;
   \   00000208   1048               LDR      R0,??blink_0     ;; blink_state_time
   \   0000020A   0021               MOVS     R1,#+0
   \   0000020C   0160               STR      R1,[R0, #+0]
    464                    ledOff( RED );
   \   0000020E   0120               MOVS     R0,#+1
   \   00000210   ........           BL       ledOff
    465                    ledOn( GREEN );
   \   00000214   0020               MOVS     R0,#+0
   \   00000216   ........           BL       ledOn
    466                    blink_state = 1;
   \   0000021A   0E48               LDR      R0,??blink_0+0x8  ;; blink_state
   \   0000021C   0121               MOVS     R1,#+1
   \   0000021E   0170               STRB     R1,[R0, #+0]
   \   00000220   10E0               B        ??blink_10
    467                  }
    468                }
    469                else {
    470                  if (  blink_state_time > 1000 ) {
   \                     ??blink_16:
   \   00000222   0A48               LDR      R0,??blink_0     ;; blink_state_time
   \   00000224   0068               LDR      R0,[R0, #+0]
   \   00000226   0C49               LDR      R1,??blink_0+0xC  ;; 0x3e9
   \   00000228   8842               CMP      R0,R1
   \   0000022A   0BD3               BCC      ??blink_10
    471                    blink_state_time = 0;
   \   0000022C   0748               LDR      R0,??blink_0     ;; blink_state_time
   \   0000022E   0021               MOVS     R1,#+0
   \   00000230   0160               STR      R1,[R0, #+0]
    472                    ledOff( GREEN );
   \   00000232   0020               MOVS     R0,#+0
   \   00000234   ........           BL       ledOff
    473                    ledOn( RED );
   \   00000238   0120               MOVS     R0,#+1
   \   0000023A   ........           BL       ledOn
    474                    blink_state = 0;
   \   0000023E   0548               LDR      R0,??blink_0+0x8  ;; blink_state
   \   00000240   0021               MOVS     R1,#+0
   \   00000242   0170               STRB     R1,[R0, #+0]
    475                  }  
    476                }
    477                break;
    478                
    479            }
    480          }
   \                     ??blink_10:
   \   00000244   08BC               POP      {R3}
   \   00000246   01BC               POP      {R0}
   \   00000248   0047               BX       R0               ;; return
   \   0000024A   C046               Nop      
   \                     ??blink_0:
   \   0000024C   ........           DC32     blink_state_time
   \   00000250   ........           DC32     blink_type
   \   00000254   ........           DC32     blink_state
   \   00000258   E9030000           DC32     0x3e9
    481          
    482          ///////////////////////////////////////////////////////////////////////////////
    483          // CAN_Com_Polling
    484          //
    485          

   \                                 In section .text, align 4, keep-with-next
    486          void CAN_Com_Polling( void )
    487          {
   \                     CAN_Com_Polling:
   \   00000000   01B5               PUSH     {R0,LR}
    488          /*  
    489            CAN_InitTypeDef CAN_Struct;
    490            
    491            CAN_EnterInitMode( CAN_CR_CCE ); 
    492            
    493            // initialize the CAN at a standard bitrate, interrupts disabled 
    494            CAN_Struct.CAN_ConfigParameters=0x0;
    495            CAN_Struct.CAN_Bitrate=CAN_BITRATE_500K;
    496            CAN_Init( &CAN_Struct );
    497           
    498            // configure the message objects  
    499            CAN_InvalidateAllMsgObj();
    500            CAN_SetTxMsgObj( CAN_TX_STD_MSGOBJ, CAN_STD_ID );
    501            CAN_SetRxMsgObj( CAN_RX_MSGOBJ0, CAN_STD_ID, 0, CAN_LAST_STD_ID, TRUE );
    502            CAN_LeaveInitMode( );
    503          */
    504            // Send the pre-defined answer
    505            CAN_SendMessage( CAN_TX_MSGOBJ, &TxCanMsg[ 0 ] );
   \   00000002   0749               LDR      R1,??CAN_Com_Polling_0  ;; TxCanMsg
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       CAN_SendMessage
    506          
    507            // wait until end of transmission 
    508            CAN_WaitEndOfTx();
   \   0000000A   ........           BL       CAN_WaitEndOfTx
    509            
    510            CAN_ReleaseTxMessage( CAN_TX_MSGOBJ );
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   ........           BL       CAN_ReleaseTxMessage
    511          
    512          /* 
    513            // wait for reception of a data frame 
    514            while ( !CAN_ReceiveMessage( CAN_RX_MSGOBJ, FALSE, &RxCanMsg ) )
    515            {
    516              // Add Timer
    517            }
    518          
    519            // Test Received Msg 
    520            if ( ( RxCanMsg.IdType == CAN_STD_ID )&&
    521                ( RxCanMsg.Id == 0x321 ) && 
    522                ( RxCanMsg.Dlc == 4 ) &&
    523                ( RxCanMsg.Data[0] == 0xAA ) &&
    524                ( RxCanMsg.Data[1] == 0x55 ) &&
    525                ( RxCanMsg.Data[2] == 0xAA ) && 
    526                ( RxCanMsg.Data[3] == 0x55 ) ) {
    527              // Received Msg OK
    528              LED_ON( GREEN );
    529            } 
    530            else {
    531              // Received Msg KO
    532              LED_OFF( RED );
    533            }
    534          */
    535          
    536            // release the message objects 
    537            //CAN_ReleaseTxMessage( CAN_TX_STD_MSGOBJ );
    538            //CAN_ReleaseRxMessage( CAN_RX_MSGOBJ0 );
    539            
    540            delay_ms( 10 );
   \   00000014   0A20               MOVS     R0,#+10
   \   00000016   ........           BL       delay_ms
    541          }
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
   \                     ??CAN_Com_Polling_0:
   \   00000020   ........           DC32     TxCanMsg
    542          
    543          ///////////////////////////////////////////////////////////////////////////////
    544          // CAN_Com_IRQ
    545          //
    546          

   \                                 In section .text, align 4, keep-with-next
    547          void CAN_Com_IRQ( void )
    548          {
   \                     CAN_Com_IRQ:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    549            EIC_IRQInitTypeDef  EIC_IRQInitStructure;
    550            CAN_InitTypeDef     CAN_Struct;
    551            
    552            // initialize the interrupt controller 
    553            EIC_DeInit();
   \   00000004   ........           BL       EIC_DeInit
    554              
    555            EIC_IRQInitStructure.EIC_IRQChannel=CAN_IRQChannel;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   1621               MOVS     R1,#+22
   \   0000000C   0170               STRB     R1,[R0, #+0]
    556            EIC_IRQInitStructure.EIC_IRQChannelPriority=1;
   \   0000000E   6846               MOV      R0,SP
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   4170               STRB     R1,[R0, #+1]
    557            EIC_IRQInitStructure.EIC_IRQChannelCmd = ENABLE;
   \   00000014   6846               MOV      R0,SP
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   8170               STRB     R1,[R0, #+2]
    558            EIC_IRQInit(&EIC_IRQInitStructure);
   \   0000001A   6846               MOV      R0,SP
   \   0000001C   ........           BL       EIC_IRQInit
    559          	
    560            // initialize the CAN at a standard bitrate, interrupts enabled 
    561            CAN_Struct.CAN_ConfigParameters=CAN_CR_IE;
   \   00000020   6846               MOV      R0,SP
   \   00000022   0221               MOVS     R1,#+2
   \   00000024   0172               STRB     R1,[R0, #+8]
    562            CAN_Struct.CAN_Bitrate=CAN_BITRATE_500K;
   \   00000026   0620               MOVS     R0,#+6
   \   00000028   0390               STR      R0,[SP, #+12]
    563            CAN_Init(&CAN_Struct);
   \   0000002A   02A8               ADD      R0,SP,#+8
   \   0000002C   ........           BL       CAN_Init
    564          
    565            // configure the message objects 
    566            CAN_EnterInitMode( CAN_CR_CCE );
   \   00000030   4020               MOVS     R0,#+64
   \   00000032   ........           BL       CAN_EnterInitMode
    567            CAN_InvalidateAllMsgObj();
   \   00000036   ........           BL       CAN_InvalidateAllMsgObj
    568            CAN_SetTxMsgObj( CAN_TX_MSGOBJ, CAN_EXT_ID );
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ........           BL       CAN_SetTxMsgObj
    569            CAN_SetRxMsgObj( CAN_RX_MSGOBJ0, CAN_EXT_ID, 0, CAN_LAST_EXT_ID, TRUE );
                                                                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000042   82B0               SUB      SP,SP,#+8
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   0090               STR      R0,[SP, #+0]
   \   00000048   0E4B               LDR      R3,??CAN_Com_IRQ_0  ;; 0x1fffffff
   \   0000004A   0022               MOVS     R2,#+0
   \   0000004C   0121               MOVS     R1,#+1
   \   0000004E   0120               MOVS     R0,#+1
   \   00000050   ........           BL       CAN_SetRxMsgObj
   \   00000054   02B0               ADD      SP,SP,#+8
    570            CAN_LeaveInitMode();
   \   00000056   ........           BL       CAN_LeaveInitMode
    571            
    572            // enable global interrupt 
    573            EIC_IRQCmd( ENABLE );
   \   0000005A   0120               MOVS     R0,#+1
   \   0000005C   ........           BL       EIC_IRQCmd
    574          
    575            // Send the pre-defined frame 
    576            CAN_SendMessage( CAN_TX_MSGOBJ, &TxCanMsg[2] );
   \   00000060   0949               LDR      R1,??CAN_Com_IRQ_0+0x4  ;; TxCanMsg + 40
   \   00000062   0020               MOVS     R0,#+0
   \   00000064   ........           BL       CAN_SendMessage
    577          
    578            // wait until end of transmission 
    579            CAN_WaitEndOfTx();
   \   00000068   ........           BL       CAN_WaitEndOfTx
    580            
    581            // reception and release are done in the interrupt handler 
    582          
    583            // delay to add when the reception occurs 
    584            Int32U dly = 0xffff;
   \   0000006C   0748               LDR      R0,??CAN_Com_IRQ_0+0x8  ;; 0xffff
   \   0000006E   0190               STR      R0,[SP, #+4]
    585            Dly100us( &dly );
   \   00000070   01A8               ADD      R0,SP,#+4
   \   00000072   ........           BL       Dly100us
    586          
    587            // Test Received Msg 
    588            if ( ( RxCanMsg.IdType == CAN_EXT_ID ) && 
    589                ( RxCanMsg.Id == 0x12345678 ) &&
    590                ( RxCanMsg.Dlc == 8 ) &&
    591                ( RxCanMsg.Data[0] == 0x10 ) &&
    592                ( RxCanMsg.Data[1] == 0x11 ) &&
    593                ( RxCanMsg.Data[2] == 0x12 ) && 
    594                ( RxCanMsg.Data[3] == 0x13 ) &&
    595                ( RxCanMsg.Data[4] == 0x14 ) &&
    596                ( RxCanMsg.Data[5] == 0x15 ) &&
    597                ( RxCanMsg.Data[6] == 0x16 ) &&
    598                ( RxCanMsg.Data[7]==0x17 ) ) {
    599              // Received Msg OK
    600            } else {
    601              // Received Msg KO
    602          
    603            }
    604          
    605            // disable interrupts globally 
    606            EIC_IRQCmd( DISABLE );
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   ........           BL       EIC_IRQCmd
    607          }
   \   0000007C   05B0               ADD      SP,SP,#+20
   \   0000007E   01BC               POP      {R0}
   \   00000080   0047               BX       R0               ;; return
   \   00000082   C046               Nop      
   \                     ??CAN_Com_IRQ_0:
   \   00000084   FFFFFF1F           DC32     0x1fffffff
   \   00000088   ........           DC32     TxCanMsg + 40
   \   0000008C   FFFF0000           DC32     0xffff
    608          
    609          ///////////////////////////////////////////////////////////////////////////////
    610          // init_CAN
    611          //
    612          

   \                                 In section .text, align 4, keep-with-next
    613          void init_CAN( void )
    614          {
   \                     init_CAN:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
    615            int i;
    616            
    617            EIC_IRQInitTypeDef  EIC_IRQInitStructure;
    618            CAN_InitTypeDef     CAN_Struct;
    619            
    620            // Init output fifo
    621            cntOutFrames = 0;
   \   00000002   2F48               LDR      R0,??init_CAN_0  ;; cntOutFrames
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0180               STRH     R1,[R0, #+0]
    622            posOutFetch = 0;
   \   00000008   2E48               LDR      R0,??init_CAN_0+0x4  ;; posOutFetch
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0180               STRH     R1,[R0, #+0]
    623            posOutPut = 0;
   \   0000000E   2E48               LDR      R0,??init_CAN_0+0x8  ;; posOutPut
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0180               STRH     R1,[R0, #+0]
    624            
    625            // Init input fifo
    626            cntInFrames = 0;
   \   00000014   2D48               LDR      R0,??init_CAN_0+0xC  ;; cntInFrames
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   0180               STRH     R1,[R0, #+0]
    627            posInFetch = 0;
   \   0000001A   2D48               LDR      R0,??init_CAN_0+0x10  ;; posInFetch
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   0180               STRH     R1,[R0, #+0]
    628            posInPut = 0;
   \   00000020   2C48               LDR      R0,??init_CAN_0+0x14  ;; posInPut
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   0180               STRH     R1,[R0, #+0]
    629            
    630            // Last ACK'ed frame is none
    631            lastAck = 0;
   \   00000026   2C48               LDR      R0,??init_CAN_0+0x18  ;; lastAck
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   0170               STRB     R1,[R0, #+0]
    632            
    633            // initialize the interrupt controller 
    634            EIC_IRQInitStructure.EIC_IRQChannel = CAN_IRQChannel;
   \   0000002C   6846               MOV      R0,SP
   \   0000002E   1621               MOVS     R1,#+22
   \   00000030   0170               STRB     R1,[R0, #+0]
    635            EIC_IRQInitStructure.EIC_IRQChannelPriority = 1;
   \   00000032   6846               MOV      R0,SP
   \   00000034   0121               MOVS     R1,#+1
   \   00000036   4170               STRB     R1,[R0, #+1]
    636            EIC_IRQInitStructure.EIC_IRQChannelCmd = ENABLE;
   \   00000038   6846               MOV      R0,SP
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   8170               STRB     R1,[R0, #+2]
    637            EIC_IRQInit( &EIC_IRQInitStructure );
   \   0000003E   6846               MOV      R0,SP
   \   00000040   ........           BL       EIC_IRQInit
    638            
    639            CAN_EnterInitMode( CAN_CR_CCE );
   \   00000044   4020               MOVS     R0,#+64
   \   00000046   ........           BL       CAN_EnterInitMode
    640             
    641            // initialize the CAN at a standard bitrate, interrupts enabled 
    642            CAN_Struct.CAN_ConfigParameters = CAN_CR_IE | CAN_CR_EIE | CAN_CR_SIE;
   \   0000004A   6846               MOV      R0,SP
   \   0000004C   0E21               MOVS     R1,#+14
   \   0000004E   0171               STRB     R1,[R0, #+4]
    643            CAN_Struct.CAN_Bitrate = CAN_BITRATE_500K;
   \   00000050   0620               MOVS     R0,#+6
   \   00000052   0290               STR      R0,[SP, #+8]
    644            CAN_Init( &CAN_Struct );
   \   00000054   01A8               ADD      R0,SP,#+4
   \   00000056   ........           BL       CAN_Init
    645            
    646            // configure the message objects 
    647            CAN_InvalidateAllMsgObj();
   \   0000005A   ........           BL       CAN_InvalidateAllMsgObj
    648            
    649            // Configure the standard id transmit object
    650            CAN_SetTxMsgObj( CAN_TX_MSGOBJ, CAN_STD_ID );
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   ........           BL       CAN_SetTxMsgObj
    651            
    652            // Configure the extended id transmit object
    653            CAN_SetTxMsgObj( CAN_TX_MSGOBJ + 1, CAN_EXT_ID );
   \   00000066   0121               MOVS     R1,#+1
   \   00000068   0120               MOVS     R0,#+1
   \   0000006A   ........           BL       CAN_SetTxMsgObj
    654            
    655            // Configure receive objects
    656            for ( i=2; i<15; i++ ) {
   \   0000006E   0220               MOVS     R0,#+2
   \   00000070   0400               MOVS     R4,R0
   \                     ??init_CAN_1:
   \   00000072   0F2C               CMP      R4,#+15
   \   00000074   0BDA               BGE      ??init_CAN_2
    657              CAN_SetRxMsgObj( i, CAN_EXT_ID, 0, CAN_LAST_EXT_ID, TRUE );
                                                                         ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000076   82B0               SUB      SP,SP,#+8
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   0090               STR      R0,[SP, #+0]
   \   0000007C   174B               LDR      R3,??init_CAN_0+0x1C  ;; 0x1fffffff
   \   0000007E   0022               MOVS     R2,#+0
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   2000               MOVS     R0,R4
   \   00000084   ........           BL       CAN_SetRxMsgObj
   \   00000088   02B0               ADD      SP,SP,#+8
    658            }
   \   0000008A   641C               ADDS     R4,R4,#+1
   \   0000008C   F1E7               B        ??init_CAN_1
    659            for ( i=16; i<32; i++ ) {
   \                     ??init_CAN_2:
   \   0000008E   1020               MOVS     R0,#+16
   \   00000090   0400               MOVS     R4,R0
   \                     ??init_CAN_3:
   \   00000092   202C               CMP      R4,#+32
   \   00000094   0BDA               BGE      ??init_CAN_4
    660              CAN_SetRxMsgObj( i, CAN_STD_ID, 0, CAN_LAST_STD_ID, TRUE );
                                                                         ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000096   82B0               SUB      SP,SP,#+8
   \   00000098   0120               MOVS     R0,#+1
   \   0000009A   0090               STR      R0,[SP, #+0]
   \   0000009C   104B               LDR      R3,??init_CAN_0+0x20  ;; 0x7ff
   \   0000009E   0022               MOVS     R2,#+0
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   ........           BL       CAN_SetRxMsgObj
   \   000000A8   02B0               ADD      SP,SP,#+8
    661            }
   \   000000AA   641C               ADDS     R4,R4,#+1
   \   000000AC   F1E7               B        ??init_CAN_3
    662            
    663            CAN_LeaveInitMode();
   \                     ??init_CAN_4:
   \   000000AE   ........           BL       CAN_LeaveInitMode
    664            
    665            // enable global interrupt 
    666            EIC_IRQCmd( ENABLE );
   \   000000B2   0120               MOVS     R0,#+1
   \   000000B4   ........           BL       EIC_IRQCmd
    667          }
   \   000000B8   1FBC               POP      {R0-R4}
   \   000000BA   01BC               POP      {R0}
   \   000000BC   0047               BX       R0               ;; return
   \   000000BE   C046               Nop      
   \                     ??init_CAN_0:
   \   000000C0   ........           DC32     cntOutFrames
   \   000000C4   ........           DC32     posOutFetch
   \   000000C8   ........           DC32     posOutPut
   \   000000CC   ........           DC32     cntInFrames
   \   000000D0   ........           DC32     posInFetch
   \   000000D4   ........           DC32     posInPut
   \   000000D8   ........           DC32     lastAck
   \   000000DC   FFFFFF1F           DC32     0x1fffffff
   \   000000E0   FF070000           DC32     0x7ff
    668          
    669          ///////////////////////////////////////////////////////////////////////////////
    670          // sendMessage
    671          //
    672          

   \                                 In section .text, align 4, keep-with-next
    673          void sendMessage( void )
    674          {
   \                     sendMessage:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   86B0               SUB      SP,SP,#+24
    675            canmsg msg;
    676            vs_frame *pFrame;
    677            
    678            if ( cntOutFrames ) {           // If anything to send
   \   00000004   4048               LDR      R0,??sendMessage_0  ;; cntOutFrames
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   78D0               BEQ      ??sendMessage_1
    679                  
    680              pFrame = (vs_frame *)&outputFrames[ posOutFetch ];
   \   0000000C   3F48               LDR      R0,??sendMessage_0+0x4  ;; posOutFetch
   \   0000000E   0088               LDRH     R0,[R0, #+0]
   \   00000010   1421               MOVS     R1,#+20
   \   00000012   4843               MULS     R0,R1,R0
   \   00000014   3E49               LDR      R1,??sendMessage_0+0x8  ;; outputFrames
   \   00000016   0818               ADDS     R0,R1,R0
   \   00000018   0400               MOVS     R4,R0
    681                
    682              // Send the message
    683              if ( !( pFrame->data[0] & 0x80 ) ) {
   \   0000001A   A079               LDRB     R0,[R4, #+6]
   \   0000001C   0006               LSLS     R0,R0,#+24
   \   0000001E   26D4               BMI      ??sendMessage_2
    684                // Standard id
    685                msg.IdType = 0;
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   0090               STR      R0,[SP, #+0]
    686                if ( pFrame->data[0] & 0x40 ) {
   \   00000024   A079               LDRB     R0,[R4, #+6]
   \   00000026   4006               LSLS     R0,R0,#+25
   \   00000028   01D5               BPL      ??sendMessage_3
    687                  msg.IdType |= 0x00;   // Remote frame
   \   0000002A   0098               LDR      R0,[SP, #+0]
   \   0000002C   0090               STR      R0,[SP, #+0]
    688                }
    689                
    690                msg.Id = pFrame->data[3] + 
    691                          ( pFrame->data[2] << 8 ) +
    692                          ( pFrame->data[1] << 16 ) +
    693                          ( ( pFrame->data[0] & 0x0f ) << 24 );
   \                     ??sendMessage_3:
   \   0000002E   607A               LDRB     R0,[R4, #+9]
   \   00000030   217A               LDRB     R1,[R4, #+8]
   \   00000032   0902               LSLS     R1,R1,#+8
   \   00000034   4018               ADDS     R0,R0,R1
   \   00000036   E179               LDRB     R1,[R4, #+7]
   \   00000038   0904               LSLS     R1,R1,#+16
   \   0000003A   4018               ADDS     R0,R0,R1
   \   0000003C   A179               LDRB     R1,[R4, #+6]
   \   0000003E   0907               LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+28
   \   00000040   090F               LSRS     R1,R1,#+28
   \   00000042   0906               LSLS     R1,R1,#+24
   \   00000044   4018               ADDS     R0,R0,R1
   \   00000046   0190               STR      R0,[SP, #+4]
    694                msg.Dlc = ( pFrame->flags & 0x1f ) - 8;
   \   00000048   6078               LDRB     R0,[R4, #+1]
   \   0000004A   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000004C   C00E               LSRS     R0,R0,#+27
   \   0000004E   0838               SUBS     R0,R0,#+8
   \   00000050   6946               MOV      R1,SP
   \   00000052   0872               STRB     R0,[R1, #+8]
    695                memcpy( msg.Data, ( pFrame->data + 4 ), msg.Dlc );
   \   00000054   6846               MOV      R0,SP
   \   00000056   027A               LDRB     R2,[R0, #+8]
   \   00000058   2100               MOVS     R1,R4
   \   0000005A   0A31               ADDS     R1,R1,#+10
   \   0000005C   6846               MOV      R0,SP
   \   0000005E   0930               ADDS     R0,R0,#+9
   \   00000060   ........           BL       memcpy
    696                CAN_SendMessage( CAN_TX_MSGOBJ, &msg );
   \   00000064   6946               MOV      R1,SP
   \   00000066   0020               MOVS     R0,#+0
   \   00000068   ........           BL       CAN_SendMessage
   \   0000006C   25E0               B        ??sendMessage_4
    697              }
    698              else {
    699                // Extended id
    700                msg.IdType = CAN_EXT_ID;
   \                     ??sendMessage_2:
   \   0000006E   0120               MOVS     R0,#+1
   \   00000070   0090               STR      R0,[SP, #+0]
    701                if ( pFrame->data[0] & 0x40 ) {
   \   00000072   A079               LDRB     R0,[R4, #+6]
   \   00000074   4006               LSLS     R0,R0,#+25
   \   00000076   01D5               BPL      ??sendMessage_5
    702                  msg.IdType |= 0x00;   // Remote frame
   \   00000078   0098               LDR      R0,[SP, #+0]
   \   0000007A   0090               STR      R0,[SP, #+0]
    703                }
    704                
    705                msg.Id = pFrame->data[ 3 ] + 
    706                          ( pFrame->data[ 2 ] << 8 ) +
    707                          ( pFrame->data[ 1 ] << 16 ) +
    708                          ( ( pFrame->data[ 0 ] & 0x0f ) << 24 );
   \                     ??sendMessage_5:
   \   0000007C   607A               LDRB     R0,[R4, #+9]
   \   0000007E   217A               LDRB     R1,[R4, #+8]
   \   00000080   0902               LSLS     R1,R1,#+8
   \   00000082   4018               ADDS     R0,R0,R1
   \   00000084   E179               LDRB     R1,[R4, #+7]
   \   00000086   0904               LSLS     R1,R1,#+16
   \   00000088   4018               ADDS     R0,R0,R1
   \   0000008A   A179               LDRB     R1,[R4, #+6]
   \   0000008C   0907               LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+28
   \   0000008E   090F               LSRS     R1,R1,#+28
   \   00000090   0906               LSLS     R1,R1,#+24
   \   00000092   4018               ADDS     R0,R0,R1
   \   00000094   0190               STR      R0,[SP, #+4]
    709                msg.Dlc = ( pFrame->flags & 0x1f ) - 4;
   \   00000096   6078               LDRB     R0,[R4, #+1]
   \   00000098   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000009A   C00E               LSRS     R0,R0,#+27
   \   0000009C   001F               SUBS     R0,R0,#+4
   \   0000009E   6946               MOV      R1,SP
   \   000000A0   0872               STRB     R0,[R1, #+8]
    710                memcpy( msg.Data, ( pFrame->data + 8 ), msg.Dlc );
   \   000000A2   6846               MOV      R0,SP
   \   000000A4   027A               LDRB     R2,[R0, #+8]
   \   000000A6   2100               MOVS     R1,R4
   \   000000A8   0E31               ADDS     R1,R1,#+14
   \   000000AA   6846               MOV      R0,SP
   \   000000AC   0930               ADDS     R0,R0,#+9
   \   000000AE   ........           BL       memcpy
    711                CAN_SendMessage( CAN_TX_MSGOBJ + 1, &msg );
   \   000000B2   6946               MOV      R1,SP
   \   000000B4   0120               MOVS     R0,#+1
   \   000000B6   ........           BL       CAN_SendMessage
    712              }
    713              
    714              posOutFetch++;
   \                     ??sendMessage_4:
   \   000000BA   1448               LDR      R0,??sendMessage_0+0x4  ;; posOutFetch
   \   000000BC   0088               LDRH     R0,[R0, #+0]
   \   000000BE   401C               ADDS     R0,R0,#+1
   \   000000C0   1249               LDR      R1,??sendMessage_0+0x4  ;; posOutFetch
   \   000000C2   0880               STRH     R0,[R1, #+0]
    715              if ( posOutFetch >= MAX_OUT_FRAMES ) posOutFetch = 0;
   \   000000C4   1148               LDR      R0,??sendMessage_0+0x4  ;; posOutFetch
   \   000000C6   0088               LDRH     R0,[R0, #+0]
   \   000000C8   1028               CMP      R0,#+16
   \   000000CA   02D3               BCC      ??sendMessage_6
   \   000000CC   0F48               LDR      R0,??sendMessage_0+0x4  ;; posOutFetch
   \   000000CE   0021               MOVS     R1,#+0
   \   000000D0   0180               STRH     R1,[R0, #+0]
    716              cntOutFrames--;
   \                     ??sendMessage_6:
   \   000000D2   0D48               LDR      R0,??sendMessage_0  ;; cntOutFrames
   \   000000D4   0088               LDRH     R0,[R0, #+0]
   \   000000D6   401E               SUBS     R0,R0,#+1
   \   000000D8   0B49               LDR      R1,??sendMessage_0  ;; cntOutFrames
   \   000000DA   0880               STRH     R0,[R1, #+0]
    717                  
    718              // Statistics
    719              cntSentFrames++;
   \   000000DC   0D48               LDR      R0,??sendMessage_0+0xC  ;; cntSentFrames
   \   000000DE   0068               LDR      R0,[R0, #+0]
   \   000000E0   401C               ADDS     R0,R0,#+1
   \   000000E2   0C49               LDR      R1,??sendMessage_0+0xC  ;; cntSentFrames
   \   000000E4   0860               STR      R0,[R1, #+0]
    720              cntSentData += outputFrames[ posOutFetch ].Dlc;
   \   000000E6   0C48               LDR      R0,??sendMessage_0+0x10  ;; cntSentData
   \   000000E8   0068               LDR      R0,[R0, #+0]
   \   000000EA   0849               LDR      R1,??sendMessage_0+0x4  ;; posOutFetch
   \   000000EC   0988               LDRH     R1,[R1, #+0]
   \   000000EE   1422               MOVS     R2,#+20
   \   000000F0   5143               MULS     R1,R2,R1
   \   000000F2   074A               LDR      R2,??sendMessage_0+0x8  ;; outputFrames
   \   000000F4   5118               ADDS     R1,R2,R1
   \   000000F6   097A               LDRB     R1,[R1, #+8]
   \   000000F8   4018               ADDS     R0,R0,R1
   \   000000FA   0749               LDR      R1,??sendMessage_0+0x10  ;; cntSentData
   \   000000FC   0860               STR      R0,[R1, #+0]
    721            }
    722          }
   \                     ??sendMessage_1:
   \   000000FE   06B0               ADD      SP,SP,#+24
   \   00000100   10BC               POP      {R4}
   \   00000102   01BC               POP      {R0}
   \   00000104   0047               BX       R0               ;; return
   \   00000106   C046               Nop      
   \                     ??sendMessage_0:
   \   00000108   ........           DC32     cntOutFrames
   \   0000010C   ........           DC32     posOutFetch
   \   00000110   ........           DC32     outputFrames
   \   00000114   ........           DC32     cntSentFrames
   \   00000118   ........           DC32     cntSentData
    723          
    724          ///////////////////////////////////////////////////////////////////////////////
    725          // CAN_ISR
    726          //
    727          // CAN interrupt service routine
    728          //
    729          

   \                                 In section .text, align 4, keep-with-next
    730          void CAN_ISR( void )
    731          {
   \                     CAN_ISR:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    732            canmsg RxCanMsg;
    733            uint8_t msgobj;
    734            uint16_t idr;
    735            
    736            if ( 0x8000 == ( idr = CAN->IDR ) ) {
   \   00000004   4F48               LDR      R0,??CAN_ISR_0   ;; 0xffffc410
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   0500               MOVS     R5,R0
   \   0000000A   8021               MOVS     R1,#+128
   \   0000000C   0902               LSLS     R1,R1,#+8        ;; #+32768
   \   0000000E   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000010   000C               LSRS     R0,R0,#+16
   \   00000012   8842               CMP      R0,R1
   \   00000014   40D1               BNE      ??CAN_ISR_1
    737              
    738              // We have a status interrupt
    739              // bit 7 - Bus off
    740              // bit 6 - Warning
    741              // bit 5 - Error Passive
    742              // bit 4 - RXOK
    743              // bit 3 - TXOK
    744              // bit 2-0 - Last Error Code.
    745              canstatus = CAN->SR;
   \   00000016   4C48               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   00000018   4C49               LDR      R1,??CAN_ISR_0+0x8  ;; 0xffffc404
   \   0000001A   0988               LDRH     R1,[R1, #+0]
   \   0000001C   0170               STRB     R1,[R0, #+0]
    746              
    747              // May need visual indication
    748              CANAdapter_stateChange = TRUE;
   \   0000001E   4C48               LDR      R0,??CAN_ISR_0+0xC  ;; CANAdapter_stateChange
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   0170               STRB     R1,[R0, #+0]
    749              
    750              // Check for bus off
    751              if ( bBusOff ) {
   \   00000024   4B48               LDR      R0,??CAN_ISR_0+0x10  ;; bBusOff
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   07D0               BEQ      ??CAN_ISR_2
    752                if ( !( canstatus & CAN_SR_BOFF ) ) {
   \   0000002C   4648               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   0000002E   0078               LDRB     R0,[R0, #+0]
   \   00000030   0006               LSLS     R0,R0,#+24
   \   00000032   0AD4               BMI      ??CAN_ISR_3
    753                  // Going away from bus off
    754                  bBusOff = FALSE;  
   \   00000034   4748               LDR      R0,??CAN_ISR_0+0x10  ;; bBusOff
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   0160               STR      R1,[R0, #+0]
   \   0000003A   06E0               B        ??CAN_ISR_3
    755                }
    756              }
    757              else {
    758                if ( canstatus & CAN_SR_BOFF ) {
   \                     ??CAN_ISR_2:
   \   0000003C   4248               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   0000003E   0078               LDRB     R0,[R0, #+0]
   \   00000040   0006               LSLS     R0,R0,#+24
   \   00000042   02D5               BPL      ??CAN_ISR_3
    759                  // bus off
    760                  bBusOff = TRUE;
   \   00000044   4348               LDR      R0,??CAN_ISR_0+0x10  ;; bBusOff
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   0160               STR      R1,[R0, #+0]
    761                }  
    762              }
    763              
    764              // Check for bus warning
    765              if ( bBusWarn ) {
   \                     ??CAN_ISR_3:
   \   0000004A   4348               LDR      R0,??CAN_ISR_0+0x14  ;; bBusWarn
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   07D0               BEQ      ??CAN_ISR_4
    766                if ( !( canstatus & CAN_SR_EWARN ) ) {
   \   00000052   3D48               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   00000054   0078               LDRB     R0,[R0, #+0]
   \   00000056   4006               LSLS     R0,R0,#+25
   \   00000058   0AD4               BMI      ??CAN_ISR_5
    767                  // Going away from bus warning
    768                  bBusWarn = FALSE;  
   \   0000005A   3F48               LDR      R0,??CAN_ISR_0+0x14  ;; bBusWarn
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0160               STR      R1,[R0, #+0]
   \   00000060   06E0               B        ??CAN_ISR_5
    769                }
    770              }
    771              else {
    772                if ( canstatus & CAN_SR_EWARN ) {
   \                     ??CAN_ISR_4:
   \   00000062   3948               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   00000064   0078               LDRB     R0,[R0, #+0]
   \   00000066   4006               LSLS     R0,R0,#+25
   \   00000068   02D5               BPL      ??CAN_ISR_5
    773                  // bus warning
    774                  bBusWarn = TRUE;
   \   0000006A   3B48               LDR      R0,??CAN_ISR_0+0x14  ;; bBusWarn
   \   0000006C   0121               MOVS     R1,#+1
   \   0000006E   0160               STR      R1,[R0, #+0]
    775                }  
    776              }
    777              
    778              // Check for error passive
    779              if ( bErrorPassive ) {
   \                     ??CAN_ISR_5:
   \   00000070   3A48               LDR      R0,??CAN_ISR_0+0x18  ;; bErrorPassive
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   07D0               BEQ      ??CAN_ISR_6
    780                if ( !( canstatus & CAN_SR_EPASS ) ) {
   \   00000078   3348               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   0000007A   0078               LDRB     R0,[R0, #+0]
   \   0000007C   8006               LSLS     R0,R0,#+26
   \   0000007E   5DD4               BMI      ??CAN_ISR_7
    781                  // Going away from error passive
    782                  bErrorPassive = FALSE;  
   \   00000080   3648               LDR      R0,??CAN_ISR_0+0x18  ;; bErrorPassive
   \   00000082   0021               MOVS     R1,#+0
   \   00000084   0160               STR      R1,[R0, #+0]
   \   00000086   59E0               B        ??CAN_ISR_7
    783                }
    784              }
    785              else {
    786                if ( canstatus & CAN_SR_EPASS ) {
   \                     ??CAN_ISR_6:
   \   00000088   2F48               LDR      R0,??CAN_ISR_0+0x4  ;; canstatus
   \   0000008A   0078               LDRB     R0,[R0, #+0]
   \   0000008C   8006               LSLS     R0,R0,#+26
   \   0000008E   55D5               BPL      ??CAN_ISR_7
    787                  // error passive
    788                  bErrorPassive = TRUE;  
   \   00000090   3248               LDR      R0,??CAN_ISR_0+0x18  ;; bErrorPassive
   \   00000092   0121               MOVS     R1,#+1
   \   00000094   0160               STR      R1,[R0, #+0]
   \   00000096   51E0               B        ??CAN_ISR_7
    789                }  
    790              }
    791              
    792            }
    793            else if ( msgobj = ( idr & 0x1f ) ) {
   \                     ??CAN_ISR_1:
   \   00000098   2800               MOVS     R0,R5
   \   0000009A   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000009C   C00E               LSRS     R0,R0,#+27
   \   0000009E   0400               MOVS     R4,R0
   \   000000A0   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000A2   000E               LSRS     R0,R0,#+24
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   49D0               BEQ      ??CAN_ISR_7
    794              
    795              if ( msgobj < 3 ) {
   \   000000A8   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000AA   240E               LSRS     R4,R4,#+24
   \   000000AC   032C               CMP      R4,#+3
   \   000000AE   09D2               BCS      ??CAN_ISR_8
    796                
    797                // We have transmitted a message, send next if one is availabe    
    798                
    799                // Clear interrupt pending bit
    800                CAN->sMsgObj[1].CMR = CAN_CMR_CLRINTPND;
   \   000000B0   2B48               LDR      R0,??CAN_ISR_0+0x1C  ;; 0xffffc484
   \   000000B2   0821               MOVS     R1,#+8
   \   000000B4   0180               STRH     R1,[R0, #+0]
    801                CAN->sMsgObj[1].CRR = msgobj;
   \   000000B6   2B48               LDR      R0,??CAN_ISR_0+0x20  ;; 0xffffc480
   \   000000B8   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000BA   240E               LSRS     R4,R4,#+24
   \   000000BC   0480               STRH     R4,[R0, #+0]
    802                
    803                sendMessage();
   \   000000BE   ........           BL       sendMessage
   \   000000C2   3BE0               B        ??CAN_ISR_7
    804                
    805              }
    806              else {
    807                
    808                // We have received a message - get it
    809                CAN_ReceiveMessage( msgobj-1, TRUE, &RxCanMsg );
                                                     ^
Warning[Pe188]: enumerated type mixed with another type
   \                     ??CAN_ISR_8:
   \   000000C4   6A46               MOV      R2,SP
   \   000000C6   0121               MOVS     R1,#+1
   \   000000C8   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000CA   240E               LSRS     R4,R4,#+24
   \   000000CC   601E               SUBS     R0,R4,#+1
   \   000000CE   ........           BL       CAN_ReceiveMessage
    810                
    811                if ( CANAdapter_bOpen ) { // Receive only if open
   \   000000D2   2548               LDR      R0,??CAN_ISR_0+0x24  ;; CANAdapter_bOpen
   \   000000D4   0068               LDR      R0,[R0, #+0]
   \   000000D6   0028               CMP      R0,#+0
   \   000000D8   30D0               BEQ      ??CAN_ISR_7
    812                  // Statistics
    813                  cntReceivedFrames++;
   \   000000DA   2448               LDR      R0,??CAN_ISR_0+0x28  ;; cntReceivedFrames
   \   000000DC   0068               LDR      R0,[R0, #+0]
   \   000000DE   401C               ADDS     R0,R0,#+1
   \   000000E0   2249               LDR      R1,??CAN_ISR_0+0x28  ;; cntReceivedFrames
   \   000000E2   0860               STR      R0,[R1, #+0]
    814                  cntReceivedData += RxCanMsg.Dlc;
   \   000000E4   2248               LDR      R0,??CAN_ISR_0+0x2C  ;; cntReceivedData
   \   000000E6   0068               LDR      R0,[R0, #+0]
   \   000000E8   6946               MOV      R1,SP
   \   000000EA   097A               LDRB     R1,[R1, #+8]
   \   000000EC   4018               ADDS     R0,R0,R1
   \   000000EE   2049               LDR      R1,??CAN_ISR_0+0x2C  ;; cntReceivedData
   \   000000F0   0860               STR      R0,[R1, #+0]
    815                
    816                  if ( cntInFrames <= MAX_IN_FRAMES ) {
   \   000000F2   2048               LDR      R0,??CAN_ISR_0+0x30  ;; cntInFrames
   \   000000F4   0088               LDRH     R0,[R0, #+0]
   \   000000F6   1128               CMP      R0,#+17
   \   000000F8   1BD2               BCS      ??CAN_ISR_9
    817                    memcpy( &inputFrames[ posInPut ], &RxCanMsg, sizeof( RxCanMsg ) );
   \   000000FA   1422               MOVS     R2,#+20
   \   000000FC   6946               MOV      R1,SP
   \   000000FE   1E48               LDR      R0,??CAN_ISR_0+0x34  ;; posInPut
   \   00000100   0088               LDRH     R0,[R0, #+0]
   \   00000102   1423               MOVS     R3,#+20
   \   00000104   5843               MULS     R0,R3,R0
   \   00000106   1D4B               LDR      R3,??CAN_ISR_0+0x38  ;; inputFrames
   \   00000108   1818               ADDS     R0,R3,R0
   \   0000010A   ........           BL       memcpy
    818                    cntInFrames++;
   \   0000010E   1948               LDR      R0,??CAN_ISR_0+0x30  ;; cntInFrames
   \   00000110   0088               LDRH     R0,[R0, #+0]
   \   00000112   401C               ADDS     R0,R0,#+1
   \   00000114   1749               LDR      R1,??CAN_ISR_0+0x30  ;; cntInFrames
   \   00000116   0880               STRH     R0,[R1, #+0]
    819                    posInPut++;
   \   00000118   1748               LDR      R0,??CAN_ISR_0+0x34  ;; posInPut
   \   0000011A   0088               LDRH     R0,[R0, #+0]
   \   0000011C   401C               ADDS     R0,R0,#+1
   \   0000011E   1649               LDR      R1,??CAN_ISR_0+0x34  ;; posInPut
   \   00000120   0880               STRH     R0,[R1, #+0]
    820                    if ( posInPut >= MAX_IN_FRAMES ) posInPut = 0;
   \   00000122   1548               LDR      R0,??CAN_ISR_0+0x34  ;; posInPut
   \   00000124   0088               LDRH     R0,[R0, #+0]
   \   00000126   1028               CMP      R0,#+16
   \   00000128   08D3               BCC      ??CAN_ISR_7
   \   0000012A   1348               LDR      R0,??CAN_ISR_0+0x34  ;; posInPut
   \   0000012C   0021               MOVS     R1,#+0
   \   0000012E   0180               STRH     R1,[R0, #+0]
   \   00000130   04E0               B        ??CAN_ISR_7
    821                  }
    822                  else {
    823                    cntReceiveOverruns++;
   \                     ??CAN_ISR_9:
   \   00000132   1348               LDR      R0,??CAN_ISR_0+0x3C  ;; cntReceiveOverruns
   \   00000134   0068               LDR      R0,[R0, #+0]
   \   00000136   401C               ADDS     R0,R0,#+1
   \   00000138   1149               LDR      R1,??CAN_ISR_0+0x3C  ;; cntReceiveOverruns
   \   0000013A   0860               STR      R0,[R1, #+0]
    824                  }
    825                  
    826                }
    827                
    828              }
    829                 
    830            }
    831          }
   \                     ??CAN_ISR_7:
   \   0000013C   05B0               ADD      SP,SP,#+20
   \   0000013E   30BC               POP      {R4,R5}
   \   00000140   01BC               POP      {R0}
   \   00000142   0047               BX       R0               ;; return
   \                     ??CAN_ISR_0:
   \   00000144   10C4FFFF           DC32     0xffffc410
   \   00000148   ........           DC32     canstatus
   \   0000014C   04C4FFFF           DC32     0xffffc404
   \   00000150   ........           DC32     CANAdapter_stateChange
   \   00000154   ........           DC32     bBusOff
   \   00000158   ........           DC32     bBusWarn
   \   0000015C   ........           DC32     bErrorPassive
   \   00000160   84C4FFFF           DC32     0xffffc484
   \   00000164   80C4FFFF           DC32     0xffffc480
   \   00000168   ........           DC32     CANAdapter_bOpen
   \   0000016C   ........           DC32     cntReceivedFrames
   \   00000170   ........           DC32     cntReceivedData
   \   00000174   ........           DC32     cntInFrames
   \   00000178   ........           DC32     posInPut
   \   0000017C   ........           DC32     inputFrames
   \   00000180   ........           DC32     cntReceiveOverruns
    832          
    833          
    834          
    835          /*************************************************************************
    836           * Function Name: main
    837           * Parameters: none
    838           *
    839           * Return: none
    840           *
    841           * Description:
    842           *
    843           *************************************************************************/
    844          

   \                                 In section .text, align 4, keep-with-next
    845          int main( void )
    846          {
   \                     main:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   C148               LDR      R0,??main_0      ;; 0xfffffbcc
   \   00000004   8544               ADD      SP,SP,R0
    847            uint16_t i;
    848            uint8_t Buffer[ 1024 ];
    849            uint32_t readCnt; // Incoming data count
    850            uint32_t readPos; // Serial incoming data pointer
    851            Boolean CdcConfigureStateHold;
    852            
    853            // Initialize output fifo 
    854            cntOutFrames = 0;
   \   00000006   C148               LDR      R0,??main_0+0x4  ;; cntOutFrames
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0180               STRH     R1,[R0, #+0]
    855            posOutFetch = 0;
   \   0000000C   C048               LDR      R0,??main_0+0x8  ;; posOutFetch
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0180               STRH     R1,[R0, #+0]
    856            posOutPut = 0;
   \   00000012   C048               LDR      R0,??main_0+0xC  ;; posOutPut
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0180               STRH     R1,[R0, #+0]
    857            
    858            // Initialize input fifo 
    859            cntInFrames = 0;
   \   00000018   BF48               LDR      R0,??main_0+0x10  ;; cntInFrames
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   0180               STRH     R1,[R0, #+0]
    860            posInFetch = 0;
   \   0000001E   BF48               LDR      R0,??main_0+0x14  ;; posInFetch
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   0180               STRH     R1,[R0, #+0]
    861            posInPut = 0;
   \   00000024   BE48               LDR      R0,??main_0+0x18  ;; posInPut
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   0180               STRH     R1,[R0, #+0]
    862            
    863            // Initialize statistics
    864            cntSentFrames = 0;
   \   0000002A   BE48               LDR      R0,??main_0+0x1C  ;; cntSentFrames
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   0160               STR      R1,[R0, #+0]
    865            cntReceivedFrames = 0;
   \   00000030   BD48               LDR      R0,??main_0+0x20  ;; cntReceivedFrames
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   0160               STR      R1,[R0, #+0]
    866            cntSentData = 0;
   \   00000036   BD48               LDR      R0,??main_0+0x24  ;; cntSentData
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   0160               STR      R1,[R0, #+0]
    867            cntReceivedData = 0;
   \   0000003C   BC48               LDR      R0,??main_0+0x28  ;; cntReceivedData
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   0160               STR      R1,[R0, #+0]
    868            cntBusWarnings = 0;
   \   00000042   BC48               LDR      R0,??main_0+0x2C  ;; cntBusWarnings
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0160               STR      R1,[R0, #+0]
    869            cntBusOff = 0;
   \   00000048   BB48               LDR      R0,??main_0+0x30  ;; cntBusOff
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0160               STR      R1,[R0, #+0]
    870            cntReceiveOverruns = 0;
   \   0000004E   BB48               LDR      R0,??main_0+0x34  ;; cntReceiveOverruns
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   0160               STR      R1,[R0, #+0]
    871            cntTransmitOverruns = 0;
   \   00000054   BA48               LDR      R0,??main_0+0x38  ;; cntTransmitOverruns
   \   00000056   0021               MOVS     R1,#+0
   \   00000058   0160               STR      R1,[R0, #+0]
    872            
    873            // Error states
    874            bBusOff = FALSE;
   \   0000005A   BA48               LDR      R0,??main_0+0x3C  ;; bBusOff
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0160               STR      R1,[R0, #+0]
    875            bBusWarn = FALSE;
   \   00000060   B948               LDR      R0,??main_0+0x40  ;; bBusWarn
   \   00000062   0021               MOVS     R1,#+0
   \   00000064   0160               STR      R1,[R0, #+0]
    876            bErrorPassive = FALSE;
   \   00000066   B948               LDR      R0,??main_0+0x44  ;; bErrorPassive
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   0160               STR      R1,[R0, #+0]
    877            
    878            // Sliding window init for USB receive
    879            swReceive.cntOutstanding = 0;
   \   0000006C   B848               LDR      R0,??main_0+0x48  ;; swReceive
   \   0000006E   0021               MOVS     R1,#+0
   \   00000070   0170               STRB     R1,[R0, #+0]
    880            swReceive.maxtime = 500;
   \   00000072   B848               LDR      R0,??main_0+0x4C  ;; swReceive + 4
   \   00000074   FA21               MOVS     R1,#+250
   \   00000076   4900               LSLS     R1,R1,#+1        ;; #+500
   \   00000078   0160               STR      R1,[R0, #+0]
    881            swReceive.maxresend = 3;
   \   0000007A   B748               LDR      R0,??main_0+0x50  ;; swReceive + 8
   \   0000007C   0321               MOVS     R1,#+3
   \   0000007E   0170               STRB     R1,[R0, #+0]
    882            
    883            // Application
    884            vs_frame serialFrame;       // VSCP Serial frame
    885            canmsg msg;                 // CAN frame
    886            uint16_t com_channel = 0;   // Communication channel (Always zero)
   \   00000080   6846               MOV      R0,SP
   \   00000082   0021               MOVS     R1,#+0
   \   00000084   4180               STRH     R1,[R0, #+2]
    887            uint8_t seqnumber = 0;      // Packet sequence number
   \   00000086   0020               MOVS     R0,#+0
   \   00000088   0700               MOVS     R7,R0
    888            
    889            // Set Burst mode
    890            CFG_FLASHBurstConfig( CFG_FLASHBurst_Enable );
   \   0000008A   8020               MOVS     R0,#+128
   \   0000008C   4000               LSLS     R0,R0,#+1        ;; #+256
   \   0000008E   ........           BL       CFG_FLASHBurstConfig
    891            
    892            // MCU clock init
    893            InitClock();
   \   00000092   ........           BL       InitClock
    894            
    895            // EIC init
    896            EIC_DeInit();
   \   00000096   ........           BL       EIC_DeInit
    897            
    898            // Delay timer init
    899            InitDlyTimer( 1 );
   \   0000009A   0120               MOVS     R0,#+1
   \   0000009C   ........           BL       InitDlyTimer
    900            
    901            // Init 1 ms timebase
    902            initTimebase();
   \   000000A0   ........           BL       initTimebase
    903            
    904            // Init UART 0/1
    905            //UartInit( UART, 3 );
    906          
    907            // GPIO ports init
    908            IO_Init();
   \   000000A4   ........           BL       IO_Init
    909            
    910            // Initialize USB
    911            // Init USB
    912            USB_Init( 5, 4, UsbCdcConfigure );
   \   000000A8   AC4A               LDR      R2,??main_0+0x54  ;; UsbCdcConfigure
   \   000000AA   0421               MOVS     R1,#+4
   \   000000AC   0520               MOVS     R0,#+5
   \   000000AE   ........           BL       USB_Init
    913            
    914            // Init CDC
    915            UsbCdcInit( 2 );
   \   000000B2   0220               MOVS     R0,#+2
   \   000000B4   ........           BL       UsbCdcInit
    916            
    917            // Init CAN interface
    918            init_CAN();
   \   000000B8   ........           BL       init_CAN
    919            
    920            // Soft connection enable
    921            USB_ConnectRes( TRUE );
   \   000000BC   0120               MOVS     R0,#+1
   \   000000BE   ........           BL       USB_ConnectRes
    922          
    923            // Enable the Interrupt controller to manage IRQ channel
    924            EIC_IRQCmd( ENABLE );
   \   000000C2   0120               MOVS     R0,#+1
   \   000000C4   ........           BL       EIC_IRQCmd
    925            __enable_interrupt();
   \   000000C8   ........           BL       __iar_enable_interrupt
    926          
    927            CdcConfigureStateHold = !UsbCdcIsCdcConfigure();
   \   000000CC   ........           BL       UsbCdcIsCdcConfigure
   \   000000D0   401E               SUBS     R0,R0,#+1
   \   000000D2   8041               SBCS     R0,R0,R0
   \   000000D4   C00F               LSRS     R0,R0,#+31
   \   000000D6   6946               MOV      R1,SP
   \   000000D8   0870               STRB     R0,[R1, #+0]
    928          
    929            setBlinkType( LED_RED_BLINK_FAST );
   \   000000DA   0320               MOVS     R0,#+3
   \   000000DC   ........           BL       setBlinkType
    930            
    931            
    932            while( 1 ) {
    933              
    934              if ( UsbCdcIsCdcConfigure() ) {
   \                     ??main_1:
   \   000000E0   ........           BL       UsbCdcIsCdcConfigure
   \   000000E4   0028               CMP      R0,#+0
   \   000000E6   00D1               BNE      .+4
   \   000000E8   15E2               B        ??main_2
    935                
    936                if ( CANAdapter_stateChange ) {
   \   000000EA   9D48               LDR      R0,??main_0+0x58  ;; CANAdapter_stateChange
   \   000000EC   0078               LDRB     R0,[R0, #+0]
   \   000000EE   0028               CMP      R0,#+0
   \   000000F0   1DD0               BEQ      ??main_3
    937                  if ( CANAdapter_bOpen  ) {
   \   000000F2   9C48               LDR      R0,??main_0+0x5C  ;; CANAdapter_bOpen
   \   000000F4   0068               LDR      R0,[R0, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   13D0               BEQ      ??main_4
    938                    if ( bBusOff ) {
   \   000000FA   9248               LDR      R0,??main_0+0x3C  ;; bBusOff
   \   000000FC   0068               LDR      R0,[R0, #+0]
   \   000000FE   0028               CMP      R0,#+0
   \   00000100   03D0               BEQ      ??main_5
    939                      setBlinkType( LED_RED_BLINK_FAST ); 
   \   00000102   0320               MOVS     R0,#+3
   \   00000104   ........           BL       setBlinkType
   \   00000108   0EE0               B        ??main_6
    940                    }
    941                    else if ( bBusWarn ) {
   \                     ??main_5:
   \   0000010A   8F48               LDR      R0,??main_0+0x40  ;; bBusWarn
   \   0000010C   0068               LDR      R0,[R0, #+0]
   \   0000010E   0028               CMP      R0,#+0
   \   00000110   03D0               BEQ      ??main_7
    942                      setBlinkType( LED_RED_GREEN_BLINK_FAST );
   \   00000112   0820               MOVS     R0,#+8
   \   00000114   ........           BL       setBlinkType
   \   00000118   06E0               B        ??main_6
    943                    }
    944                    else {
    945                      setBlinkType( LED_GREEN_BLINK_FAST );
   \                     ??main_7:
   \   0000011A   0520               MOVS     R0,#+5
   \   0000011C   ........           BL       setBlinkType
   \   00000120   02E0               B        ??main_6
    946                    }
    947                  }
    948                  else {
    949                    setBlinkType( LED_GREEN_STEADY );
   \                     ??main_4:
   \   00000122   0220               MOVS     R0,#+2
   \   00000124   ........           BL       setBlinkType
    950                  }
    951                  
    952                  CANAdapter_stateChange = FALSE;
   \                     ??main_6:
   \   00000128   8D48               LDR      R0,??main_0+0x58  ;; CANAdapter_stateChange
   \   0000012A   0021               MOVS     R1,#+0
   \   0000012C   0170               STRB     R1,[R0, #+0]
    953                  
    954                }
    955                
    956                
    957                if ( CdcConfigureStateHold == FALSE ) {
   \                     ??main_3:
   \   0000012E   6846               MOV      R0,SP
   \   00000130   0078               LDRB     R0,[R0, #+0]
   \   00000132   0028               CMP      R0,#+0
   \   00000134   02D1               BNE      ??main_8
    958                  CdcConfigureStateHold = TRUE;
   \   00000136   6846               MOV      R0,SP
   \   00000138   0121               MOVS     R1,#+1
   \   0000013A   0170               STRB     R1,[R0, #+0]
    959                }
    960                
    961                // Data from USB
    962                if ( readCnt = UsbCdcRead( Buffer, sizeof( Buffer ) ) ) {
   \                     ??main_8:
   \   0000013C   8021               MOVS     R1,#+128
   \   0000013E   C900               LSLS     R1,R1,#+3        ;; #+1024
   \   00000140   0CA8               ADD      R0,SP,#+48
   \   00000142   ........           BL       UsbCdcRead
   \   00000146   0500               MOVS     R5,R0
   \   00000148   0028               CMP      R0,#+0
   \   0000014A   00D1               BNE      .+4
   \   0000014C   58E1               B        ??main_9
    963                  
    964                  readPos = 0;
   \   0000014E   0020               MOVS     R0,#+0
   \   00000150   0600               MOVS     R6,R0
    965                  do {
    966                 
    967                    if ( vs_feed( Buffer[ readPos ] ) ) {
   \                     ??main_10:
   \   00000152   0CA8               ADD      R0,SP,#+48
   \   00000154   805D               LDRB     R0,[R0, R6]
   \   00000156   ........           BL       vs_feed
   \   0000015A   0028               CMP      R0,#+0
   \   0000015C   00D1               BNE      .+4
   \   0000015E   4AE1               B        ??main_11
    968                      
    969                      // We have a frame
    970                      if ( vs_getFrame( &serialFrame ) ) {
   \   00000160   01A8               ADD      R0,SP,#+4
   \   00000162   ........           BL       vs_getFrame
   \   00000166   0028               CMP      R0,#+0
   \   00000168   00D1               BNE      .+4
   \   0000016A   44E1               B        ??main_11
    971                      
    972                        switch ( serialFrame.opcode ) {
   \   0000016C   6846               MOV      R0,SP
   \   0000016E   0079               LDRB     R0,[R0, #+4]
   \   00000170   0028               CMP      R0,#+0
   \   00000172   0AD0               BEQ      ??main_12
   \   00000174   401E               SUBS     R0,R0,#+1
   \   00000176   0FD0               BEQ      ??main_13
   \   00000178   401E               SUBS     R0,R0,#+1
   \   0000017A   59D0               BEQ      ??main_14
   \   0000017C   401E               SUBS     R0,R0,#+1
   \   0000017E   5ED0               BEQ      ??main_15
   \   00000180   801E               SUBS     R0,R0,#+2
   \   00000182   10D0               BEQ      ??main_16
   \   00000184   FA38               SUBS     R0,R0,#+250
   \   00000186   61D0               BEQ      ??main_17
   \   00000188   35E1               B        ??main_11
    973                      
    974                          case VSCP_SERIAL_OPCODE_NOOP:
    975                            
    976                            // We don't do anything other then ACK the frame
    977                            vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_12:
   \   0000018A   01A8               ADD      R0,SP,#+4
   \   0000018C   C178               LDRB     R1,[R0, #+3]
   \   0000018E   01A8               ADD      R0,SP,#+4
   \   00000190   8078               LDRB     R0,[R0, #+2]
   \   00000192   ........           BL       vs_sendAck
   \   00000196   2EE1               B        ??main_11
    978                            break;
    979                        
    980                          case VSCP_SERIAL_OPCODE_LEVEL1_EVENT:
    981                            // We don't accept LEVEL I events
    982                            vs_sendNack( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_13:
   \   00000198   01A8               ADD      R0,SP,#+4
   \   0000019A   C178               LDRB     R1,[R0, #+3]
   \   0000019C   01A8               ADD      R0,SP,#+4
   \   0000019E   8078               LDRB     R0,[R0, #+2]
   \   000001A0   ........           BL       vs_sendNack
   \   000001A4   27E1               B        ??main_11
    983                            break;
    984                            
    985                          case VSCP_SERIAL_OPCODE_CAN_FRAME:
    986                            
    987                            if ( CANAdapter_bOpen ) { // Send only if open
   \                     ??main_16:
   \   000001A6   6F48               LDR      R0,??main_0+0x5C  ;; CANAdapter_bOpen
   \   000001A8   0068               LDR      R0,[R0, #+0]
   \   000001AA   0028               CMP      R0,#+0
   \   000001AC   39D0               BEQ      ??main_18
    988                              // Place message in outqueue if there is room for it
    989                              if ( cntOutFrames > MAX_OUT_FRAMES ) {
   \   000001AE   5748               LDR      R0,??main_0+0x4  ;; cntOutFrames
   \   000001B0   0088               LDRH     R0,[R0, #+0]
   \   000001B2   1128               CMP      R0,#+17
   \   000001B4   05D3               BCC      ??main_19
    990                                // No room for frame - TX overrun
    991                                cntTransmitOverruns++;
   \   000001B6   6248               LDR      R0,??main_0+0x38  ;; cntTransmitOverruns
   \   000001B8   0068               LDR      R0,[R0, #+0]
   \   000001BA   401C               ADDS     R0,R0,#+1
   \   000001BC   6049               LDR      R1,??main_0+0x38  ;; cntTransmitOverruns
   \   000001BE   0860               STR      R0,[R1, #+0]
   \   000001C0   19E1               B        ??main_11
    992                              }
    993                              else {
    994                              
    995                                // A CAN frame has it's id in the four first
    996                                // bytes of the data area and timestamp in the
    997                                // last four databytes. This means that
    998                                // the data count must be at least eight bytes
    999                               // for a fram to be a valid CAN frame.
   1000                                // id + data + timestamp
   1001                                if ( ( serialFrame.flags & 0x1f ) >= 8 ) {
   \                     ??main_19:
   \   000001C2   01A8               ADD      R0,SP,#+4
   \   000001C4   4078               LDRB     R0,[R0, #+1]
   \   000001C6   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   000001C8   C00E               LSRS     R0,R0,#+27
   \   000001CA   0828               CMP      R0,#+8
   \   000001CC   00DA               BGE      .+4
   \   000001CE   12E1               B        ??main_11
   1002                                   
   1003                                  // Place frame in outqueue
   1004                                  lastAck = serialFrame.seqnumber;
   \   000001D0   01A8               ADD      R0,SP,#+4
   \   000001D2   C078               LDRB     R0,[R0, #+3]
   \   000001D4   D449               LDR      R1,??main_20     ;; lastAck
   \   000001D6   0870               STRB     R0,[R1, #+0]
   1005                                  memcpy( &outputFrames[ posOutPut++ ], 
   1006                                            &serialFrame, 
   1007                                            sizeof( serialFrame ) );
   \   000001D8   4E48               LDR      R0,??main_0+0xC  ;; posOutPut
   \   000001DA   0088               LDRH     R0,[R0, #+0]
   \   000001DC   0100               MOVS     R1,R0
   \   000001DE   491C               ADDS     R1,R1,#+1
   \   000001E0   4C4A               LDR      R2,??main_0+0xC  ;; posOutPut
   \   000001E2   1180               STRH     R1,[R2, #+0]
   \   000001E4   1622               MOVS     R2,#+22
   \   000001E6   01A9               ADD      R1,SP,#+4
   \   000001E8   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   000001EA   000C               LSRS     R0,R0,#+16
   \   000001EC   1423               MOVS     R3,#+20
   \   000001EE   5843               MULS     R0,R3,R0
   \   000001F0   CE4B               LDR      R3,??main_20+0x4  ;; outputFrames
   \   000001F2   1818               ADDS     R0,R3,R0
   \   000001F4   ........           BL       memcpy
   1008                                  cntOutFrames++;
   \   000001F8   4448               LDR      R0,??main_0+0x4  ;; cntOutFrames
   \   000001FA   0088               LDRH     R0,[R0, #+0]
   \   000001FC   401C               ADDS     R0,R0,#+1
   \   000001FE   4349               LDR      R1,??main_0+0x4  ;; cntOutFrames
   \   00000200   0880               STRH     R0,[R1, #+0]
   1009                                  posOutPut %= MAX_OUT_FRAMES;
   \   00000202   4448               LDR      R0,??main_0+0xC  ;; posOutPut
   \   00000204   0088               LDRH     R0,[R0, #+0]
   \   00000206   1021               MOVS     R1,#+16
   \   00000208   ........           BL       __aeabi_idivmod
   \   0000020C   4148               LDR      R0,??main_0+0xC  ;; posOutPut
   \   0000020E   0180               STRH     R1,[R0, #+0]
   1010                                     
   1011                                  // If the CAN output queue was empty we need to send
   1012                                  // the event here
   1013                                  if ( 0 == ( cntOutFrames - 1 ) ) {
   \   00000210   3E48               LDR      R0,??main_0+0x4  ;; cntOutFrames
   \   00000212   0088               LDRH     R0,[R0, #+0]
   \   00000214   401E               SUBS     R0,R0,#+1
   \   00000216   0028               CMP      R0,#+0
   \   00000218   00D0               BEQ      .+4
   \   0000021A   ECE0               B        ??main_11
   1014                                    sendMessage();
   \   0000021C   ........           BL       sendMessage
   \   00000220   E9E0               B        ??main_11
   1015                                  }
   1016                                
   1017                                }
   1018                              
   1019                              }
   1020                            }
   1021                            else {
   1022                              // Not open
   1023                              vs_sendNack( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_18:
   \   00000222   01A8               ADD      R0,SP,#+4
   \   00000224   C178               LDRB     R1,[R0, #+3]
   \   00000226   01A8               ADD      R0,SP,#+4
   \   00000228   8078               LDRB     R0,[R0, #+2]
   \   0000022A   ........           BL       vs_sendNack
   \   0000022E   E2E0               B        ??main_11
   1024                            }
   1025                            break;
   1026                        
   1027                          case VSCP_SERIAL_OPCODE_LEVEL2_EVENT:
   1028                            // We don't accept LEVEL II events
   1029                            vs_sendNack( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_14:
   \   00000230   01A8               ADD      R0,SP,#+4
   \   00000232   C178               LDRB     R1,[R0, #+3]
   \   00000234   01A8               ADD      R0,SP,#+4
   \   00000236   8078               LDRB     R0,[R0, #+2]
   \   00000238   ........           BL       vs_sendNack
   \   0000023C   DBE0               B        ??main_11
   1030                            break;
   1031                        
   1032                          case VSCP_SERIAL_OPCODE_POLL_EVENT:
   1033                            // We don't accept poll events
   1034                            vs_sendNack( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_15:
   \   0000023E   01A8               ADD      R0,SP,#+4
   \   00000240   C178               LDRB     R1,[R0, #+3]
   \   00000242   01A8               ADD      R0,SP,#+4
   \   00000244   8078               LDRB     R0,[R0, #+2]
   \   00000246   ........           BL       vs_sendNack
   \   0000024A   D4E0               B        ??main_11
   1035                            break;
   1036                        
   1037                          case VSCP_SERIAL_OPCODE_NO_EVENT:
   1038                            // We don't do anything
   1039                            break;
   1040                        
   1041                          case VSCP_SERIAL_OPCODE_ACK:
   1042                            // ACK received - remove the frame for the active frames
   1043                            break;
   1044                        
   1045                          case VSCP_SERIAL_OPCODE_NACK: 
   1046                            // NACK received
   1047                            break;
   1048                        
   1049                          case VSCP_SERIAL_OPCODE_ERROR:
   1050                            // We don't do anything
   1051                            break;
   1052                            
   1053                          case VSCP_SERIAL_OPCODE_REPLY:
   1054                            // We don't do anything
   1055                            break;    
   1056                        
   1057                          case VSCP_SERIAL_OPCODE_COMMAND:
   1058                            switch ( serialFrame.vscptype ) {
   \                     ??main_17:
   \   0000024C   01A8               ADD      R0,SP,#+4
   \   0000024E   4079               LDRB     R0,[R0, #+5]
   \   00000250   0028               CMP      R0,#+0
   \   00000252   12D0               BEQ      ??main_21
   \   00000254   401E               SUBS     R0,R0,#+1
   \   00000256   17D0               BEQ      ??main_22
   \   00000258   401E               SUBS     R0,R0,#+1
   \   0000025A   00D1               BNE      .+4
   \   0000025C   9DE0               B        ??main_23
   \   0000025E   401E               SUBS     R0,R0,#+1
   \   00000260   00D1               BNE      .+4
   \   00000262   A1E0               B        ??main_24
   \   00000264   401E               SUBS     R0,R0,#+1
   \   00000266   00D1               BNE      .+4
   \   00000268   A5E0               B        ??main_25
   \   0000026A   401E               SUBS     R0,R0,#+1
   \   0000026C   00D1               BNE      .+4
   \   0000026E   AFE0               B        ??main_26
   \   00000270   401E               SUBS     R0,R0,#+1
   \   00000272   0728               CMP      R0,#+7
   \   00000274   00D8               BHI      .+4
   \   00000276   BEE0               B        ??main_11
   \   00000278   B7E0               B        ??main_27
   1059                              
   1060                              case CANUSB_COMMAND_NOOP:
   1061                                // OK
   1062                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_21:
   \   0000027A   01A8               ADD      R0,SP,#+4
   \   0000027C   C178               LDRB     R1,[R0, #+3]
   \   0000027E   01A8               ADD      R0,SP,#+4
   \   00000280   8078               LDRB     R0,[R0, #+2]
   \   00000282   ........           BL       vs_sendAck
   \   00000286   B6E0               B        ??main_11
   1063                                break;
   1064                               
   1065                              case CANUSB_COMMAND_SET_BITRATE:
   1066                                
   1067                                CAN_EnterInitMode( CAN_CR_CCE | CAN_CR_IE | CAN_CR_EIE | CAN_CR_SIE );
   \                     ??main_22:
   \   00000288   4E20               MOVS     R0,#+78
   \   0000028A   ........           BL       CAN_EnterInitMode
   1068                                
   1069                                if ( 0 == serialFrame.data[ 0 ] ) {
   \   0000028E   01A8               ADD      R0,SP,#+4
   \   00000290   8079               LDRB     R0,[R0, #+6]
   \   00000292   0028               CMP      R0,#+0
   \   00000294   68D1               BNE      ??main_28
   1070                                                
   1071                                  // Standard baudrate
   1072                                  switch ( serialFrame.data[ 1 ] ) {
   \   00000296   01A8               ADD      R0,SP,#+4
   \   00000298   C079               LDRB     R0,[R0, #+7]
   \   0000029A   0028               CMP      R0,#+0
   \   0000029C   10D0               BEQ      ??main_29
   \   0000029E   401E               SUBS     R0,R0,#+1
   \   000002A0   12D0               BEQ      ??main_30
   \   000002A2   401E               SUBS     R0,R0,#+1
   \   000002A4   14D0               BEQ      ??main_31
   \   000002A6   401E               SUBS     R0,R0,#+1
   \   000002A8   16D0               BEQ      ??main_32
   \   000002AA   401E               SUBS     R0,R0,#+1
   \   000002AC   18D0               BEQ      ??main_33
   \   000002AE   401E               SUBS     R0,R0,#+1
   \   000002B0   1AD0               BEQ      ??main_34
   \   000002B2   401E               SUBS     R0,R0,#+1
   \   000002B4   1CD0               BEQ      ??main_35
   \   000002B6   401E               SUBS     R0,R0,#+1
   \   000002B8   1ED0               BEQ      ??main_36
   \   000002BA   401E               SUBS     R0,R0,#+1
   \   000002BC   20D0               BEQ      ??main_37
   \   000002BE   61E0               B        ??main_38
   1073                                  
   1074                                    case 0x00:      
   1075                                      CAN_SetBitrate( CAN_BITRATE_10K );
   \                     ??main_29:
   \   000002C0   0020               MOVS     R0,#+0
   \   000002C2   ........           BL       CAN_SetBitrate
   \   000002C6   5DE0               B        ??main_38
   1076                                      break;
   1077                                      
   1078                                    case 0x01:      
   1079                                      CAN_SetBitrate( CAN_BITRATE_20K );
   \                     ??main_30:
   \   000002C8   0120               MOVS     R0,#+1
   \   000002CA   ........           BL       CAN_SetBitrate
   \   000002CE   59E0               B        ??main_38
   1080                                      break;                            
   1081                                      
   1082                                    case 0x02:      
   1083                                      CAN_SetBitrate( CAN_BITRATE_50K );
   \                     ??main_31:
   \   000002D0   0220               MOVS     R0,#+2
   \   000002D2   ........           BL       CAN_SetBitrate
   \   000002D6   55E0               B        ??main_38
   1084                                      break;                            
   1085                                      
   1086                                    case 0x03:      
   1087                                      CAN_SetBitrate( CAN_BITRATE_100K );
   \                     ??main_32:
   \   000002D8   0320               MOVS     R0,#+3
   \   000002DA   ........           BL       CAN_SetBitrate
   \   000002DE   51E0               B        ??main_38
   1088                                      break;                            
   1089                                      
   1090                                    case 0x04:      
   1091                                      CAN_SetBitrate( CAN_BITRATE_125K );
   \                     ??main_33:
   \   000002E0   0420               MOVS     R0,#+4
   \   000002E2   ........           BL       CAN_SetBitrate
   \   000002E6   4DE0               B        ??main_38
   1092                                      break;                            
   1093                                    
   1094                                    case 0x05:      
   1095                                      CAN_SetBitrate( CAN_BITRATE_250K );
   \                     ??main_34:
   \   000002E8   0520               MOVS     R0,#+5
   \   000002EA   ........           BL       CAN_SetBitrate
   \   000002EE   49E0               B        ??main_38
   1096                                      break;                            
   1097                                      
   1098                                    case 0x06:      
   1099                                      CAN_SetBitrate( CAN_BITRATE_500K );
   \                     ??main_35:
   \   000002F0   0620               MOVS     R0,#+6
   \   000002F2   ........           BL       CAN_SetBitrate
   \   000002F6   45E0               B        ??main_38
   1100                                      break;                            
   1101                                      
   1102                                    case 0x07:      
   1103                                      CAN_SetBitrate( CAN_BITRATE_800K );
   \                     ??main_36:
   \   000002F8   0720               MOVS     R0,#+7
   \   000002FA   ........           BL       CAN_SetBitrate
   \   000002FE   41E0               B        ??main_38
   1104                                      break;                            
   1105                                      
   1106                                    case 0x08:      
   1107                                      CAN_SetBitrate( CAN_BITRATE_1M );
   \                     ??main_37:
   \   00000300   0820               MOVS     R0,#+8
   \   00000302   ........           BL       CAN_SetBitrate
   \   00000306   3DE0               B        ??main_38
   \                     ??main_0:
   \   00000308   CCFBFFFF           DC32     0xfffffbcc
   \   0000030C   ........           DC32     cntOutFrames
   \   00000310   ........           DC32     posOutFetch
   \   00000314   ........           DC32     posOutPut
   \   00000318   ........           DC32     cntInFrames
   \   0000031C   ........           DC32     posInFetch
   \   00000320   ........           DC32     posInPut
   \   00000324   ........           DC32     cntSentFrames
   \   00000328   ........           DC32     cntReceivedFrames
   \   0000032C   ........           DC32     cntSentData
   \   00000330   ........           DC32     cntReceivedData
   \   00000334   ........           DC32     cntBusWarnings
   \   00000338   ........           DC32     cntBusOff
   \   0000033C   ........           DC32     cntReceiveOverruns
   \   00000340   ........           DC32     cntTransmitOverruns
   \   00000344   ........           DC32     bBusOff
   \   00000348   ........           DC32     bBusWarn
   \   0000034C   ........           DC32     bErrorPassive
   \   00000350   ........           DC32     swReceive
   \   00000354   ........           DC32     swReceive + 4
   \   00000358   ........           DC32     swReceive + 8
   \   0000035C   ........           DC32     UsbCdcConfigure
   \   00000360   ........           DC32     CANAdapter_stateChange
   \   00000364   ........           DC32     CANAdapter_bOpen
   1108                                      break;                            
   1109                                  }
   1110                                  
   1111                                }
   1112                                else {
   1113                                  // Custom bitrate settings
   1114                                  CAN->BTR = 256 * serialFrame.data[ 1 ] + serialFrame.data[ 2 ];    
   \                     ??main_28:
   \   00000368   01A8               ADD      R0,SP,#+4
   \   0000036A   C079               LDRB     R0,[R0, #+7]
   \   0000036C   8021               MOVS     R1,#+128
   \   0000036E   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000370   4843               MULS     R0,R1,R0
   \   00000372   01A9               ADD      R1,SP,#+4
   \   00000374   097A               LDRB     R1,[R1, #+8]
   \   00000376   4018               ADDS     R0,R0,R1
   \   00000378   6D49               LDR      R1,??main_20+0x8  ;; 0xffffc40c
   \   0000037A   0880               STRH     R0,[R1, #+0]
   1115                                  CAN->BRPR = serialFrame.data[ 3 ];
   \   0000037C   01A8               ADD      R0,SP,#+4
   \   0000037E   407A               LDRB     R0,[R0, #+9]
   \   00000380   6C49               LDR      R1,??main_20+0xC  ;; 0xffffc418
   \   00000382   0880               STRH     R0,[R1, #+0]
   1116                                }
   1117                                
   1118                                CAN_LeaveInitMode();
   \                     ??main_38:
   \   00000384   ........           BL       CAN_LeaveInitMode
   1119                                CAN_LeaveTestMode();
   \   00000388   ........           BL       CAN_LeaveTestMode
   1120                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \   0000038C   01A8               ADD      R0,SP,#+4
   \   0000038E   C178               LDRB     R1,[R0, #+3]
   \   00000390   01A8               ADD      R0,SP,#+4
   \   00000392   8078               LDRB     R0,[R0, #+2]
   \   00000394   ........           BL       vs_sendAck
   \   00000398   2DE0               B        ??main_11
   1121                                break;
   1122                              
   1123                              case CANUSB_COMMAND_SET_FILTER:
   1124                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_23:
   \   0000039A   01A8               ADD      R0,SP,#+4
   \   0000039C   C178               LDRB     R1,[R0, #+3]
   \   0000039E   01A8               ADD      R0,SP,#+4
   \   000003A0   8078               LDRB     R0,[R0, #+2]
   \   000003A2   ........           BL       vs_sendAck
   \   000003A6   26E0               B        ??main_11
   1125                                break;
   1126                              
   1127                              case CANUSB_COMMAND_SET_MASK:
   1128                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_24:
   \   000003A8   01A8               ADD      R0,SP,#+4
   \   000003AA   C178               LDRB     R1,[R0, #+3]
   \   000003AC   01A8               ADD      R0,SP,#+4
   \   000003AE   8078               LDRB     R0,[R0, #+2]
   \   000003B0   ........           BL       vs_sendAck
   \   000003B4   1FE0               B        ??main_11
   1129                                break;
   1130                              
   1131                              case CANUSB_COMMAND_OPEN:
   1132                                setBlinkType( LED_GREEN_BLINK_FAST  );
   \                     ??main_25:
   \   000003B6   0520               MOVS     R0,#+5
   \   000003B8   ........           BL       setBlinkType
   1133                                CANAdapter_bOpen = TRUE;
   \   000003BC   5E48               LDR      R0,??main_20+0x10  ;; CANAdapter_bOpen
   \   000003BE   0121               MOVS     R1,#+1
   \   000003C0   0160               STR      R1,[R0, #+0]
   1134                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \   000003C2   01A8               ADD      R0,SP,#+4
   \   000003C4   C178               LDRB     R1,[R0, #+3]
   \   000003C6   01A8               ADD      R0,SP,#+4
   \   000003C8   8078               LDRB     R0,[R0, #+2]
   \   000003CA   ........           BL       vs_sendAck
   \   000003CE   12E0               B        ??main_11
   1135                                break;
   1136                              
   1137                              case CANUSB_COMMAND_CLOSE:
   1138                                setBlinkType( LED_GREEN_STEADY );
   \                     ??main_26:
   \   000003D0   0220               MOVS     R0,#+2
   \   000003D2   ........           BL       setBlinkType
   1139                                CANAdapter_bOpen = FALSE;
   \   000003D6   5848               LDR      R0,??main_20+0x10  ;; CANAdapter_bOpen
   \   000003D8   0021               MOVS     R1,#+0
   \   000003DA   0160               STR      R1,[R0, #+0]
   1140                                vs_sendAck( serialFrame.channel, serialFrame.seqnumber );
   \   000003DC   01A8               ADD      R0,SP,#+4
   \   000003DE   C178               LDRB     R1,[R0, #+3]
   \   000003E0   01A8               ADD      R0,SP,#+4
   \   000003E2   8078               LDRB     R0,[R0, #+2]
   \   000003E4   ........           BL       vs_sendAck
   \   000003E8   05E0               B        ??main_11
   1141                                break;
   1142                              
   1143                              case CANUSB_COMMAND_GET_STATUS:
   1144                                
   1145                                break;
   1146                              
   1147                              case CANUSB_COMMAND_GET_VERSION:
   1148                                
   1149                                break;
   1150                              
   1151                              case CANUSB_COMMAND_GET_SERIALNO:
   1152                                
   1153                                break;
   1154                              
   1155                              case CANUSB_COMMAND_FIND_BITRATE:
   1156                                
   1157                                break;
   1158                              
   1159                              case CANUSB_COMMAND_GET_STAT_FRAME:
   1160                                
   1161                                break;
   1162                              
   1163                              case CANUSB_COMMAND_GET_STAT_DATA:
   1164                                
   1165                                break;
   1166                              
   1167                              case CANUSB_COMMAND_GET_STAT_ERROR:
   1168                                
   1169                                break;
   1170                                
   1171                              case CANUSB_COMMAND_CLR_STAT:
   1172                                
   1173                                break;                      
   1174          
   1175                              default:
   1176                                // Unknown command
   1177                                vs_sendNack( serialFrame.channel, serialFrame.seqnumber );
   \                     ??main_27:
   \   000003EA   01A8               ADD      R0,SP,#+4
   \   000003EC   C178               LDRB     R1,[R0, #+3]
   \   000003EE   01A8               ADD      R0,SP,#+4
   \   000003F0   8078               LDRB     R0,[R0, #+2]
   \   000003F2   ........           BL       vs_sendNack
   1178                                break;
   1179                            }
   1180                            break;
   1181                            
   1182                        } // frame type
   1183                        
   1184                      } // get frame
   1185                      
   1186                    } // new frame
   1187                    
   1188                    // Next Character.
   1189                    readPos++;
   \                     ??main_11:
   \   000003F6   761C               ADDS     R6,R6,#+1
   1190                    
   1191                  } while( --readCnt );
   \   000003F8   6D1E               SUBS     R5,R5,#+1
   \   000003FA   002D               CMP      R5,#+0
   \   000003FC   00D0               BEQ      .+4
   \   000003FE   A8E6               B        ??main_10
   1192                  
   1193                } // Data available
   1194          
   1195                // Send frames to USB host if any pending
   1196                if ( CANAdapter_bOpen && ( cntInFrames > 0 ) ) { // Only if open
   \                     ??main_9:
   \   00000400   4D48               LDR      R0,??main_20+0x10  ;; CANAdapter_bOpen
   \   00000402   0068               LDR      R0,[R0, #+0]
   \   00000404   0028               CMP      R0,#+0
   \   00000406   00D1               BNE      .+4
   \   00000408   6AE6               B        ??main_1
   \   0000040A   4C48               LDR      R0,??main_20+0x14  ;; cntInFrames
   \   0000040C   0088               LDRH     R0,[R0, #+0]
   \   0000040E   0128               CMP      R0,#+1
   \   00000410   00D2               BCS      .+4
   \   00000412   65E6               B        ??main_1
   1197                  
   1198                  memcpy( &msg, &inputFrames[ posInFetch ], sizeof( canmsg )  );
   \   00000414   1422               MOVS     R2,#+20
   \   00000416   4A48               LDR      R0,??main_20+0x18  ;; posInFetch
   \   00000418   0088               LDRH     R0,[R0, #+0]
   \   0000041A   1421               MOVS     R1,#+20
   \   0000041C   4843               MULS     R0,R1,R0
   \   0000041E   4949               LDR      R1,??main_20+0x1C  ;; inputFrames
   \   00000420   0918               ADDS     R1,R1,R0
   \   00000422   07A8               ADD      R0,SP,#+28
   \   00000424   ........           BL       memcpy
   1199                  
   1200                  serialFrame.channel = com_channel;
   \   00000428   01A8               ADD      R0,SP,#+4
   \   0000042A   6946               MOV      R1,SP
   \   0000042C   4988               LDRH     R1,[R1, #+2]
   \   0000042E   8170               STRB     R1,[R0, #+2]
   1201          	serialFrame.seqnumber = seqnumber++;
   \   00000430   01A8               ADD      R0,SP,#+4
   \   00000432   C770               STRB     R7,[R0, #+3]
   \   00000434   7F1C               ADDS     R7,R7,#+1
   1202          	serialFrame.flags = 4 + 4 + msg.Dlc; // id + timestamp + dlc
   \   00000436   07A8               ADD      R0,SP,#+28
   \   00000438   007A               LDRB     R0,[R0, #+8]
   \   0000043A   0830               ADDS     R0,R0,#+8
   \   0000043C   01A9               ADD      R1,SP,#+4
   \   0000043E   4870               STRB     R0,[R1, #+1]
   1203          	serialFrame.data[ 3 ] = (uint8_t)(( msg.Id >> 0 ) & 0xff);
   \   00000440   01A8               ADD      R0,SP,#+4
   \   00000442   0899               LDR      R1,[SP, #+32]
   \   00000444   4172               STRB     R1,[R0, #+9]
   1204          	serialFrame.data[ 2 ] = (uint8_t)(( msg.Id >> 9 ) & 0xff);
   \   00000446   0898               LDR      R0,[SP, #+32]
   \   00000448   400A               LSRS     R0,R0,#+9
   \   0000044A   01A9               ADD      R1,SP,#+4
   \   0000044C   0872               STRB     R0,[R1, #+8]
   1205          	serialFrame.data[ 1 ] = (uint8_t)(( msg.Id >> 16 ) & 0xff);
   \   0000044E   0898               LDR      R0,[SP, #+32]
   \   00000450   000C               LSRS     R0,R0,#+16
   \   00000452   01A9               ADD      R1,SP,#+4
   \   00000454   C871               STRB     R0,[R1, #+7]
   1206          	serialFrame.data[ 0 ] = (uint8_t)(( msg.Id >> 24 ) & 0xff);
   \   00000456   0898               LDR      R0,[SP, #+32]
   \   00000458   000E               LSRS     R0,R0,#+24
   \   0000045A   01A9               ADD      R1,SP,#+4
   \   0000045C   8871               STRB     R0,[R1, #+6]
   1207                  if ( CAN_EXT_ID ==  msg.IdType ) {
   \   0000045E   0798               LDR      R0,[SP, #+28]
   \   00000460   0128               CMP      R0,#+1
   \   00000462   05D1               BNE      ??main_39
   1208          	  serialFrame.data[ 0 ] |= VSCP_SERIAL_CAN_DATA0_EXTENDED;
   \   00000464   01A8               ADD      R0,SP,#+4
   \   00000466   8079               LDRB     R0,[R0, #+6]
   \   00000468   8021               MOVS     R1,#+128
   \   0000046A   0143               ORRS     R1,R1,R0
   \   0000046C   01A8               ADD      R0,SP,#+4
   \   0000046E   8171               STRB     R1,[R0, #+6]
   1209                  }
   1210               
   1211                  
   1212                  // Data
   1213          	for ( i=0; i<msg.Dlc; i++ ) {
   \                     ??main_39:
   \   00000470   0020               MOVS     R0,#+0
   \   00000472   0400               MOVS     R4,R0
   \                     ??main_40:
   \   00000474   07A8               ADD      R0,SP,#+28
   \   00000476   007A               LDRB     R0,[R0, #+8]
   \   00000478   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   0000047A   240C               LSRS     R4,R4,#+16
   \   0000047C   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000047E   000C               LSRS     R0,R0,#+16
   \   00000480   8442               CMP      R4,R0
   \   00000482   0BD2               BCS      ??main_41
   1214          	  serialFrame.data[ 4 + i ] = msg.Data[ i ];	
   \   00000484   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000486   240C               LSRS     R4,R4,#+16
   \   00000488   01A8               ADD      R0,SP,#+4
   \   0000048A   0019               ADDS     R0,R0,R4
   \   0000048C   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   0000048E   240C               LSRS     R4,R4,#+16
   \   00000490   07A9               ADD      R1,SP,#+28
   \   00000492   0919               ADDS     R1,R1,R4
   \   00000494   497A               LDRB     R1,[R1, #+9]
   \   00000496   8172               STRB     R1,[R0, #+10]
   1215          	}
   \   00000498   641C               ADDS     R4,R4,#+1
   \   0000049A   EBE7               B        ??main_40
   1216                  
   1217                  // Timestamp  
   1218                  serialFrame.data[ 7 + msg.Dlc ] = (uint8_t)(( getSysTICs() >> 0 ) & 0xff);
   \                     ??main_41:
   \   0000049C   ........           BL       getSysTICs
   \   000004A0   07A9               ADD      R1,SP,#+28
   \   000004A2   097A               LDRB     R1,[R1, #+8]
   \   000004A4   01AA               ADD      R2,SP,#+4
   \   000004A6   5118               ADDS     R1,R2,R1
   \   000004A8   4873               STRB     R0,[R1, #+13]
   1219          	serialFrame.data[ 6 + msg.Dlc ] = (uint8_t)(( getSysTICs() >> 9 ) & 0xff);
   \   000004AA   ........           BL       getSysTICs
   \   000004AE   07A9               ADD      R1,SP,#+28
   \   000004B0   097A               LDRB     R1,[R1, #+8]
   \   000004B2   01AA               ADD      R2,SP,#+4
   \   000004B4   5118               ADDS     R1,R2,R1
   \   000004B6   400A               LSRS     R0,R0,#+9
   \   000004B8   0873               STRB     R0,[R1, #+12]
   1220          	serialFrame.data[ 5 + msg.Dlc ] = (uint8_t)(( getSysTICs() >> 16 ) & 0xff);
   \   000004BA   ........           BL       getSysTICs
   \   000004BE   07A9               ADD      R1,SP,#+28
   \   000004C0   097A               LDRB     R1,[R1, #+8]
   \   000004C2   01AA               ADD      R2,SP,#+4
   \   000004C4   5118               ADDS     R1,R2,R1
   \   000004C6   000C               LSRS     R0,R0,#+16
   \   000004C8   C872               STRB     R0,[R1, #+11]
   1221          	serialFrame.data[ 4 + msg.Dlc ] = (uint8_t)(( getSysTICs() >> 24 ) & 0xff);
   \   000004CA   ........           BL       getSysTICs
   \   000004CE   07A9               ADD      R1,SP,#+28
   \   000004D0   097A               LDRB     R1,[R1, #+8]
   \   000004D2   01AA               ADD      R2,SP,#+4
   \   000004D4   5118               ADDS     R1,R2,R1
   \   000004D6   000E               LSRS     R0,R0,#+24
   \   000004D8   8872               STRB     R0,[R1, #+10]
   1222                  
   1223          	serialFrame.opcode = VSCP_SERIAL_OPCODE_CAN_FRAME;
   \   000004DA   6846               MOV      R0,SP
   \   000004DC   0521               MOVS     R1,#+5
   \   000004DE   0171               STRB     R1,[R0, #+4]
   1224          	serialFrame.vscpclass = 0;
   \   000004E0   01A8               ADD      R0,SP,#+4
   \   000004E2   0021               MOVS     R1,#+0
   \   000004E4   0171               STRB     R1,[R0, #+4]
   1225          	serialFrame.vscptype = 0;
   \   000004E6   01A8               ADD      R0,SP,#+4
   \   000004E8   0021               MOVS     R1,#+0
   \   000004EA   4171               STRB     R1,[R0, #+5]
   1226          	
   1227          	vs_sendFrame( &serialFrame );
   \   000004EC   01A8               ADD      R0,SP,#+4
   \   000004EE   ........           BL       vs_sendFrame
   1228                  
   1229                  posInFetch++;
   \   000004F2   1348               LDR      R0,??main_20+0x18  ;; posInFetch
   \   000004F4   0088               LDRH     R0,[R0, #+0]
   \   000004F6   401C               ADDS     R0,R0,#+1
   \   000004F8   1149               LDR      R1,??main_20+0x18  ;; posInFetch
   \   000004FA   0880               STRH     R0,[R1, #+0]
   1230                  if ( posInFetch >= MAX_IN_FRAMES ) posInFetch = 0;
   \   000004FC   1048               LDR      R0,??main_20+0x18  ;; posInFetch
   \   000004FE   0088               LDRH     R0,[R0, #+0]
   \   00000500   1028               CMP      R0,#+16
   \   00000502   02D3               BCC      ??main_42
   \   00000504   0E48               LDR      R0,??main_20+0x18  ;; posInFetch
   \   00000506   0021               MOVS     R1,#+0
   \   00000508   0180               STRH     R1,[R0, #+0]
   1231                  cntInFrames--;
   \                     ??main_42:
   \   0000050A   0C48               LDR      R0,??main_20+0x14  ;; cntInFrames
   \   0000050C   0088               LDRH     R0,[R0, #+0]
   \   0000050E   401E               SUBS     R0,R0,#+1
   \   00000510   0A49               LDR      R1,??main_20+0x14  ;; cntInFrames
   \   00000512   0880               STRH     R0,[R1, #+0]
   \   00000514   E4E5               B        ??main_1
   1232                  
   1233                }
   1234                
   1235          
   1236                // Data from UART
   1237                //readCnt = UartRead( UART, Buffer, sizeof( Buffer ) - 1 );
   1238                //if ( readCnt ) {
   1239                //  while(!UsbCdcWrite( Buffer, readCnt ) );
   1240                //}
   1241                //else {
   1242                //  strcpy( Buffer, "Hello World\n" );
   1243                //  UsbCdcWriteTimeout( Buffer, 100 );
   1244                //}
   1245              } // USB configured
   1246              else {
   1247                if ( TRUE == CdcConfigureStateHold ) {
   \                     ??main_2:
   \   00000516   6846               MOV      R0,SP
   \   00000518   0078               LDRB     R0,[R0, #+0]
   \   0000051A   0128               CMP      R0,#+1
   \   0000051C   00D0               BEQ      .+4
   \   0000051E   DFE5               B        ??main_1
   1248                  CdcConfigureStateHold = FALSE;
   \   00000520   6846               MOV      R0,SP
   \   00000522   0021               MOVS     R1,#+0
   \   00000524   0170               STRB     R1,[R0, #+0]
   \   00000526   DBE5               B        ??main_1
   \                     ??main_20:
   \   00000528   ........           DC32     lastAck
   \   0000052C   ........           DC32     outputFrames
   \   00000530   0CC4FFFF           DC32     0xffffc40c
   \   00000534   18C4FFFF           DC32     0xffffc418
   \   00000538   ........           DC32     CANAdapter_bOpen
   \   0000053C   ........           DC32     cntInFrames
   \   00000540   ........           DC32     posInFetch
   \   00000544   ........           DC32     inputFrames
   1249                }
   1250              }
   1251            } // Main loop
   1252          }
   1253          
   1254          ///////////////////////////////////////////////////////////////////////////////
   1255          // UsbCdcWriteTimeout
   1256          //
   1257          

   \                                 In section .text, align 4, keep-with-next
   1258          Boolean UsbCdcWriteTimeout( uint8_t *Buffer, uint16_t count, uint32_t timeout ) 
   1259          {
   \                     UsbCdcWriteTimeout:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
   1260            uint32_t tics = getSysTICs();
   \   00000008   ........           BL       getSysTICs
   \   0000000C   0700               MOVS     R7,R0
   1261            
   1262            while ( getElapsedSysTICs( tics ) < timeout ) {
   \                     ??UsbCdcWriteTimeout_0:
   \   0000000E   3800               MOVS     R0,R7
   \   00000010   ........           BL       getElapsedSysTICs
   \   00000014   B042               CMP      R0,R6
   \   00000016   09D2               BCS      ??UsbCdcWriteTimeout_1
   1263              if ( UsbCdcWrite( Buffer, count ) ) return TRUE;   
   \   00000018   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   0000001A   2D0C               LSRS     R5,R5,#+16
   \   0000001C   2900               MOVS     R1,R5
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   ........           BL       UsbCdcWrite
   \   00000024   0028               CMP      R0,#+0
   \   00000026   F2D0               BEQ      ??UsbCdcWriteTimeout_0
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   00E0               B        ??UsbCdcWriteTimeout_2
   1264            }
   1265            
   1266            return FALSE;
   \                     ??UsbCdcWriteTimeout_1:
   \   0000002C   0020               MOVS     R0,#+0
   \                     ??UsbCdcWriteTimeout_2:
   \   0000002E   F8BC               POP      {R3-R7}
   \   00000030   02BC               POP      {R1}
   \   00000032   0847               BX       R1               ;; return
   1267          }
   1268          
   1269          
   1270          ///////////////////////////////////////////////////////////////////////////////
   1271          // vs_sendBuffer
   1272          //
   1273          // This routine is required by the VSCP serial protocol. 
   1274          //
   1275          

   \                                 In section .text, align 4, keep-with-next
   1276          BOOL vs_sendBuffer( uint8_t *pbuf, uint16_t count  )
   1277          {
   \                     vs_sendBuffer:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   1278            // UsbCdcWrite( pbuf, count );
   1279            //while ( !UsbCdcWrite( pbuf, count ) );
   1280            if ( !UsbCdcWriteTimeout(  pbuf, count, 500 ) ) {
   \   00000006   FA22               MOVS     R2,#+250
   \   00000008   5200               LSLS     R2,R2,#+1        ;; #+500
   \   0000000A   2900               MOVS     R1,R5
   \   0000000C   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000000E   090C               LSRS     R1,R1,#+16
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       UsbCdcWriteTimeout
   \   00000016   401E               SUBS     R0,R0,#+1
   \   00000018   8041               SBCS     R0,R0,R0
   \   0000001A   C043               MVNS     R0,R0
   \   0000001C   C00F               LSRS     R0,R0,#+31
   1281              return FALSE;  
   \   0000001E   38BC               POP      {R3-R5}
   \   00000020   02BC               POP      {R1}
   \   00000022   0847               BX       R1               ;; return
   1282            }
   1283              
   1284            return TRUE;
   1285          }
   1286          
   1287          ///////////////////////////////////////////////////////////////////////////////
   1288          // vs_sendSerialByte
   1289          //
   1290          // This routine is required by the VSCP serial protocol. 
   1291          //
   1292          

   \                                 In section .text, align 4, keep-with-next
   1293          vs_sendSerialByte( uint8_t b )
   1294          {
   \                     vs_sendSerialByte:
   \   00000000   01B5               PUSH     {R0,LR}
   1295            if ( !UsbCdcWriteTimeout( &b, 1, 500 ) ) {
   \   00000002   FA22               MOVS     R2,#+250
   \   00000004   5200               LSLS     R2,R2,#+1        ;; #+500
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   6846               MOV      R0,SP
   \   0000000A   ........           BL       UsbCdcWriteTimeout
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   8041               SBCS     R0,R0,R0
   \   00000012   C043               MVNS     R0,R0
   \   00000014   C00F               LSRS     R0,R0,#+31
   1296              return FALSE;  
   \   00000016   08BC               POP      {R3}
   \   00000018   02BC               POP      {R1}
   \   0000001A   0847               BX       R1               ;; return
   1297            }
   1298              
   1299            return TRUE;
   1300          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     DlyCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   008CFFFF           DC32     0xffff8c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   00E4FFFF           DC32     0xffffe400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     blink_state_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     blink_type

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     CANAdapter_stateChange

   Maximum stack usage in bytes:

     Function           .cstack
     --------           -------
     CAN_Com_IRQ            32
     CAN_Com_Polling         8
     CAN_ISR                32
     Dly100us                8
     IO_Init                32
     InitClock               8
     InitDlyTimer           72
     Tim0Handler             8
     UsbCdcWriteTimeout     24
     blink                   8
     init_CAN               32
     ledOff                  8
     ledOn                   8
     main                 1096
     memcpy                 16
     sendMessage            32
     setBlinkType            0
     vs_sendBuffer          16
     vs_sendSerialByte       8


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     memcpy                        26
     RxCanMsg                      20
     serial_out_pos                 4
     serial_out_buf               256
     cntOutFrames                   2
     posOutFetch                    2
     posOutPut                      2
     outputFrames                 320
     cntInFrames                    2
     posInFetch                     2
     posInPut                       2
     inputFrames                  320
     lastAck                        1
     cntSentFrames                  4
     cntReceivedFrames              4
     cntSentData                    4
     cntReceivedData                4
     cntBusWarnings                 4
     cntBusOff                      4
     cntReceiveOverruns             4
     cntTransmitOverruns            4
     bBusOff                        4
     bBusWarn                       4
     bErrorPassive                  4
     blink_state_time               4
     blink_state                    1
     blink_type                     1
     canstatus                      1
     swReceiveFrames              280
     swReceive                    292
     CANAdapter_bOpen               4
     CANAdapter_bSendErrorFrames    4
     CANAdapter_modeOpen            1
     CANAdapter_stateChange         1
     TxCanMsg                      60
     InitClock                     50
     DlyCount                       4
     Tim0Handler                   34
     InitDlyTimer                 116
     Dly100us                      66
     IO_Init                      160
     ledOn                         46
     ledOff                        46
     setBlinkType                  18
     blink                        604
     CAN_Com_Polling               36
     CAN_Com_IRQ                  144
     init_CAN                     228
     sendMessage                  284
     CAN_ISR                      388
     main                        1352
     UsbCdcWriteTimeout            52
     vs_sendBuffer                 36
     vs_sendSerialByte             28
     ??DataTable9                   4
     ??DataTable11                  4
     ??DataTable20                  4
     ??DataTable21                  4
     ??DataTable22                  4
     ??DataTable23                  4
      Others                       16

 
 1 569 bytes in section .bss
    61 bytes in section .data
 3 754 bytes in section .text
 
 3 712 bytes of CODE memory (+ 42 bytes shared)
 1 630 bytes of DATA memory

Errors: none
Warnings: 4
