###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:23 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Program\IAR Systems\Embedded Workbench                #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _mrcc.c                                                  #
#    Command line =  "D:\Program\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _mrcc.c" -lC D:\development\gediminas\CAN4USB\project\RE #
#                    LEASE\List\ -lA D:\development\gediminas\CAN4USB\project #
#                    \RELEASE\List\ -o D:\development\gediminas\CAN4USB\proje #
#                    ct\RELEASE\Obj\ --no_cse --no_unroll --no_inline         #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian little --cpu            #
#                    ARM7TDMI-S -e --fpu None --dlib_config "D:\Program\IAR   #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I D:\development\gediminas\CAN4USB\project\ -I     #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\75 #
#                    x_mrcc.lst                                               #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\75x #
#                    _mrcc.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Program\IAR Systems\Embedded Workbench 5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x_mrcc.c
      1          /******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
      2          * File Name          : 75x_mrcc.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 03/10/2006
      5          * Description        : This file provides all the MRCC software functions.
      6          ********************************************************************************
      7          * History:
      8          * 07/17/2006 : V1.0
      9          * 03/10/2006 : V0.1
     10          ********************************************************************************
     11          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     13          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     14          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     15          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     16          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *******************************************************************************/
     18          
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "75x_mrcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          #define MRCC_FLAG_Mask    0x1F    /* MRCC Flag Mask */
     25          
     26          /* MRCC_PWRCTRL mask bits */
     27          #define MRCC_LP_Set_Mask             0x00000001
     28          #define MRCC_LP_Reset_Mask           0xFFFFFFFE
     29          #define MRCC_SWRESET_Mask            0x00000002
     30          #define MRCC_WFI_Mask                0x00000004
     31          #define MRCC_STANDBY_Mask            0x00000006
     32          #define MRCC_LPMC_Reset_Mask         0xFFFFFFF9
     33          #define MRCC_LPDONE_Reset_Mask       0xFFFFFF7F
     34          #define MRCC_LPPARAM_Reset_Mask      0xFFFF1FFF
     35          #define MRCC_WFIParam_Reset_Mask     0xFFFF1FEF
     36          #define MRCC_CKRTCSEL_Set_Mask       0x03000000
     37          #define MRCC_CKRTCSEL_Reset_Mask     0xFCFFFFFF
     38          #define MRCC_CKRTCOK_Mask            0x08000000
     39          #define MRCC_LPOSCEN_Mask            0x10000000
     40          #define MRCC_OSC32KEN_Mask           0x20000000
     41                      
     42          /* MRCC_CLKCTL mask bits */
     43          #define MRCC_PPRESC_Set_Mask        0x00000003
     44          #define MRCC_PPRESC_Reset_Mask      0xFFFFFFFC
     45          #define MRCC_PPRESC2_Mask           0x00000004
     46          #define MRCC_HPRESC_Set_Mask        0x00000018
     47          #define MRCC_HPRESC_Reset_Mask      0xFFFFFFE7
     48          #define MRCC_MCOS_Reset_Mask        0xFFFFFF3F
     49          #define MRCC_XTDIV2_Set_Mask        0x00008000
     50          #define MRCC_XTDIV2_Reset_Mask      0xFFFF7FFF
     51          #define MRCC_OSC4MBYP_Set_Mask      0x00010000
     52          #define MRCC_OSC4MBYP_Reset_Mask    0xFFFEFFFF
     53          #define MRCC_OSC4MOFF_Set_Mask      0x00020000  
     54          #define MRCC_OSC4MOFF_Reset_Mask    0xFFFDFFFF
     55          #define MRCC_NCKDF_Set_Mask         0x00040000
     56          #define MRCC_NCKDF_Reset_Mask       0xFFFBFFFF
     57          #define MRCC_CKOSCSEL_Set_Mask      0x00200000
     58          #define MRCC_CKOSCSEL_Reset_Mask    0xFFDFFFFF
     59          #define MRCC_CKUSBSEL_Mask          0x00400000
     60          #define MRCC_CKSEL_Set_Mask         0x00800000
     61          #define MRCC_CKSEL_Reset_Mask       0xFF7FFFFF
     62          #define MRCC_CKSEL_CKOSCSEL_Mask    0x00A00000
     63          #define MRCC_PLLEN_Set_Mask         0x01000000
     64          #define MRCC_PLLEN_Reset_Mask       0xFEFFFFFF
     65          #define MRCC_PLL2EN_Set_Mask        0x02000000
     66          #define MRCC_PLL2EN_Reset_Mask      0xFDFFFFFF
     67          #define MRCC_MX_Set_Mask            0x18000000
     68          #define MRCC_MX_Reset_Mask          0xE7FFFFFF
     69          #define MRCC_LOCK_Mask              0x80000000
     70          #define MRCC_PLLEN_LOCK_Mask        0x81000000
     71          
     72          /* Typical Value of the OSC4M in Hz */
     73          #define OSC4M_Value    4000000   
     74          
     75          /* Typical Value of the OSC4M divided by 128 (used to clock the RTC) in Hz */
     76          #define OSC4M_Div128_Value    31250
     77             
     78          /* Typical Value of the OS32K Oscillator Frequency in Hz */
     79          #define OSC32K_Value    32768     
     80          
     81          /* Typical Reset Value of the Internal LPOSC Oscillator Frequency in Hz */
     82          #define LPOSC_Value    245000   
     83          
     84          /* Typical Reset Value of the Internal FREEOSC Oscillator Frequency in Hz */
     85          #define FREEOSC_Value    5000000 
     86          
     87          /* Time out for OSC4M start up */
     88          #define OSC4MStartUp_TimeOut   0xFE
     89          
     90          /* Private macro -------------------------------------------------------------*/
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private function prototypes -----------------------------------------------*/
     93          static ErrorStatus SetCKSYS_FREEOSC(void);
     94          static ErrorStatus SetCKSYS_OSC4M(u32 PLL_State);
     95          static ErrorStatus SetCKSYS_OSC4MPLL(u32 PLL_Mul);
     96          static ErrorStatus SetCKSYS_RTC(u32 PLL_State);
     97          static void WriteLPBit(void);
     98          static void WriteCKOSCSELBit(void);
     99          
    100          /* Private functions ---------------------------------------------------------*/
    101          
    102          /*******************************************************************************
    103          * Function Name  : MRCC_DeInit
    104          * Description    : Deinitializes the MRCC peripheral registers to their default
    105          *                  reset values. 
    106          *                   - Depending on the system clock state, some bits in MRCC_CLKCTL
    107          *                     register can’t be reset.
    108          *                   - The OSC32K, LPOSC and RTC clock selection configuration 
    109          *                     bits in MRCC_PWRCTRL register are not cleared by this  
    110          *                     function. To reset those bits, use the dedicated functions 
    111          *                     available within this driver.
    112          *                   - The MRCC_RFSR, MRCC_BKP0 and MRCC_BKP1 registers are not
    113          *                     reset by this function.
    114          * Input          : None
    115          * Output         : None
    116          * Return         : None
    117          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    118          void MRCC_DeInit(void)
    119          {
   \                     MRCC_DeInit:
   \   00000000   01B5               PUSH     {R0,LR}
    120            /* Try to clear NCKDF bit */
    121            MRCC->CLKCTL &= MRCC_NCKDF_Reset_Mask;
   \   00000002   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   2C49               LDR      R1,??MRCC_DeInit_0  ;; 0xfffbffff
   \   00000008   0140               ANDS     R1,R1,R0
   \   0000000A   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000000C   0160               STR      R1,[R0, #+0]
    122          
    123            if((MRCC->CLKCTL & MRCC_NCKDF_Set_Mask) != RESET)
   \   0000000E   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   4003               LSLS     R0,R0,#+13
   \   00000014   0CD5               BPL      ??MRCC_DeInit_1
    124            {/* No clock detected on OSC4M */
    125          
    126              /* Reset LOCKIE, LOCKIF, CKUSBSEL, NCKDIE, OSC4MOFF, OSC4MBYP, MCOS[1:0], 
    127                 MCOP, HPRESC[1:0], PPRES[2:0] bits */
    128              MRCC->CLKCTL &= 0x9FB40000;
   \   00000016   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   2849               LDR      R1,??MRCC_DeInit_0+0x4  ;; 0x9fb40000
   \   0000001C   0140               ANDS     R1,R1,R0
   \   0000001E   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000020   0160               STR      R1,[R0, #+0]
    129               
    130              if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \   00000022   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   8002               LSLS     R0,R0,#+10
   \   00000028   31D5               BPL      ??MRCC_DeInit_2
    131              { 
    132                /* Clear CKOSCSEL bit --------------------------------------------------*/         
    133                /* Execute CKOSCSEL bit writing sequence */
    134                WriteCKOSCSELBit();
   \   0000002A   ........           BL       WriteCKOSCSELBit
   \   0000002E   2EE0               B        ??MRCC_DeInit_2
    135              }
    136            }
    137            else
    138            {/* Clock present on OSC4M */
    139          
    140              if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \                     ??MRCC_DeInit_1:
   \   00000030   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   8002               LSLS     R0,R0,#+10
   \   00000036   07D5               BPL      ??MRCC_DeInit_3
    141              { 
    142                /* Reset CKSEL bit */
    143                MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   00000038   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   ....               LDR      R1,??DataTable19  ;; 0xff7fffff
   \   0000003E   0140               ANDS     R1,R1,R0
   \   00000040   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000042   0160               STR      R1,[R0, #+0]
    144          
    145                /* Clear CKOSCSEL bit --------------------------------------------------*/
    146                /* Execute CKOSCSEL bit writing sequence */
    147                WriteCKOSCSELBit();
   \   00000044   ........           BL       WriteCKOSCSELBit
    148              }
    149          
    150              if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) == RESET)
   \                     ??MRCC_DeInit_3:
   \   00000048   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   0002               LSLS     R0,R0,#+8
   \   0000004E   06D4               BMI      ??MRCC_DeInit_4
    151              {
    152                /* Set CKSEL bit */
    153                MRCC->CLKCTL |= MRCC_CKSEL_Set_Mask;  
   \   00000050   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000052   0068               LDR      R0,[R0, #+0]
   \   00000054   8021               MOVS     R1,#+128
   \   00000056   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000058   0143               ORRS     R1,R1,R0
   \   0000005A   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000005C   0160               STR      R1,[R0, #+0]
    154              }
    155          
    156              /* Disable PLL */
    157              MRCC->CLKCTL &= MRCC_PLLEN_Reset_Mask;
   \                     ??MRCC_DeInit_4:
   \   0000005E   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000060   0068               LDR      R0,[R0, #+0]
   \   00000062   ....               LDR      R1,??DataTable36  ;; 0xfeffffff
   \   00000064   0140               ANDS     R1,R1,R0
   \   00000066   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000068   0160               STR      R1,[R0, #+0]
    158          
    159              /* Reset LOCKIE, LOCKIF, MX[1:0], CKUSBSEL, NCKDIE, MCOS[1:0], MCOP,
    160                 HPRESC[1:0], PPRES[2:0] bits */
    161              MRCC->CLKCTL &= 0x87B70000;
   \   0000006A   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000006C   0068               LDR      R0,[R0, #+0]
   \   0000006E   1449               LDR      R1,??MRCC_DeInit_0+0x8  ;; 0x87b70000
   \   00000070   0140               ANDS     R1,R1,R0
   \   00000072   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000074   0160               STR      R1,[R0, #+0]
    162          
    163              /* Reset CKSEL bit */
    164              MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   00000076   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000078   0068               LDR      R0,[R0, #+0]
   \   0000007A   ....               LDR      R1,??DataTable19  ;; 0xff7fffff
   \   0000007C   0140               ANDS     R1,R1,R0
   \   0000007E   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000080   0160               STR      R1,[R0, #+0]
    165          
    166              /* Reset OSC4MOFF and OSC4MBYP bits */
    167              MRCC->CLKCTL &= 0xFFFCFFFF;   
   \   00000082   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000084   0068               LDR      R0,[R0, #+0]
   \   00000086   ....               LDR      R1,??DataTable22  ;; 0xfffcffff
   \   00000088   0140               ANDS     R1,R1,R0
   \   0000008A   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000008C   0160               STR      R1,[R0, #+0]
    168            }
    169          
    170            /* Reset RTCM, EN33V, LP_PARAM[15:13], WFI_FLASH_EN, LPMC_DBG and LPMC[1:0] bits */
    171            MRCC->PWRCTRL &= 0xFBFE1FE1;
   \                     ??MRCC_DeInit_2:
   \   0000008E   ....               LDR      R0,??DataTable49  ;; 0x60000028
   \   00000090   0068               LDR      R0,[R0, #+0]
   \   00000092   0C49               LDR      R1,??MRCC_DeInit_0+0xC  ;; 0xfbfe1fe1
   \   00000094   0140               ANDS     R1,R1,R0
   \   00000096   ....               LDR      R0,??DataTable49  ;; 0x60000028
   \   00000098   0160               STR      R1,[R0, #+0]
    172            
    173            /* Reset PCLKEN register bits */
    174            MRCC->PCLKEN = 0x00;
   \   0000009A   ....               LDR      R0,??DataTable26  ;; 0x60000030
   \   0000009C   0021               MOVS     R1,#+0
   \   0000009E   0160               STR      R1,[R0, #+0]
    175            
    176            /* Reset PSWRES register bits */
    177            MRCC->PSWRES = 0x00;  
   \   000000A0   ....               LDR      R0,??DataTable27  ;; 0x60000034
   \   000000A2   0021               MOVS     R1,#+0
   \   000000A4   0160               STR      R1,[R0, #+0]
    178          
    179            /* Clear NCKDF bit */
    180            MRCC->CLKCTL &= MRCC_NCKDF_Reset_Mask; 
   \   000000A6   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   000000A8   0068               LDR      R0,[R0, #+0]
   \   000000AA   0349               LDR      R1,??MRCC_DeInit_0  ;; 0xfffbffff
   \   000000AC   0140               ANDS     R1,R1,R0
   \   000000AE   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   000000B0   0160               STR      R1,[R0, #+0]
    181          }
   \   000000B2   08BC               POP      {R3}
   \   000000B4   01BC               POP      {R0}
   \   000000B6   0047               BX       R0               ;; return
   \                     ??MRCC_DeInit_0:
   \   000000B8   FFFFFBFF           DC32     0xfffbffff
   \   000000BC   0000B49F           DC32     0x9fb40000
   \   000000C0   0000B787           DC32     0x87b70000
   \   000000C4   E11FFEFB           DC32     0xfbfe1fe1
    182          
    183          /*******************************************************************************
    184          * Function Name  : MRCC_XTDIV2Config
    185          * Description    : Enables or disables the oscillator divider by 2. This function
    186          *                  must not be used when the PLL is enabled.
    187          * Input          : - MRCC_XTDIV2: specifies the new state of the oscillator 
    188          *                    divider by 2.
    189          *                    This parameter can be one of the following values:
    190          *                          - MRCC_XTDIV2_Disable: oscillator divider by 2 disbaled
    191          *                          - MRCC_XTDIV2_Enable: oscillator divider by 2 enbaled
    192          * Output         : None
    193          * Return         : None
    194          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    195          void MRCC_XTDIV2Config(u32 MRCC_XTDIV2)
    196          {
   \                     MRCC_XTDIV2Config:
   \   00000000   01B5               PUSH     {R0,LR}
    197            if(MRCC_XTDIV2 == MRCC_XTDIV2_Enable)
   \   00000002   8021               MOVS     R1,#+128
   \   00000004   0902               LSLS     R1,R1,#+8        ;; #+32768
   \   00000006   8842               CMP      R0,R1
   \   00000008   07D1               BNE      ??MRCC_XTDIV2Config_0
    198            {
    199              MRCC->CLKCTL |= MRCC_XTDIV2_Enable;
   \   0000000A   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   8022               MOVS     R2,#+128
   \   00000010   1202               LSLS     R2,R2,#+8        ;; #+32768
   \   00000012   0A43               ORRS     R2,R2,R1
   \   00000014   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   00000016   0A60               STR      R2,[R1, #+0]
   \   00000018   05E0               B        ??MRCC_XTDIV2Config_1
    200            }
    201            else
    202            {
    203              MRCC->CLKCTL &= MRCC_XTDIV2_Disable;
   \                     ??MRCC_XTDIV2Config_0:
   \   0000001A   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   034A               LDR      R2,??MRCC_XTDIV2Config_2  ;; 0xffff7fff
   \   00000020   0A40               ANDS     R2,R2,R1
   \   00000022   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   00000024   0A60               STR      R2,[R1, #+0]
    204            }  
    205          }
   \                     ??MRCC_XTDIV2Config_1:
   \   00000026   08BC               POP      {R3}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??MRCC_XTDIV2Config_2:
   \   0000002C   FF7FFFFF           DC32     0xffff7fff
    206          
    207          /*******************************************************************************
    208          * Function Name  : MRCC_CKSYSConfig
    209          * Description    : Configures the system clock (CK_SYS).
    210          * Input          : - MRCC_CKSYS: specifies the clock source used as system clock.
    211          *                    This parameter can be one of the following values:
    212          *                          - MRCC_CKSYS_FREEOSC
    213          *                          - MRCC_CKSYS_OSC4M
    214          *                          - MRCC_CKSYS_OSC4MPLL
    215          *                          - MRCC_CKSYS_RTC (RTC clock source must be previously
    216          *                            configured using MRCC_CKRTCConfig() function)
    217          *                : - MRCC_PLL: specifies the PLL configuration.
    218          *                    This parameter can be one of the following values:
    219          *                          - MRCC_PLL_Disabled: PLL disabled
    220          *                          - MRCC_PLL_NoChange: No change on PLL configuration
    221          *                          - MRCC_PLL_Mul_12: Multiplication by 12
    222          *                          - MRCC_PLL_Mul_14: Multiplication by 14
    223          *                          - MRCC_PLL_Mul_15: Multiplication by 15
    224          *                          - MRCC_PLL_Mul_16: Multiplication by 16
    225          * Output         : None
    226          * Return         : An ErrorStatus enumuration value:
    227          *                         - SUCCESS: Clock configuration succeeded
    228          *                         - ERROR: Clock configuration failed
    229          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    230          ErrorStatus MRCC_CKSYSConfig(u32 MRCC_CKSYS, u32 MRCC_PLL)
    231          {
   \                     MRCC_CKSYSConfig:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
    232            ErrorStatus Status = ERROR;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0500               MOVS     R5,R0
    233          
    234            switch(MRCC_CKSYS)
   \   0000000A   3000               MOVS     R0,R6
   \   0000000C   401E               SUBS     R0,R0,#+1
   \   0000000E   06D0               BEQ      ??MRCC_CKSYSConfig_0
   \   00000010   401E               SUBS     R0,R0,#+1
   \   00000012   0DD0               BEQ      ??MRCC_CKSYSConfig_1
   \   00000014   401E               SUBS     R0,R0,#+1
   \   00000016   15D0               BEQ      ??MRCC_CKSYSConfig_2
   \   00000018   401E               SUBS     R0,R0,#+1
   \   0000001A   26D0               BEQ      ??MRCC_CKSYSConfig_3
   \   0000001C   2FE0               B        ??MRCC_CKSYSConfig_4
    235            {
    236              case MRCC_CKSYS_FREEOSC:
    237                if((MRCC_PLL == MRCC_PLL_Disabled) || (MRCC_PLL == MRCC_PLL_NoChange))
   \                     ??MRCC_CKSYSConfig_0:
   \   0000001E   ....               LDR      R0,??DataTable36  ;; 0xfeffffff
   \   00000020   8442               CMP      R4,R0
   \   00000022   01D0               BEQ      ??MRCC_CKSYSConfig_5
   \   00000024   012C               CMP      R4,#+1
   \   00000026   2CD1               BNE      ??MRCC_CKSYSConfig_6
    238                {
    239                  Status = SetCKSYS_FREEOSC();
   \                     ??MRCC_CKSYSConfig_5:
   \   00000028   ........           BL       SetCKSYS_FREEOSC
   \   0000002C   0500               MOVS     R5,R0
   \   0000002E   28E0               B        ??MRCC_CKSYSConfig_6
    240                }
    241                break;
    242          
    243              case MRCC_CKSYS_OSC4M:
    244                if((MRCC_PLL == MRCC_PLL_Disabled) || (MRCC_PLL == MRCC_PLL_NoChange))
   \                     ??MRCC_CKSYSConfig_1:
   \   00000030   ....               LDR      R0,??DataTable36  ;; 0xfeffffff
   \   00000032   8442               CMP      R4,R0
   \   00000034   01D0               BEQ      ??MRCC_CKSYSConfig_7
   \   00000036   012C               CMP      R4,#+1
   \   00000038   23D1               BNE      ??MRCC_CKSYSConfig_6
    245                {
    246                  Status = SetCKSYS_OSC4M(MRCC_PLL);
   \                     ??MRCC_CKSYSConfig_7:
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ........           BL       SetCKSYS_OSC4M
   \   00000040   0500               MOVS     R5,R0
   \   00000042   1EE0               B        ??MRCC_CKSYSConfig_6
    247                }
    248                break;
    249          
    250              case MRCC_CKSYS_OSC4MPLL:
    251                if((MRCC_PLL == MRCC_PLL_Mul_12) || (MRCC_PLL == MRCC_PLL_Mul_14) ||
    252                   (MRCC_PLL == MRCC_PLL_Mul_15) || (MRCC_PLL == MRCC_PLL_Mul_16))
   \                     ??MRCC_CKSYSConfig_2:
   \   00000044   C020               MOVS     R0,#+192
   \   00000046   4005               LSLS     R0,R0,#+21       ;; #+402653184
   \   00000048   8442               CMP      R4,R0
   \   0000004A   09D0               BEQ      ??MRCC_CKSYSConfig_8
   \   0000004C   8020               MOVS     R0,#+128
   \   0000004E   4005               LSLS     R0,R0,#+21       ;; #+268435456
   \   00000050   8442               CMP      R4,R0
   \   00000052   05D0               BEQ      ??MRCC_CKSYSConfig_8
   \   00000054   8020               MOVS     R0,#+128
   \   00000056   0005               LSLS     R0,R0,#+20       ;; #+134217728
   \   00000058   8442               CMP      R4,R0
   \   0000005A   01D0               BEQ      ??MRCC_CKSYSConfig_8
   \   0000005C   002C               CMP      R4,#+0
   \   0000005E   10D1               BNE      ??MRCC_CKSYSConfig_6
    253                {
    254                  Status = SetCKSYS_OSC4MPLL(MRCC_PLL);
   \                     ??MRCC_CKSYSConfig_8:
   \   00000060   2000               MOVS     R0,R4
   \   00000062   ........           BL       SetCKSYS_OSC4MPLL
   \   00000066   0500               MOVS     R5,R0
   \   00000068   0BE0               B        ??MRCC_CKSYSConfig_6
    255                }
    256                break;
    257          
    258              case MRCC_CKSYS_RTC:
    259                if((MRCC_PLL == MRCC_PLL_Disabled) || (MRCC_PLL == MRCC_PLL_NoChange))
   \                     ??MRCC_CKSYSConfig_3:
   \   0000006A   ....               LDR      R0,??DataTable36  ;; 0xfeffffff
   \   0000006C   8442               CMP      R4,R0
   \   0000006E   01D0               BEQ      ??MRCC_CKSYSConfig_9
   \   00000070   012C               CMP      R4,#+1
   \   00000072   06D1               BNE      ??MRCC_CKSYSConfig_6
    260                {    
    261                  Status = SetCKSYS_RTC(MRCC_PLL);
   \                     ??MRCC_CKSYSConfig_9:
   \   00000074   2000               MOVS     R0,R4
   \   00000076   ........           BL       SetCKSYS_RTC
   \   0000007A   0500               MOVS     R5,R0
   \   0000007C   01E0               B        ??MRCC_CKSYSConfig_6
    262                }
    263                break;
    264          
    265              default:
    266                Status = ERROR;
   \                     ??MRCC_CKSYSConfig_4:
   \   0000007E   0020               MOVS     R0,#+0
   \   00000080   0500               MOVS     R5,R0
    267                break;
    268            }
    269            return Status;
   \                     ??MRCC_CKSYSConfig_6:
   \   00000082   2800               MOVS     R0,R5
   \   00000084   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000086   000E               LSRS     R0,R0,#+24
   \   00000088   70BC               POP      {R4-R6}
   \   0000008A   02BC               POP      {R1}
   \   0000008C   0847               BX       R1               ;; return
    270          }
    271          
    272          /*******************************************************************************
    273          * Function Name  : MRCC_HCLKConfig
    274          * Description    : Configures the AHB clock (HCLK).
    275          * Input          : - MRCC_HCLK: defines the AHB clock. This clock is derived
    276          *                    from the system clock(CK_SYS).
    277          *                    This parameter can be one of the following values:
    278          *                          - MRCC_CKSYS_Div1: AHB clock = CK_SYS
    279          *                          - MRCC_CKSYS_Div2: AHB clock = CK_SYS/2
    280          *                          - MRCC_CKSYS_Div4: AHB clock = CK_SYS/4
    281          *                          - MRCC_CKSYS_Div8: AHB clock = CK_SYS/8
    282          * Output         : None
    283          * Return         : None
    284          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    285          void MRCC_HCLKConfig(u32 MRCC_HCLK)
    286          {
    287            u32 Temp = 0;
   \                     MRCC_HCLKConfig:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   1100               MOVS     R1,R2
    288            
    289            /* Clear HPRESC[1:0] bits */
    290            Temp = MRCC->CLKCTL & MRCC_HPRESC_Reset_Mask;
   \   00000004   ....               LDR      R2,??DataTable58  ;; 0x60000020
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1823               MOVS     R3,#+24
   \   0000000A   9A43               BICS     R2,R2,R3
   \   0000000C   1100               MOVS     R1,R2
    291            
    292            /* Set HPRESC[1:0] bits according to MRCC_HCLK value */
    293            Temp |= MRCC_HCLK;
   \   0000000E   0143               ORRS     R1,R1,R0
    294            
    295            /* Store the new value */
    296            MRCC->CLKCTL = Temp;  
   \   00000010   ....               LDR      R2,??DataTable58  ;; 0x60000020
   \   00000012   1160               STR      R1,[R2, #+0]
    297          }
   \   00000014   7047               BX       LR               ;; return
    298          
    299          /*******************************************************************************
    300          * Function Name  : MRCC_CKTIMConfig
    301          * Description    : Configures the TIM clock (CK_TIM).
    302          * Input          : - MRCC_CKTIM: defines the TIM clock. This clock is derived
    303          *                    from the AHB clock(HCLK).
    304          *                    This parameter can be one of the following values:
    305          *                          - MRCC_HCLK_Div1: TIM clock = HCLK
    306          *                          - MRCC_HCLK_Div2: TIM clock = HCLK/2
    307          *                          - MRCC_HCLK_Div4: TIM clock = HCLK/4
    308          *                          - MRCC_HCLK_Div8: TIM clock = HCLK/8
    309          * Output         : None
    310          * Return         : None
    311          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    312          void MRCC_CKTIMConfig(u32 MRCC_CKTIM)
    313          {
    314            u32 Temp = 0;
   \                     MRCC_CKTIMConfig:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   1100               MOVS     R1,R2
    315            
    316            /* Clear PPRESC[1:0] bits */
    317            Temp = MRCC->CLKCTL & MRCC_PPRESC_Reset_Mask;
   \   00000004   ....               LDR      R2,??DataTable58  ;; 0x60000020
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   0323               MOVS     R3,#+3
   \   0000000A   9A43               BICS     R2,R2,R3
   \   0000000C   1100               MOVS     R1,R2
    318            
    319            /* Set PPRESC[1:0] bits according to MRCC_CKTIM value */
    320            Temp |= MRCC_CKTIM;
   \   0000000E   0143               ORRS     R1,R1,R0
    321            
    322            /* Store the new value */
    323            MRCC->CLKCTL = Temp;
   \   00000010   ....               LDR      R2,??DataTable58  ;; 0x60000020
   \   00000012   1160               STR      R1,[R2, #+0]
    324          }
   \   00000014   7047               BX       LR               ;; return
    325          
    326          /*******************************************************************************
    327          * Function Name  : MRCC_PCLKConfig
    328          * Description    : Configures the APB clock (PCLK).
    329          * Input          : - MRCC_PCLK: defines the APB clock. This clock is derived 
    330          *                    from the TIM clock(CK_TIM).
    331          *                    This parameter can be one of the following values:
    332          *                          - MRCC_CKTIM_Div1: APB clock = CKTIM
    333          *                          - MRCC_CKTIM_Div2: APB clock = CKTIM/2
    334          * Output         : None
    335          * Return         : None
    336          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    337          void MRCC_PCLKConfig(u32 MRCC_PCLK)
    338          {
   \                     MRCC_PCLKConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    339            if(MRCC_PCLK == MRCC_CKTIM_Div2)
   \   00000002   0428               CMP      R0,#+4
   \   00000004   06D1               BNE      ??MRCC_PCLKConfig_0
    340            {
    341              MRCC->CLKCTL |= MRCC_CKTIM_Div2;
   \   00000006   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0422               MOVS     R2,#+4
   \   0000000C   0A43               ORRS     R2,R2,R1
   \   0000000E   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   00000010   0A60               STR      R2,[R1, #+0]
   \   00000012   05E0               B        ??MRCC_PCLKConfig_1
    342            }
    343            else
    344            {
    345              MRCC->CLKCTL &= MRCC_CKTIM_Div1;
   \                     ??MRCC_PCLKConfig_0:
   \   00000014   ....               LDR      R1,??DataTable58  ;; 0x60000020
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   0422               MOVS     R2,#+4
   \   0000001A   9143               BICS     R1,R1,R2
   \   0000001C   ....               LDR      R2,??DataTable58  ;; 0x60000020
   \   0000001E   1160               STR      R1,[R2, #+0]
    346            }
    347          }
   \                     ??MRCC_PCLKConfig_1:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
    348          
    349          /*******************************************************************************
    350          * Function Name  : MRCC_CKRTCConfig
    351          * Description    : Configures the RTC clock (CK_RTC).
    352          * Input          : - MRCC_CKRTC: specifies the clock source to be used as RTC
    353          *                    clock.
    354          *                    This parameter can be one of the following values:
    355          *                          - MRCC_CKRTC_OSC4M_Div128
    356          *                          - MRCC_CKRTC_OSC32K (OSC32K must be previously enabled
    357          *                            using MRCC_OSC32KConfig() function)
    358          *                          - MRCC_CKRTC_LPOSC (LPOSC must be previously enabled
    359          *                            using MRCC_LPOSCConfig() function)
    360          * Output         : None
    361          * Return         : An ErrorStatus enumuration value:
    362          *                         - SUCCESS: Clock configuration succeeded
    363          *                         - ERROR: Clock configuration failed
    364          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    365          ErrorStatus MRCC_CKRTCConfig(u32 MRCC_CKRTC)
    366          {
   \                     MRCC_CKRTCConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    367            u32 Tmp = 0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0200               MOVS     R2,R0
    368          
    369            if(((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET) &&
    370               ((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET))
   \   00000008   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   8002               LSLS     R0,R0,#+10
   \   0000000E   05D5               BPL      ??MRCC_CKRTCConfig_0
   \   00000010   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   0002               LSLS     R0,R0,#+8
   \   00000016   01D5               BPL      ??MRCC_CKRTCConfig_0
    371            { 
    372              /* CK_RTC used as CK_SYS clock source */
    373              return ERROR;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   08E0               B        ??MRCC_CKRTCConfig_1
    374            }
    375            else
    376            {    
    377              /* Clear CKRTCSEL[1:0] bits */
    378              Tmp = MRCC->PWRCTRL & MRCC_CKRTCSEL_Reset_Mask;
   \                     ??MRCC_CKRTCConfig_0:
   \   0000001C   ....               LDR      R0,??DataTable49  ;; 0x60000028
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   ....               LDR      R3,??DataTable48  ;; 0xfcffffff
   \   00000022   0340               ANDS     R3,R3,R0
   \   00000024   1A00               MOVS     R2,R3
    379          
    380              /* Set CKRTCSEL[1:0] bits according to MRCC_CKRTC value */
    381              Tmp |= MRCC_CKRTC;
   \   00000026   0A43               ORRS     R2,R2,R1
    382          
    383              /* Store the new value */
    384              MRCC->PWRCTRL = Tmp;       
   \   00000028   ....               LDR      R0,??DataTable49  ;; 0x60000028
   \   0000002A   0260               STR      R2,[R0, #+0]
    385            }
    386          
    387            return SUCCESS;
   \   0000002C   0120               MOVS     R0,#+1
   \                     ??MRCC_CKRTCConfig_1:
   \   0000002E   08BC               POP      {R3}
   \   00000030   02BC               POP      {R1}
   \   00000032   0847               BX       R1               ;; return
    388          }
    389          
    390          /*******************************************************************************
    391          * Function Name  : MRCC_CKUSBConfig
    392          * Description    : Configures the USB clock(CK_USB).
    393          * Input          : - MRCC_CKUSB: specifies the clock source to be used as USB
    394          *                    clock.
    395          *                    This parameter can be one of the following values:
    396          *                          - MRCC_CKUSB_Internal(CK_PLL2 enabled)
    397          *                          - MRCC_CKUSB_External(CK_PLL2 disabled)
    398          * Output         : None
    399          * Return         : An ErrorStatus enumuration value:
    400          *                         - SUCCESS: Clock configuration succeeded
    401          *                         - ERROR: Clock configuration failed
    402          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    403          ErrorStatus MRCC_CKUSBConfig(u32 MRCC_CKUSB)
    404          {
   \                     MRCC_CKUSBConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    405            if(MRCC_CKUSB == MRCC_CKUSB_External)
   \   00000004   8020               MOVS     R0,#+128
   \   00000006   C003               LSLS     R0,R0,#+15       ;; #+4194304
   \   00000008   8142               CMP      R1,R0
   \   0000000A   0DD1               BNE      ??MRCC_CKUSBConfig_0
    406            {
    407              /* Disable CK_PLL2 */
    408              MRCC->CLKCTL &= MRCC_PLL2EN_Reset_Mask;
   \   0000000C   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   134A               LDR      R2,??MRCC_CKUSBConfig_1  ;; 0xfdffffff
   \   00000012   0240               ANDS     R2,R2,R0
   \   00000014   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000016   0260               STR      R2,[R0, #+0]
    409          
    410              /* External USB clock selected */
    411              MRCC->CLKCTL |= MRCC_CKUSB_External;
   \   00000018   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   8022               MOVS     R2,#+128
   \   0000001E   D203               LSLS     R2,R2,#+15       ;; #+4194304
   \   00000020   0243               ORRS     R2,R2,R0
   \   00000022   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000024   0260               STR      R2,[R0, #+0]
   \   00000026   16E0               B        ??MRCC_CKUSBConfig_2
    412            }
    413            else
    414            {
    415              if((MRCC->CLKCTL & MRCC_PLLEN_LOCK_Mask) != RESET)
   \                     ??MRCC_CKUSBConfig_0:
   \   00000028   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   8122               MOVS     R2,#+129
   \   0000002E   1206               LSLS     R2,R2,#+24       ;; #-2130706432
   \   00000030   0240               ANDS     R2,R2,R0
   \   00000032   002A               CMP      R2,#+0
   \   00000034   0DD0               BEQ      ??MRCC_CKUSBConfig_3
    416              { /* PLL enabled and locked */
    417                
    418                /* Enable CK_PLL2 */
    419                MRCC->CLKCTL |= MRCC_PLL2EN_Set_Mask;
   \   00000036   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   8022               MOVS     R2,#+128
   \   0000003C   9204               LSLS     R2,R2,#+18       ;; #+33554432
   \   0000003E   0243               ORRS     R2,R2,R0
   \   00000040   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000042   0260               STR      R2,[R0, #+0]
    420          
    421                /* Internal USB clock selected */
    422                MRCC->CLKCTL &= MRCC_CKUSB_Internal;
   \   00000044   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   064A               LDR      R2,??MRCC_CKUSBConfig_1+0x4  ;; 0xffbfffff
   \   0000004A   0240               ANDS     R2,R2,R0
   \   0000004C   ....               LDR      R0,??DataTable58  ;; 0x60000020
   \   0000004E   0260               STR      R2,[R0, #+0]
   \   00000050   01E0               B        ??MRCC_CKUSBConfig_2
    423              }
    424              else
    425              {
    426                /* PLL not enabled */
    427                return ERROR;
   \                     ??MRCC_CKUSBConfig_3:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   00E0               B        ??MRCC_CKUSBConfig_4
    428              }
    429            }
    430          
    431            return SUCCESS;  
   \                     ??MRCC_CKUSBConfig_2:
   \   00000056   0120               MOVS     R0,#+1
   \                     ??MRCC_CKUSBConfig_4:
   \   00000058   08BC               POP      {R3}
   \   0000005A   02BC               POP      {R1}
   \   0000005C   0847               BX       R1               ;; return
   \   0000005E   C046               Nop      
   \                     ??MRCC_CKUSBConfig_1:
   \   00000060   FFFFFFFD           DC32     0xfdffffff
   \   00000064   FFFFBFFF           DC32     0xffbfffff
    432          }
    433          
    434          /*******************************************************************************
    435          * Function Name  : MRCC_ITConfig
    436          * Description    : Enables or disables the specified MRCC interrupts.
    437          * Input          : - MRCC_IT: specifies the MRCC interrupts sources to be
    438          *                    enabled or disabled. This parameter can be any combination
    439          *                    of the following values:
    440          *                          - MRCC_IT_LOCK: PLL lock interrupt
    441          *                          - MRCC_IT_NCKD: No Clock detected interrupt
    442          *                  - NewState: new state of the MRCC interrupts.
    443          *                    This parameter can be: ENABLE or DISABLE.
    444          * Output         : None
    445          * Return         : None
    446          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    447          void MRCC_ITConfig(u32 MRCC_IT, FunctionalState NewState)
    448          {
   \                     MRCC_ITConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    449            if(NewState == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   05D1               BNE      ??MRCC_ITConfig_0
    450            {
    451              MRCC->CLKCTL |= MRCC_IT;
   \   0000000A   074A               LDR      R2,??MRCC_ITConfig_1  ;; 0x60000020
   \   0000000C   1268               LDR      R2,[R2, #+0]
   \   0000000E   0243               ORRS     R2,R2,R0
   \   00000010   054B               LDR      R3,??MRCC_ITConfig_1  ;; 0x60000020
   \   00000012   1A60               STR      R2,[R3, #+0]
   \   00000014   04E0               B        ??MRCC_ITConfig_2
    452            }
    453            else
    454            {
    455              MRCC->CLKCTL &= ~MRCC_IT;
   \                     ??MRCC_ITConfig_0:
   \   00000016   044A               LDR      R2,??MRCC_ITConfig_1  ;; 0x60000020
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   8243               BICS     R2,R2,R0
   \   0000001C   024B               LDR      R3,??MRCC_ITConfig_1  ;; 0x60000020
   \   0000001E   1A60               STR      R2,[R3, #+0]
    456            }
    457          }
   \                     ??MRCC_ITConfig_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??MRCC_ITConfig_1:
   \   00000028   20000060           DC32     0x60000020
    458          
    459          /*******************************************************************************
    460          * Function Name  : MRCC_PeripheralClockConfig
    461          * Description    : Enables or disables the specified peripheral clock.
    462          * Input          : - MRCC_Peripheral: specifies the peripheral to gates its
    463          *                    clock. More than one peripheral can be selected using
    464          *                    the “|” operator.
    465          *                  - NewState: new state of the specified peripheral clock.
    466          *                    This parameter can be one of the following values:
    467          *                          - ENABLE: the selected peripheral clock is enabled
    468          *                          - DISABLE: the selected peripheral clock is disabled
    469          * Output         : None
    470          * Return         : None
    471          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    472          void MRCC_PeripheralClockConfig(u32 MRCC_Peripheral, FunctionalState NewState)
    473          {
   \                     MRCC_PeripheralClockConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    474            if(NewState == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   05D1               BNE      ??MRCC_PeripheralClockConfig_0
    475            {
    476              MRCC->PCLKEN |= MRCC_Peripheral;
   \   0000000A   074A               LDR      R2,??MRCC_PeripheralClockConfig_1  ;; 0x60000030
   \   0000000C   1268               LDR      R2,[R2, #+0]
   \   0000000E   0243               ORRS     R2,R2,R0
   \   00000010   054B               LDR      R3,??MRCC_PeripheralClockConfig_1  ;; 0x60000030
   \   00000012   1A60               STR      R2,[R3, #+0]
   \   00000014   04E0               B        ??MRCC_PeripheralClockConfig_2
    477            }
    478            else
    479            {
    480              MRCC->PCLKEN &= ~MRCC_Peripheral;
   \                     ??MRCC_PeripheralClockConfig_0:
   \   00000016   044A               LDR      R2,??MRCC_PeripheralClockConfig_1  ;; 0x60000030
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   8243               BICS     R2,R2,R0
   \   0000001C   024B               LDR      R3,??MRCC_PeripheralClockConfig_1  ;; 0x60000030
   \   0000001E   1A60               STR      R2,[R3, #+0]
    481            }
    482          }
   \                     ??MRCC_PeripheralClockConfig_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??MRCC_PeripheralClockConfig_1:
   \   00000028   30000060           DC32     0x60000030
    483          
    484          /*******************************************************************************
    485          * Function Name  : MRCC_PeripheralSWResetConfig
    486          * Description    : Forces or releases peripheral software reset.
    487          * Input          : - MRCC_Peripheral: specifies the peripheral to reset. More
    488          *                    than one peripheral can be selected using the “|” operator.
    489          *                  - NewState: new state of the specified peripheral software
    490          *                    reset. This parameter can be one of the following values:
    491          *                          - ENABLE: the selected peripheral is kept under reset
    492          *                          - DISABLE: the selected peripheral exits from reset
    493          * Output         : None
    494          * Return         : None
    495          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    496          void MRCC_PeripheralSWResetConfig(u32 MRCC_Peripheral, FunctionalState NewState)
    497          {
   \                     MRCC_PeripheralSWResetConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    498            if(NewState == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   05D1               BNE      ??MRCC_PeripheralSWResetConfig_0
    499            {
    500              MRCC->PSWRES |= MRCC_Peripheral;
   \   0000000A   074A               LDR      R2,??MRCC_PeripheralSWResetConfig_1  ;; 0x60000034
   \   0000000C   1268               LDR      R2,[R2, #+0]
   \   0000000E   0243               ORRS     R2,R2,R0
   \   00000010   054B               LDR      R3,??MRCC_PeripheralSWResetConfig_1  ;; 0x60000034
   \   00000012   1A60               STR      R2,[R3, #+0]
   \   00000014   04E0               B        ??MRCC_PeripheralSWResetConfig_2
    501            }
    502            else
    503            {
    504              MRCC->PSWRES &= ~MRCC_Peripheral;
   \                     ??MRCC_PeripheralSWResetConfig_0:
   \   00000016   044A               LDR      R2,??MRCC_PeripheralSWResetConfig_1  ;; 0x60000034
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   8243               BICS     R2,R2,R0
   \   0000001C   024B               LDR      R3,??MRCC_PeripheralSWResetConfig_1  ;; 0x60000034
   \   0000001E   1A60               STR      R2,[R3, #+0]
    505            }
    506          }
   \                     ??MRCC_PeripheralSWResetConfig_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??MRCC_PeripheralSWResetConfig_1:
   \   00000028   34000060           DC32     0x60000034
    507          
    508          /*******************************************************************************
    509          * Function Name  : MRCC_GetClocksStatus
    510          * Description    : Returns the status and frequencies of different on chip clocks.
    511          *                  Don’t use this function when CK_SYS is clocked by an external
    512          *                  clock source (OSC4M bypassed).
    513          * Input          : - MRCC_ClocksStatus: pointer to a MRCC_ClocksTypeDef structure
    514          *                    which will hold the clocks information.
    515          * Output         : None
    516          * Return         : None
    517          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    518          void MRCC_GetClocksStatus(MRCC_ClocksTypeDef*  MRCC_ClocksStatus)
    519          {
   \                     MRCC_GetClocksStatus:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    520            u32 PLLMul = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   2100               MOVS     R1,R4
    521            u32 Temp = 0;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   2200               MOVS     R2,R4
    522            u32 Presc = 0;
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   2300               MOVS     R3,R4
    523          
    524            /* Get the Status of PLL */
    525            if((MRCC->CLKCTL & MRCC_PLLEN_Set_Mask) == RESET)  
   \   0000000E   624C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000010   2468               LDR      R4,[R4, #+0]
   \   00000012   E401               LSLS     R4,R4,#+7
   \   00000014   02D4               BMI      ??MRCC_GetClocksStatus_1
    526            {
    527              MRCC_ClocksStatus->PLL_Status = OFF;
   \   00000016   0B24               MOVS     R4,#+11
   \   00000018   C470               STRB     R4,[R0, #+3]
   \   0000001A   01E0               B        ??MRCC_GetClocksStatus_2
    528            }
    529            else
    530            {
    531              MRCC_ClocksStatus->PLL_Status = ON;
   \                     ??MRCC_GetClocksStatus_1:
   \   0000001C   0A24               MOVS     R4,#+10
   \   0000001E   C470               STRB     R4,[R0, #+3]
    532            }
    533            
    534            /* Get the Status of OSC4M */
    535            if((MRCC->CLKCTL & MRCC_OSC4MOFF_Set_Mask) == RESET)  
   \                     ??MRCC_GetClocksStatus_2:
   \   00000020   5D4C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000022   2468               LDR      R4,[R4, #+0]
   \   00000024   A403               LSLS     R4,R4,#+14
   \   00000026   02D4               BMI      ??MRCC_GetClocksStatus_3
    536            {
    537              MRCC_ClocksStatus->OSC4M_Status = ON;
   \   00000028   0A24               MOVS     R4,#+10
   \   0000002A   0471               STRB     R4,[R0, #+4]
   \   0000002C   01E0               B        ??MRCC_GetClocksStatus_4
    538            }
    539            else
    540            {
    541              MRCC_ClocksStatus->OSC4M_Status = OFF;
   \                     ??MRCC_GetClocksStatus_3:
   \   0000002E   0B24               MOVS     R4,#+11
   \   00000030   0471               STRB     R4,[R0, #+4]
    542            }  
    543            
    544            /* Get the Status of LPOSC */
    545            if((MRCC->PWRCTRL & MRCC_LPOSCEN_Mask) == RESET)  
   \                     ??MRCC_GetClocksStatus_4:
   \   00000032   5A4C               LDR      R4,??MRCC_GetClocksStatus_0+0x4  ;; 0x60000028
   \   00000034   2468               LDR      R4,[R4, #+0]
   \   00000036   E400               LSLS     R4,R4,#+3
   \   00000038   02D4               BMI      ??MRCC_GetClocksStatus_5
    546            {
    547              MRCC_ClocksStatus->LPOSC_Status = OFF;
   \   0000003A   0B24               MOVS     R4,#+11
   \   0000003C   4471               STRB     R4,[R0, #+5]
   \   0000003E   01E0               B        ??MRCC_GetClocksStatus_6
    548            }
    549            else
    550            {
    551              MRCC_ClocksStatus->LPOSC_Status = ON;
   \                     ??MRCC_GetClocksStatus_5:
   \   00000040   0A24               MOVS     R4,#+10
   \   00000042   4471               STRB     R4,[R0, #+5]
    552            }  
    553            
    554            /* Get the Status of OSC32K */
    555            if((MRCC->PWRCTRL & MRCC_OSC32KEN_Mask) == RESET)  
   \                     ??MRCC_GetClocksStatus_6:
   \   00000044   554C               LDR      R4,??MRCC_GetClocksStatus_0+0x4  ;; 0x60000028
   \   00000046   2468               LDR      R4,[R4, #+0]
   \   00000048   A400               LSLS     R4,R4,#+2
   \   0000004A   02D4               BMI      ??MRCC_GetClocksStatus_7
    556            {
    557              MRCC_ClocksStatus->OSC32K_Status = OFF;
   \   0000004C   0B24               MOVS     R4,#+11
   \   0000004E   8471               STRB     R4,[R0, #+6]
   \   00000050   01E0               B        ??MRCC_GetClocksStatus_8
    558            }
    559            else
    560            {
    561              MRCC_ClocksStatus->OSC32K_Status = ON;
   \                     ??MRCC_GetClocksStatus_7:
   \   00000052   0A24               MOVS     R4,#+10
   \   00000054   8471               STRB     R4,[R0, #+6]
    562            } 
    563              
    564          /* Get CKU_SB source ---------------------------------------------------------*/  
    565            if((MRCC->CLKCTL & MRCC_CKUSBSEL_Mask) != RESET)
   \                     ??MRCC_GetClocksStatus_8:
   \   00000056   504C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000058   2468               LDR      R4,[R4, #+0]
   \   0000005A   6402               LSLS     R4,R4,#+9
   \   0000005C   02D5               BPL      ??MRCC_GetClocksStatus_9
    566            {
    567              MRCC_ClocksStatus->CKUSB_Source = External;    
   \   0000005E   0924               MOVS     R4,#+9
   \   00000060   8470               STRB     R4,[R0, #+2]
   \   00000062   08E0               B        ??MRCC_GetClocksStatus_10
    568            }
    569            else
    570            {  
    571              if((MRCC->CLKCTL & MRCC_PLL2EN_Set_Mask) != RESET)
   \                     ??MRCC_GetClocksStatus_9:
   \   00000064   4C4C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000066   2468               LDR      R4,[R4, #+0]
   \   00000068   A401               LSLS     R4,R4,#+6
   \   0000006A   02D5               BPL      ??MRCC_GetClocksStatus_11
    572              {
    573                MRCC_ClocksStatus->CKUSB_Source = Internal;
   \   0000006C   0824               MOVS     R4,#+8
   \   0000006E   8470               STRB     R4,[R0, #+2]
   \   00000070   01E0               B        ??MRCC_GetClocksStatus_10
    574              
    575              }
    576              else 
    577              {
    578                MRCC_ClocksStatus->CKUSB_Source = Disabled;    
   \                     ??MRCC_GetClocksStatus_11:
   \   00000072   0424               MOVS     R4,#+4
   \   00000074   8470               STRB     R4,[R0, #+2]
    579              }
    580            }
    581          
    582          /* Get CK_RTC source ---------------------------------------------------------*/ 
    583            Temp = MRCC->PWRCTRL & MRCC_CKRTCSEL_Set_Mask;
   \                     ??MRCC_GetClocksStatus_10:
   \   00000076   494C               LDR      R4,??MRCC_GetClocksStatus_0+0x4  ;; 0x60000028
   \   00000078   2468               LDR      R4,[R4, #+0]
   \   0000007A   C025               MOVS     R5,#+192
   \   0000007C   AD04               LSLS     R5,R5,#+18       ;; #+50331648
   \   0000007E   2540               ANDS     R5,R5,R4
   \   00000080   2A00               MOVS     R2,R5
    584            Temp = Temp >> 24;
   \   00000082   120E               LSRS     R2,R2,#+24
    585              
    586            switch(Temp)
   \   00000084   1400               MOVS     R4,R2
   \   00000086   002C               CMP      R4,#+0
   \   00000088   06D0               BEQ      ??MRCC_GetClocksStatus_12
   \   0000008A   641E               SUBS     R4,R4,#+1
   \   0000008C   07D0               BEQ      ??MRCC_GetClocksStatus_13
   \   0000008E   641E               SUBS     R4,R4,#+1
   \   00000090   08D0               BEQ      ??MRCC_GetClocksStatus_14
   \   00000092   641E               SUBS     R4,R4,#+1
   \   00000094   09D0               BEQ      ??MRCC_GetClocksStatus_15
   \   00000096   0BE0               B        ??MRCC_GetClocksStatus_16
    587            {
    588              case 0x00:
    589                MRCC_ClocksStatus->CKRTC_Source = Disabled;
   \                     ??MRCC_GetClocksStatus_12:
   \   00000098   0424               MOVS     R4,#+4
   \   0000009A   4470               STRB     R4,[R0, #+1]
   \   0000009C   0AE0               B        ??MRCC_GetClocksStatus_17
    590                break;
    591          
    592              case 0x01:
    593                MRCC_ClocksStatus->CKRTC_Source = OSC4M_Div128;
   \                     ??MRCC_GetClocksStatus_13:
   \   0000009E   0524               MOVS     R4,#+5
   \   000000A0   4470               STRB     R4,[R0, #+1]
   \   000000A2   07E0               B        ??MRCC_GetClocksStatus_17
    594                break;
    595          
    596              case 0x02:
    597                MRCC_ClocksStatus->CKRTC_Source = OSC32K;
   \                     ??MRCC_GetClocksStatus_14:
   \   000000A4   0724               MOVS     R4,#+7
   \   000000A6   4470               STRB     R4,[R0, #+1]
   \   000000A8   04E0               B        ??MRCC_GetClocksStatus_17
    598                break;
    599                  
    600              case 0x03:
    601                MRCC_ClocksStatus->CKRTC_Source = LPOSC;              
   \                     ??MRCC_GetClocksStatus_15:
   \   000000AA   0624               MOVS     R4,#+6
   \   000000AC   4470               STRB     R4,[R0, #+1]
   \   000000AE   01E0               B        ??MRCC_GetClocksStatus_17
    602                break;
    603                  
    604              default:
    605                MRCC_ClocksStatus->CKRTC_Source = Disabled;
   \                     ??MRCC_GetClocksStatus_16:
   \   000000B0   0424               MOVS     R4,#+4
   \   000000B2   4470               STRB     R4,[R0, #+1]
    606                break;          
    607            }
    608                
    609          /* Get CK_SYS source ---------------------------------------------------------*/   
    610            if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET)
   \                     ??MRCC_GetClocksStatus_17:
   \   000000B4   384C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   000000B6   2468               LDR      R4,[R4, #+0]
   \   000000B8   2402               LSLS     R4,R4,#+8
   \   000000BA   24D5               BPL      ??MRCC_GetClocksStatus_18
    611            {/* CK_OSC used as CK_SYS clock source */
    612              
    613              if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \   000000BC   364C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   000000BE   2468               LDR      R4,[R4, #+0]
   \   000000C0   A402               LSLS     R4,R4,#+10
   \   000000C2   14D5               BPL      ??MRCC_GetClocksStatus_19
    614              { /* CK_RTC used as CK_OSC clock source */
    615                MRCC_ClocksStatus->CKSYS_Source = CKRTC;
   \   000000C4   0324               MOVS     R4,#+3
   \   000000C6   0470               STRB     R4,[R0, #+0]
    616                
    617                if(MRCC_ClocksStatus->CKRTC_Source == OSC32K)
   \   000000C8   4478               LDRB     R4,[R0, #+1]
   \   000000CA   072C               CMP      R4,#+7
   \   000000CC   03D1               BNE      ??MRCC_GetClocksStatus_20
    618                {
    619                  /* CK_SYS clock frequency */
    620                  MRCC_ClocksStatus->CKSYS_Frequency = OSC32K_Value;         
   \   000000CE   8024               MOVS     R4,#+128
   \   000000D0   2402               LSLS     R4,R4,#+8        ;; #+32768
   \   000000D2   8460               STR      R4,[R0, #+8]
   \   000000D4   43E0               B        ??MRCC_GetClocksStatus_21
    621                }         
    622                else if(MRCC_ClocksStatus->CKRTC_Source == LPOSC)
   \                     ??MRCC_GetClocksStatus_20:
   \   000000D6   4478               LDRB     R4,[R0, #+1]
   \   000000D8   062C               CMP      R4,#+6
   \   000000DA   02D1               BNE      ??MRCC_GetClocksStatus_22
    623          
    624                {
    625                  /* CK_SYS clock frequency */
    626                  MRCC_ClocksStatus->CKSYS_Frequency = LPOSC_Value;             
   \   000000DC   304C               LDR      R4,??MRCC_GetClocksStatus_0+0x8  ;; 0x3bd08
   \   000000DE   8460               STR      R4,[R0, #+8]
   \   000000E0   3DE0               B        ??MRCC_GetClocksStatus_21
    627                }
    628                else if(MRCC_ClocksStatus->CKRTC_Source == OSC4M_Div128)
   \                     ??MRCC_GetClocksStatus_22:
   \   000000E2   4478               LDRB     R4,[R0, #+1]
   \   000000E4   052C               CMP      R4,#+5
   \   000000E6   3AD1               BNE      ??MRCC_GetClocksStatus_21
    629          
    630                {
    631                  /* CK_SYS clock frequency */
    632                  MRCC_ClocksStatus->CKSYS_Frequency = OSC4M_Div128_Value;             
   \   000000E8   2E4C               LDR      R4,??MRCC_GetClocksStatus_0+0xC  ;; 0x7a12
   \   000000EA   8460               STR      R4,[R0, #+8]
   \   000000EC   37E0               B        ??MRCC_GetClocksStatus_21
    633                }
    634              }
    635              else
    636              { /* OSC4M used as CK_OSC clock source */
    637                MRCC_ClocksStatus->CKSYS_Source = OSC4M; 
   \                     ??MRCC_GetClocksStatus_19:
   \   000000EE   0224               MOVS     R4,#+2
   \   000000F0   0470               STRB     R4,[R0, #+0]
    638              
    639                if((MRCC->CLKCTL & MRCC_XTDIV2_Set_Mask) != RESET)
   \   000000F2   294C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   000000F4   2468               LDR      R4,[R4, #+0]
   \   000000F6   2404               LSLS     R4,R4,#+16
   \   000000F8   02D5               BPL      ??MRCC_GetClocksStatus_23
    640                {
    641                  /* CK_SYS clock frequency */
    642                  MRCC_ClocksStatus->CKSYS_Frequency = Main_Oscillator >> 1;
   \   000000FA   2B4C               LDR      R4,??MRCC_GetClocksStatus_0+0x10  ;; 0x3d0900
   \   000000FC   8460               STR      R4,[R0, #+8]
   \   000000FE   2EE0               B        ??MRCC_GetClocksStatus_21
    643                }
    644                else
    645                {
    646                  /* CK_SYS clock frequency */
    647                  MRCC_ClocksStatus->CKSYS_Frequency = Main_Oscillator;
   \                     ??MRCC_GetClocksStatus_23:
   \   00000100   2A4C               LDR      R4,??MRCC_GetClocksStatus_0+0x14  ;; 0x7a1200
   \   00000102   8460               STR      R4,[R0, #+8]
   \   00000104   2BE0               B        ??MRCC_GetClocksStatus_21
    648                }          
    649              }
    650            }     
    651            else
    652            {/* CK_PLL1 used as CK_SYS clock */
    653              
    654              if(MRCC_ClocksStatus->PLL_Status == OFF)
   \                     ??MRCC_GetClocksStatus_18:
   \   00000106   C478               LDRB     R4,[R0, #+3]
   \   00000108   0B2C               CMP      R4,#+11
   \   0000010A   04D1               BNE      ??MRCC_GetClocksStatus_24
    655              { /* FREEOSC used as CK_PLL1 clock source */
    656                MRCC_ClocksStatus->CKSYS_Source = FREEOSC; 
   \   0000010C   0024               MOVS     R4,#+0
   \   0000010E   0470               STRB     R4,[R0, #+0]
    657                
    658                /* CK_SYS clock frequency */
    659                MRCC_ClocksStatus->CKSYS_Frequency = FREEOSC_Value;               
   \   00000110   274C               LDR      R4,??MRCC_GetClocksStatus_0+0x18  ;; 0x4c4b40
   \   00000112   8460               STR      R4,[R0, #+8]
   \   00000114   23E0               B        ??MRCC_GetClocksStatus_21
    660              }
    661              else
    662              { /* OSC4M followed by PLL used as CK_PLL1 clock source */
    663                MRCC_ClocksStatus->CKSYS_Source = OSC4MPLL;
   \                     ??MRCC_GetClocksStatus_24:
   \   00000116   0124               MOVS     R4,#+1
   \   00000118   0470               STRB     R4,[R0, #+0]
    664                              
    665                /* Get PLL factor ------------------------------------------------------*/
    666                Temp = MRCC->CLKCTL & MRCC_MX_Set_Mask;
   \   0000011A   1F4C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   0000011C   2468               LDR      R4,[R4, #+0]
   \   0000011E   C025               MOVS     R5,#+192
   \   00000120   6D05               LSLS     R5,R5,#+21       ;; #+402653184
   \   00000122   2540               ANDS     R5,R5,R4
   \   00000124   2A00               MOVS     R2,R5
    667                Temp = Temp >> 27;
   \   00000126   D20E               LSRS     R2,R2,#+27
    668              
    669                switch(Temp)
   \   00000128   1400               MOVS     R4,R2
   \   0000012A   002C               CMP      R4,#+0
   \   0000012C   06D0               BEQ      ??MRCC_GetClocksStatus_25
   \   0000012E   641E               SUBS     R4,R4,#+1
   \   00000130   07D0               BEQ      ??MRCC_GetClocksStatus_26
   \   00000132   641E               SUBS     R4,R4,#+1
   \   00000134   08D0               BEQ      ??MRCC_GetClocksStatus_27
   \   00000136   641E               SUBS     R4,R4,#+1
   \   00000138   09D0               BEQ      ??MRCC_GetClocksStatus_28
   \   0000013A   0BE0               B        ??MRCC_GetClocksStatus_29
    670                {
    671                  case 0x00:
    672                    PLLMul = 16;
   \                     ??MRCC_GetClocksStatus_25:
   \   0000013C   1024               MOVS     R4,#+16
   \   0000013E   2100               MOVS     R1,R4
   \   00000140   0AE0               B        ??MRCC_GetClocksStatus_30
    673                    break;
    674          
    675                  case 0x01:
    676                    PLLMul = 15;
   \                     ??MRCC_GetClocksStatus_26:
   \   00000142   0F24               MOVS     R4,#+15
   \   00000144   2100               MOVS     R1,R4
   \   00000146   07E0               B        ??MRCC_GetClocksStatus_30
    677                    break;
    678          
    679                  case 0x02:
    680                    PLLMul = 14;
   \                     ??MRCC_GetClocksStatus_27:
   \   00000148   0E24               MOVS     R4,#+14
   \   0000014A   2100               MOVS     R1,R4
   \   0000014C   04E0               B        ??MRCC_GetClocksStatus_30
    681                    break;
    682                  
    683                  case 0x03:
    684                    PLLMul = 12;
   \                     ??MRCC_GetClocksStatus_28:
   \   0000014E   0C24               MOVS     R4,#+12
   \   00000150   2100               MOVS     R1,R4
   \   00000152   01E0               B        ??MRCC_GetClocksStatus_30
    685                    break;
    686                  
    687                  default:
    688                    PLLMul = 16;
   \                     ??MRCC_GetClocksStatus_29:
   \   00000154   1024               MOVS     R4,#+16
   \   00000156   2100               MOVS     R1,R4
    689                    break;          
    690                } 
    691                
    692                /* CK_SYS clock frequency */
    693                MRCC_ClocksStatus->CKSYS_Frequency = OSC4M_Value * PLLMul;     
   \                     ??MRCC_GetClocksStatus_30:
   \   00000158   134C               LDR      R4,??MRCC_GetClocksStatus_0+0x10  ;; 0x3d0900
   \   0000015A   4C43               MULS     R4,R1,R4
   \   0000015C   8460               STR      R4,[R0, #+8]
    694              }
    695            }
    696          
    697          /* Compute HCLK, CKTIM and PCLK clocks frequencies ---------------------------*/    
    698            /* Get HCLK prescaler */
    699            Presc = MRCC->CLKCTL & MRCC_HPRESC_Set_Mask;
   \                     ??MRCC_GetClocksStatus_21:
   \   0000015E   0E4C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000160   2468               LDR      R4,[R4, #+0]
   \   00000162   1825               MOVS     R5,#+24
   \   00000164   2540               ANDS     R5,R5,R4
   \   00000166   2B00               MOVS     R3,R5
    700            Presc = Presc >> 3;
   \   00000168   DB08               LSRS     R3,R3,#+3
    701            /* HCLK clock frequency */
    702            MRCC_ClocksStatus->HCLK_Frequency = MRCC_ClocksStatus->CKSYS_Frequency >> Presc;
   \   0000016A   8468               LDR      R4,[R0, #+8]
   \   0000016C   DC40               LSRS     R4,R4,R3
   \   0000016E   C460               STR      R4,[R0, #+12]
    703          
    704            /* Get CK_TIM prescaler */
    705            Presc = MRCC->CLKCTL & MRCC_PPRESC_Set_Mask;
   \   00000170   094C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000172   2468               LDR      R4,[R4, #+0]
   \   00000174   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   00000176   A40F               LSRS     R4,R4,#+30
   \   00000178   2300               MOVS     R3,R4
    706            /* CK_TIM clock frequency */
    707            MRCC_ClocksStatus->CKTIM_Frequency = MRCC_ClocksStatus->HCLK_Frequency >> Presc;
   \   0000017A   C468               LDR      R4,[R0, #+12]
   \   0000017C   DC40               LSRS     R4,R4,R3
   \   0000017E   0461               STR      R4,[R0, #+16]
    708           
    709            /* Get PCLK prescaler */
    710            Presc = MRCC->CLKCTL & MRCC_PPRESC2_Mask;
   \   00000180   054C               LDR      R4,??MRCC_GetClocksStatus_0  ;; 0x60000020
   \   00000182   2468               LDR      R4,[R4, #+0]
   \   00000184   0425               MOVS     R5,#+4
   \   00000186   2540               ANDS     R5,R5,R4
   \   00000188   2B00               MOVS     R3,R5
    711            Presc = Presc >> 2;
   \   0000018A   9B08               LSRS     R3,R3,#+2
    712            /* PCLK clock frequency */
    713            MRCC_ClocksStatus->PCLK_Frequency = MRCC_ClocksStatus->CKTIM_Frequency >> Presc;
   \   0000018C   0469               LDR      R4,[R0, #+16]
   \   0000018E   DC40               LSRS     R4,R4,R3
   \   00000190   4461               STR      R4,[R0, #+20]
    714          }
   \   00000192   38BC               POP      {R3-R5}
   \   00000194   01BC               POP      {R0}
   \   00000196   0047               BX       R0               ;; return
   \                     ??MRCC_GetClocksStatus_0:
   \   00000198   20000060           DC32     0x60000020
   \   0000019C   28000060           DC32     0x60000028
   \   000001A0   08BD0300           DC32     0x3bd08
   \   000001A4   127A0000           DC32     0x7a12
   \   000001A8   00093D00           DC32     0x3d0900
   \   000001AC   00127A00           DC32     0x7a1200
   \   000001B0   404B4C00           DC32     0x4c4b40
    715          
    716          /*******************************************************************************
    717          * Function Name  : MRCC_LPMC_DBGonfig
    718          * Description    : Enables or disables the Low Power Debug Mode.
    719          * Input          : - MRCC_LPDM: specifies the LPDM new state value.
    720          *                    This parameter can be one of the following values:
    721          *                          - MRCC_LPDM_Disable
    722          *                          - MRCC_LPDM_Enable
    723          * Output         : None
    724          * Return         : None
    725          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    726          void MRCC_LPMC_DBGConfig(u32 MRCC_LPDM)
    727          {
   \                     MRCC_LPMC_DBGConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    728            if(MRCC_LPDM == MRCC_LPDM_Enable)
   \   00000002   0828               CMP      R0,#+8
   \   00000004   06D1               BNE      ??MRCC_LPMC_DBGConfig_0
    729            {
    730              MRCC->PWRCTRL |= MRCC_LPDM_Enable;
   \   00000006   0849               LDR      R1,??MRCC_LPMC_DBGConfig_1  ;; 0x60000028
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0822               MOVS     R2,#+8
   \   0000000C   0A43               ORRS     R2,R2,R1
   \   0000000E   0649               LDR      R1,??MRCC_LPMC_DBGConfig_1  ;; 0x60000028
   \   00000010   0A60               STR      R2,[R1, #+0]
   \   00000012   05E0               B        ??MRCC_LPMC_DBGConfig_2
    731            }
    732            else
    733            {
    734              MRCC->PWRCTRL &= MRCC_LPDM_Disable;
   \                     ??MRCC_LPMC_DBGConfig_0:
   \   00000014   0449               LDR      R1,??MRCC_LPMC_DBGConfig_1  ;; 0x60000028
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   0822               MOVS     R2,#+8
   \   0000001A   9143               BICS     R1,R1,R2
   \   0000001C   024A               LDR      R2,??MRCC_LPMC_DBGConfig_1  ;; 0x60000028
   \   0000001E   1160               STR      R1,[R2, #+0]
    735            }
    736          }
   \                     ??MRCC_LPMC_DBGConfig_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??MRCC_LPMC_DBGConfig_1:
   \   00000028   28000060           DC32     0x60000028
    737          
    738          /*******************************************************************************
    739          * Function Name  : MRCC_EnterWFIMode
    740          * Description    : Enters WFI mode.
    741          *                  If the Flash is used in Burst mode, it must be kept enabled
    742          *                  in WFI mode(use MRCC_WFIParam_FLASHOn as parameter)
    743          * Input          : - MRCC_WFIParam: specifies the WFI mode control parameters.
    744          *                    This parameter can be one of the following values:
    745          *                          - MRCC_WFIParam_FLASHPowerDown(DMA not allowed during WFI)
    746          *                          - MRCC_WFIParam_FLASHOn(DMA allowed during WFI)
    747          *                          - MRCC_WFIParam_FLASHOff(DMA not allowed during WFI)
    748          * Output         : None
    749          * Return         : None
    750          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    751          void MRCC_EnterWFIMode(u32 MRCC_WFIParam)
    752          {
   \                     MRCC_EnterWFIMode:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    753          /* Low Power mode configuration ----------------------------------------------*/
    754            /* Clear LPMC[1:0] bits */
    755             MRCC->PWRCTRL &= MRCC_LPMC_Reset_Mask;
   \   00000004   0E48               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0621               MOVS     R1,#+6
   \   0000000A   8843               BICS     R0,R0,R1
   \   0000000C   0C49               LDR      R1,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   0000000E   0860               STR      R0,[R1, #+0]
    756          
    757            /* Select WFI mode */
    758            MRCC->PWRCTRL |= MRCC_WFI_Mask;
   \   00000010   0B48               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   0421               MOVS     R1,#+4
   \   00000016   0143               ORRS     R1,R1,R0
   \   00000018   0948               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   0000001A   0160               STR      R1,[R0, #+0]
    759          
    760          /* Low Power mode control parameters configuration ---------------------------*/
    761            /* Clear LP_PARAM[15:13] and WFI_FLASH_EN bits */
    762            MRCC->PWRCTRL &= MRCC_WFIParam_Reset_Mask;
   \   0000001C   0848               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   0849               LDR      R1,??MRCC_EnterWFIMode_0+0x4  ;; 0xffff1fef
   \   00000022   0140               ANDS     R1,R1,R0
   \   00000024   0648               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   00000026   0160               STR      R1,[R0, #+0]
    763            
    764            if(MRCC_WFIParam != MRCC_WFIParam_FLASHPowerDown)
   \   00000028   002C               CMP      R4,#+0
   \   0000002A   04D0               BEQ      ??MRCC_EnterWFIMode_1
    765            {
    766              /* Set LP_PARAM[15:13] and WFI_FLASH_EN bits according to MRCC_WFIParam value */
    767              MRCC->PWRCTRL |= MRCC_WFIParam;
   \   0000002C   0448               LDR      R0,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   2043               ORRS     R0,R0,R4
   \   00000032   0349               LDR      R1,??MRCC_EnterWFIMode_0  ;; 0x60000028
   \   00000034   0860               STR      R0,[R1, #+0]
    768            }
    769              
    770          /* Execute the Low Power bit writing sequence --------------------------------*/
    771            WriteLPBit();
   \                     ??MRCC_EnterWFIMode_1:
   \   00000036   ........           BL       WriteLPBit
    772          }
   \   0000003A   10BC               POP      {R4}
   \   0000003C   01BC               POP      {R0}
   \   0000003E   0047               BX       R0               ;; return
   \                     ??MRCC_EnterWFIMode_0:
   \   00000040   28000060           DC32     0x60000028
   \   00000044   EF1FFFFF           DC32     0xffff1fef
    773          
    774          /*******************************************************************************
    775          * Function Name  : MRCC_EnterSTOPMode
    776          * Description    : Enters STOP mode.
    777          * Input          : - MRCC_STOPParam: specifies the STOP mode control parameters.
    778          *                    This parameter can be one of the following values:
    779          *                          - MRCC_STOPParam_Default (OSC4M On, FLASH On, MVREG On)
    780          *                          - MRCC_STOPParam_OSC4MOff
    781          *                          - MRCC_STOPParam_FLASHOff
    782          *                          - MRCC_STOPParam_MVREGOff
    783          * Output         : None
    784          * Return         : None
    785          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    786          void MRCC_EnterSTOPMode(u32 MRCC_STOPParam)
    787          {
   \                     MRCC_EnterSTOPMode:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    788          /* Low Power mode configuration ----------------------------------------------*/
    789            /* Clear LPMC[1:0] bits (STOP mode is selected) */
    790             MRCC->PWRCTRL &= MRCC_LPMC_Reset_Mask;
   \   00000004   0B48               LDR      R0,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0621               MOVS     R1,#+6
   \   0000000A   8843               BICS     R0,R0,R1
   \   0000000C   0949               LDR      R1,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   0000000E   0860               STR      R0,[R1, #+0]
    791          
    792          /* Low Power mode control parameters configuration ---------------------------*/
    793            /* Clear LP_PARAM[15:13] bits */
    794            MRCC->PWRCTRL &= MRCC_LPPARAM_Reset_Mask;
   \   00000010   0848               LDR      R0,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   0849               LDR      R1,??MRCC_EnterSTOPMode_0+0x4  ;; 0xffff1fff
   \   00000016   0140               ANDS     R1,R1,R0
   \   00000018   0648               LDR      R0,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   0000001A   0160               STR      R1,[R0, #+0]
    795            
    796            if(MRCC_STOPParam != MRCC_STOPParam_Default)
   \   0000001C   002C               CMP      R4,#+0
   \   0000001E   04D0               BEQ      ??MRCC_EnterSTOPMode_1
    797            {
    798              /* Set LP_PARAM[15:13] bits according to MRCC_STOPParam value */
    799              MRCC->PWRCTRL |= MRCC_STOPParam;
   \   00000020   0448               LDR      R0,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   2043               ORRS     R0,R0,R4
   \   00000026   0349               LDR      R1,??MRCC_EnterSTOPMode_0  ;; 0x60000028
   \   00000028   0860               STR      R0,[R1, #+0]
    800            }
    801          
    802          /* Execute the Low Power bit writing sequence --------------------------------*/
    803            WriteLPBit();
   \                     ??MRCC_EnterSTOPMode_1:
   \   0000002A   ........           BL       WriteLPBit
    804          }
   \   0000002E   10BC               POP      {R4}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
   \                     ??MRCC_EnterSTOPMode_0:
   \   00000034   28000060           DC32     0x60000028
   \   00000038   FF1FFFFF           DC32     0xffff1fff
    805          
    806          /*******************************************************************************
    807          * Function Name  : MRCC_EnterSTANDBYMode
    808          * Description    : Enters STANDBY mode.
    809          *                  Make sure that WKPF flag is cleared before using this function.
    810          * Input          : None
    811          * Output         : None
    812          * Return         : None
    813          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    814          void MRCC_EnterSTANDBYMode(void)
    815          {
   \                     MRCC_EnterSTANDBYMode:
   \   00000000   01B5               PUSH     {R0,LR}
    816          /* Low Power mode configuration ----------------------------------------------*/
    817            /* Clear LPMC[1:0] bits */
    818             MRCC->PWRCTRL &= MRCC_LPMC_Reset_Mask;
   \   00000002   0848               LDR      R0,??MRCC_EnterSTANDBYMode_0  ;; 0x60000028
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0621               MOVS     R1,#+6
   \   00000008   8843               BICS     R0,R0,R1
   \   0000000A   0649               LDR      R1,??MRCC_EnterSTANDBYMode_0  ;; 0x60000028
   \   0000000C   0860               STR      R0,[R1, #+0]
    819          
    820            /* Select STANDBY mode */
    821            MRCC->PWRCTRL |= MRCC_STANDBY_Mask;
   \   0000000E   0548               LDR      R0,??MRCC_EnterSTANDBYMode_0  ;; 0x60000028
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0621               MOVS     R1,#+6
   \   00000014   0143               ORRS     R1,R1,R0
   \   00000016   0348               LDR      R0,??MRCC_EnterSTANDBYMode_0  ;; 0x60000028
   \   00000018   0160               STR      R1,[R0, #+0]
    822          
    823          /* Execute the Low Power bit writing sequence --------------------------------*/
    824            WriteLPBit();
   \   0000001A   ........           BL       WriteLPBit
    825          }
   \   0000001E   08BC               POP      {R3}
   \   00000020   01BC               POP      {R0}
   \   00000022   0047               BX       R0               ;; return
   \                     ??MRCC_EnterSTANDBYMode_0:
   \   00000024   28000060           DC32     0x60000028
    826          
    827          /*******************************************************************************
    828          * Function Name  : MRCC_GenerateSWReset
    829          * Description    : Generates a system software reset.
    830          * Input          : None
    831          * Output         : None
    832          * Return         : None
    833          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    834          void MRCC_GenerateSWReset(void)
    835          {
   \                     MRCC_GenerateSWReset:
   \   00000000   01B5               PUSH     {R0,LR}
    836          /* Low Power mode configuration ----------------------------------------------*/
    837            /* Clear LPMC[1:0] bits */
    838            MRCC->PWRCTRL &= MRCC_LPMC_Reset_Mask;
   \   00000002   0848               LDR      R0,??MRCC_GenerateSWReset_0  ;; 0x60000028
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0621               MOVS     R1,#+6
   \   00000008   8843               BICS     R0,R0,R1
   \   0000000A   0649               LDR      R1,??MRCC_GenerateSWReset_0  ;; 0x60000028
   \   0000000C   0860               STR      R0,[R1, #+0]
    839          
    840            /* Select software reset */
    841            MRCC->PWRCTRL |= MRCC_SWRESET_Mask;
   \   0000000E   0548               LDR      R0,??MRCC_GenerateSWReset_0  ;; 0x60000028
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0221               MOVS     R1,#+2
   \   00000014   0143               ORRS     R1,R1,R0
   \   00000016   0348               LDR      R0,??MRCC_GenerateSWReset_0  ;; 0x60000028
   \   00000018   0160               STR      R1,[R0, #+0]
    842          
    843          /* Execute the Low Power bit writing sequence --------------------------------*/
    844            WriteLPBit();
   \   0000001A   ........           BL       WriteLPBit
    845          }
   \   0000001E   08BC               POP      {R3}
   \   00000020   01BC               POP      {R0}
   \   00000022   0047               BX       R0               ;; return
   \                     ??MRCC_GenerateSWReset_0:
   \   00000024   28000060           DC32     0x60000028
    846          
    847          /*******************************************************************************
    848          * Function Name  : MRCC_WriteBackupRegister
    849          * Description    : Writes user data to the specified backup register.
    850          * Input          : - MRCC_BKP: specifies the backup register.
    851          *                    This parameter can be one of the following values:
    852          *                          - MRCC_BKP0
    853          *                          - MRCC_BKP1
    854          *                  - Data: data to write.
    855          * Output         : None
    856          * Return         : None
    857          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    858          void MRCC_WriteBackupRegister(MRCC_BKPReg MRCC_BKP, u32 Data)
    859          {
   \                     MRCC_WriteBackupRegister:
   \   00000000   01B5               PUSH     {R0,LR}
    860            if(MRCC_BKP == MRCC_BKP0)
   \   00000002   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000004   000E               LSRS     R0,R0,#+24
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D1               BNE      ??MRCC_WriteBackupRegister_0
    861            {
    862              MRCC->BKP0 = Data;
   \   0000000A   044A               LDR      R2,??MRCC_WriteBackupRegister_1  ;; 0x60000040
   \   0000000C   1160               STR      R1,[R2, #+0]
   \   0000000E   01E0               B        ??MRCC_WriteBackupRegister_2
    863            }
    864            else
    865            {
    866              MRCC->BKP1 = Data;
   \                     ??MRCC_WriteBackupRegister_0:
   \   00000010   034A               LDR      R2,??MRCC_WriteBackupRegister_1+0x4  ;; 0x60000044
   \   00000012   1160               STR      R1,[R2, #+0]
    867            }
    868          }
   \                     ??MRCC_WriteBackupRegister_2:
   \   00000014   08BC               POP      {R3}
   \   00000016   01BC               POP      {R0}
   \   00000018   0047               BX       R0               ;; return
   \   0000001A   C046               Nop      
   \                     ??MRCC_WriteBackupRegister_1:
   \   0000001C   40000060           DC32     0x60000040
   \   00000020   44000060           DC32     0x60000044
    869          
    870          /*******************************************************************************
    871          * Function Name  : MRCC_ReadBackupRegister
    872          * Description    : Reads data from the specified backup register.
    873          * Input          : - MRCC_BKP: specifies the backup register.
    874          *                    This parameter can be one of the following values:
    875          *                          - MRCC_BKP0
    876          *                          - MRCC_BKP1
    877          * Output         : None
    878          * Return         : The content of the specified backup register.
    879          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    880          u32 MRCC_ReadBackupRegister(MRCC_BKPReg MRCC_BKP)
    881          {
   \                     MRCC_ReadBackupRegister:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    882            if(MRCC_BKP == MRCC_BKP0)
   \   00000004   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000006   090E               LSRS     R1,R1,#+24
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   02D1               BNE      ??MRCC_ReadBackupRegister_0
    883            {
    884              return(MRCC->BKP0);
   \   0000000C   0348               LDR      R0,??MRCC_ReadBackupRegister_1  ;; 0x60000040
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   01E0               B        ??MRCC_ReadBackupRegister_2
    885            }
    886            else
    887            {
    888              return(MRCC->BKP1);
   \                     ??MRCC_ReadBackupRegister_0:
   \   00000012   0348               LDR      R0,??MRCC_ReadBackupRegister_1+0x4  ;; 0x60000044
   \   00000014   0068               LDR      R0,[R0, #+0]
   \                     ??MRCC_ReadBackupRegister_2:
   \   00000016   08BC               POP      {R3}
   \   00000018   02BC               POP      {R1}
   \   0000001A   0847               BX       R1               ;; return
   \                     ??MRCC_ReadBackupRegister_1:
   \   0000001C   40000060           DC32     0x60000040
   \   00000020   44000060           DC32     0x60000044
    889            }
    890          }
    891          
    892          /*******************************************************************************
    893          * Function Name  : MRCC_IOVoltageRangeConfig
    894          * Description    : Configures the I/O pins voltage range.
    895          * Input          : - MRCC_IOVoltageRange: specifies the I/O pins voltage range.
    896          *                    This parameter can be one of the following values:
    897          *                          - MRCC_IOVoltageRange_5V
    898          *                          - MRCC_IOVoltageRange_3V3
    899          * Output         : None
    900          * Return         : None
    901          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    902          void MRCC_IOVoltageRangeConfig(u32 MRCC_IOVoltageRange)
    903          {
   \                     MRCC_IOVoltageRangeConfig:
   \   00000000   01B5               PUSH     {R0,LR}
    904            if(MRCC_IOVoltageRange == MRCC_IOVoltageRange_3V3)
   \   00000002   8021               MOVS     R1,#+128
   \   00000004   4902               LSLS     R1,R1,#+9        ;; #+65536
   \   00000006   8842               CMP      R0,R1
   \   00000008   07D1               BNE      ??MRCC_IOVoltageRangeConfig_0
    905            {
    906              MRCC->PWRCTRL |= MRCC_IOVoltageRange_3V3;
   \   0000000A   0849               LDR      R1,??MRCC_IOVoltageRangeConfig_1  ;; 0x60000028
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   8022               MOVS     R2,#+128
   \   00000010   5202               LSLS     R2,R2,#+9        ;; #+65536
   \   00000012   0A43               ORRS     R2,R2,R1
   \   00000014   0549               LDR      R1,??MRCC_IOVoltageRangeConfig_1  ;; 0x60000028
   \   00000016   0A60               STR      R2,[R1, #+0]
   \   00000018   05E0               B        ??MRCC_IOVoltageRangeConfig_2
    907            }
    908            else
    909            {
    910              MRCC->PWRCTRL &= MRCC_IOVoltageRange_5V;
   \                     ??MRCC_IOVoltageRangeConfig_0:
   \   0000001A   0449               LDR      R1,??MRCC_IOVoltageRangeConfig_1  ;; 0x60000028
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   044A               LDR      R2,??MRCC_IOVoltageRangeConfig_1+0x4  ;; 0xfffeffff
   \   00000020   0A40               ANDS     R2,R2,R1
   \   00000022   0249               LDR      R1,??MRCC_IOVoltageRangeConfig_1  ;; 0x60000028
   \   00000024   0A60               STR      R2,[R1, #+0]
    911            }
    912          }
   \                     ??MRCC_IOVoltageRangeConfig_2:
   \   00000026   08BC               POP      {R3}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??MRCC_IOVoltageRangeConfig_1:
   \   0000002C   28000060           DC32     0x60000028
   \   00000030   FFFFFEFF           DC32     0xfffeffff
    913          
    914          /*******************************************************************************
    915          * Function Name  : MRCC_MCOConfig
    916          * Description    : Selects the clock source to output on MCO pin (P0.1).
    917          *                  To output the clock, the associated alternate function must
    918          *                  be enabled in the I/O port controller.
    919          * Input          : - MRCC_MCO: specifies the clock source to output.
    920          *                    This parameter can be one of the following values:
    921          *                          - MRCC_MCO_HCLK
    922          *                          - MRCC_MCO_PCLK
    923          *                          - MRCC_MCO_OSC4M
    924          *                          - MRCC_MCO_CKPLL2
    925          *                  - MRCC_MCOPrescaler: specifies if prescaler, divide by 1 or 2,
    926          *                    is applied to this clock before outputting it to MCO pin.
    927          *                    This parameter can be one of the following values:
    928          *                          - MRCC_MCOPrescaler_1
    929          *                          - MRCC_MCOPrescaler_2
    930          * Output         : None
    931          * Return         : None
    932          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    933          void MRCC_MCOConfig(u32 MRCC_MCO, u32 MCO_MCOPrescaler)
    934          {
   \                     MRCC_MCOConfig:
   \   00000000   10B5               PUSH     {R4,LR}
    935            u32 Temp = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   1A00               MOVS     R2,R3
    936          /* MCO prescaler configuration -----------------------------------------------*/
    937            if(MCO_MCOPrescaler == MRCC_MCOPrescaler_2)
   \   00000006   2029               CMP      R1,#+32
   \   00000008   06D1               BNE      ??MRCC_MCOConfig_0
    938            {
    939              MRCC->CLKCTL |= MRCC_MCOPrescaler_2;
   \   0000000A   0C4B               LDR      R3,??MRCC_MCOConfig_1  ;; 0x60000020
   \   0000000C   1B68               LDR      R3,[R3, #+0]
   \   0000000E   2024               MOVS     R4,#+32
   \   00000010   1C43               ORRS     R4,R4,R3
   \   00000012   0A4B               LDR      R3,??MRCC_MCOConfig_1  ;; 0x60000020
   \   00000014   1C60               STR      R4,[R3, #+0]
   \   00000016   05E0               B        ??MRCC_MCOConfig_2
    940            }
    941            else
    942            {
    943              MRCC->CLKCTL &= MRCC_MCOPrescaler_1;
   \                     ??MRCC_MCOConfig_0:
   \   00000018   084B               LDR      R3,??MRCC_MCOConfig_1  ;; 0x60000020
   \   0000001A   1B68               LDR      R3,[R3, #+0]
   \   0000001C   2024               MOVS     R4,#+32
   \   0000001E   A343               BICS     R3,R3,R4
   \   00000020   064C               LDR      R4,??MRCC_MCOConfig_1  ;; 0x60000020
   \   00000022   2360               STR      R3,[R4, #+0]
    944            }
    945          
    946          /* MCO selection configuration -----------------------------------------------*/
    947          
    948            /* Clear MCOS[1:0] bits */
    949            Temp = MRCC->CLKCTL & MRCC_MCOS_Reset_Mask;
   \                     ??MRCC_MCOConfig_2:
   \   00000024   054B               LDR      R3,??MRCC_MCOConfig_1  ;; 0x60000020
   \   00000026   1B68               LDR      R3,[R3, #+0]
   \   00000028   C024               MOVS     R4,#+192
   \   0000002A   A343               BICS     R3,R3,R4
   \   0000002C   1A00               MOVS     R2,R3
    950          
    951            /* Set MCOS[1:0] bits according to MRCC_MCO value */
    952            Temp |= MRCC_MCO;
   \   0000002E   0243               ORRS     R2,R2,R0
    953            
    954            /* Store the new value */
    955            MRCC->CLKCTL = Temp;
   \   00000030   024B               LDR      R3,??MRCC_MCOConfig_1  ;; 0x60000020
   \   00000032   1A60               STR      R2,[R3, #+0]
    956          }
   \   00000034   10BC               POP      {R4}
   \   00000036   01BC               POP      {R0}
   \   00000038   0047               BX       R0               ;; return
   \   0000003A   C046               Nop      
   \                     ??MRCC_MCOConfig_1:
   \   0000003C   20000060           DC32     0x60000020
    957          
    958          /*******************************************************************************
    959          * Function Name  : MRCC_OSC4MConfig
    960          * Description    : Configures the 4MHz main oscillator (OSC4M).
    961          *                  This function must be used when the CK_SYS is not clocked
    962          *                  by the OSC4M and the PLL is not enabled.
    963          * Input          : - MRCC_OSC4M: specifies the new state of the OSC4M oscillator.
    964          *                    This parameter can be one of the following values:
    965          *                          - MRCC_OSC4M_Default: OSC4M enabled, bypass disabled
    966          *                          - MRCC_OSC4M_Disable: OSC4M disabled
    967          *                          - MRCC_OSC4M_Bypass:  OSC4M bypassed
    968          * Output         : None
    969          * Return         : An ErrorStatus enumuration value:
    970          *                         - SUCCESS: Clock configuration succeeded
    971          *                         - ERROR: Clock configuration failed
    972          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    973          ErrorStatus MRCC_OSC4MConfig(u32 MRCC_OSC4M)
    974          {
   \                     MRCC_OSC4MConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    975            ErrorStatus Status = SUCCESS;
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   1000               MOVS     R0,R2
    976          
    977          /* If CK_SYS is driven by OSC4M or the PLL is enabled, exit ------------------*/           
    978            if(((MRCC->CLKCTL & MRCC_CKSEL_CKOSCSEL_Mask) == MRCC_CKSEL_Set_Mask) ||    
    979               (((MRCC->CLKCTL & MRCC_CKSEL_CKOSCSEL_Mask) == MRCC_CKSEL_CKOSCSEL_Mask) &&
    980               ((MRCC->PWRCTRL & MRCC_CKRTCSEL_Reset_Mask) != RESET))||
    981               ((MRCC->CLKCTL & MRCC_PLLEN_Set_Mask) != RESET))
   \   00000008   2A4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   A023               MOVS     R3,#+160
   \   0000000E   1B04               LSLS     R3,R3,#+16       ;; #+10485760
   \   00000010   1340               ANDS     R3,R3,R2
   \   00000012   8022               MOVS     R2,#+128
   \   00000014   1204               LSLS     R2,R2,#+16       ;; #+8388608
   \   00000016   9342               CMP      R3,R2
   \   00000018   12D0               BEQ      ??MRCC_OSC4MConfig_1
   \   0000001A   264A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000001C   1268               LDR      R2,[R2, #+0]
   \   0000001E   A023               MOVS     R3,#+160
   \   00000020   1B04               LSLS     R3,R3,#+16       ;; #+10485760
   \   00000022   1340               ANDS     R3,R3,R2
   \   00000024   A022               MOVS     R2,#+160
   \   00000026   1204               LSLS     R2,R2,#+16       ;; #+10485760
   \   00000028   9342               CMP      R3,R2
   \   0000002A   05D1               BNE      ??MRCC_OSC4MConfig_2
   \   0000002C   224A               LDR      R2,??MRCC_OSC4MConfig_0+0x4  ;; 0x60000028
   \   0000002E   1268               LDR      R2,[R2, #+0]
   \   00000030   224B               LDR      R3,??MRCC_OSC4MConfig_0+0x8  ;; 0xfcffffff
   \   00000032   1340               ANDS     R3,R3,R2
   \   00000034   002B               CMP      R3,#+0
   \   00000036   03D1               BNE      ??MRCC_OSC4MConfig_1
   \                     ??MRCC_OSC4MConfig_2:
   \   00000038   1E4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000003A   1268               LDR      R2,[R2, #+0]
   \   0000003C   D201               LSLS     R2,R2,#+7
   \   0000003E   02D5               BPL      ??MRCC_OSC4MConfig_3
    982            {
    983              Status = ERROR;
   \                     ??MRCC_OSC4MConfig_1:
   \   00000040   0022               MOVS     R2,#+0
   \   00000042   1000               MOVS     R0,R2
   \   00000044   30E0               B        ??MRCC_OSC4MConfig_4
    984            }
    985          /* Else configure the OSC4MOFF and OSC4MBYP bits -----------------------------*/   
    986            else
    987            {  
    988              switch(MRCC_OSC4M)
   \                     ??MRCC_OSC4MConfig_3:
   \   00000046   0A00               MOVS     R2,R1
   \   00000048   8023               MOVS     R3,#+128
   \   0000004A   5B02               LSLS     R3,R3,#+9        ;; #+65536
   \   0000004C   D21A               SUBS     R2,R2,R3
   \   0000004E   1BD0               BEQ      ??MRCC_OSC4MConfig_5
   \   00000050   8023               MOVS     R3,#+128
   \   00000052   5B02               LSLS     R3,R3,#+9        ;; #+65536
   \   00000054   D21A               SUBS     R2,R2,R3
   \   00000056   09D0               BEQ      ??MRCC_OSC4MConfig_6
   \   00000058   194B               LDR      R3,??MRCC_OSC4MConfig_0+0xC  ;; 0xfffaffff
   \   0000005A   D21A               SUBS     R2,R2,R3
   \   0000005C   22D1               BNE      ??MRCC_OSC4MConfig_7
    989              {
    990                case MRCC_OSC4M_Default:
    991                  MRCC->CLKCTL &= MRCC_OSC4MOFF_Reset_Mask & MRCC_OSC4MBYP_Reset_Mask;
   \                     ??MRCC_OSC4MConfig_8:
   \   0000005E   154A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000060   1268               LDR      R2,[R2, #+0]
   \   00000062   184B               LDR      R3,??MRCC_OSC4MConfig_0+0x10  ;; 0xfffcffff
   \   00000064   1340               ANDS     R3,R3,R2
   \   00000066   134A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000068   1360               STR      R3,[R2, #+0]
   \   0000006A   1DE0               B        ??MRCC_OSC4MConfig_4
    992                  break;
    993                
    994                case MRCC_OSC4M_Disable:
    995                  MRCC->CLKCTL &= MRCC_OSC4MBYP_Reset_Mask;
   \                     ??MRCC_OSC4MConfig_6:
   \   0000006C   114A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000006E   1268               LDR      R2,[R2, #+0]
   \   00000070   154B               LDR      R3,??MRCC_OSC4MConfig_0+0x14  ;; 0xfffeffff
   \   00000072   1340               ANDS     R3,R3,R2
   \   00000074   0F4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000076   1360               STR      R3,[R2, #+0]
    996                  MRCC->CLKCTL |= MRCC_OSC4MOFF_Set_Mask;
   \   00000078   0E4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000007A   1268               LDR      R2,[R2, #+0]
   \   0000007C   8023               MOVS     R3,#+128
   \   0000007E   9B02               LSLS     R3,R3,#+10       ;; #+131072
   \   00000080   1343               ORRS     R3,R3,R2
   \   00000082   0C4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000084   1360               STR      R3,[R2, #+0]
   \   00000086   0FE0               B        ??MRCC_OSC4MConfig_4
    997                  break;
    998                  
    999                case MRCC_OSC4M_Bypass:
   1000                  MRCC->CLKCTL &= MRCC_OSC4MOFF_Reset_Mask;
   \                     ??MRCC_OSC4MConfig_5:
   \   00000088   0A4A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   0000008A   1268               LDR      R2,[R2, #+0]
   \   0000008C   0F4B               LDR      R3,??MRCC_OSC4MConfig_0+0x18  ;; 0xfffdffff
   \   0000008E   1340               ANDS     R3,R3,R2
   \   00000090   084A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000092   1360               STR      R3,[R2, #+0]
   1001                  MRCC->CLKCTL |= MRCC_OSC4MBYP_Set_Mask;
   \   00000094   074A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   00000096   1268               LDR      R2,[R2, #+0]
   \   00000098   8023               MOVS     R3,#+128
   \   0000009A   5B02               LSLS     R3,R3,#+9        ;; #+65536
   \   0000009C   1343               ORRS     R3,R3,R2
   \   0000009E   054A               LDR      R2,??MRCC_OSC4MConfig_0  ;; 0x60000020
   \   000000A0   1360               STR      R3,[R2, #+0]
   \   000000A2   01E0               B        ??MRCC_OSC4MConfig_4
   1002                  break;        
   1003                
   1004                default:
   1005                  Status =  ERROR;
   \                     ??MRCC_OSC4MConfig_7:
   \   000000A4   0022               MOVS     R2,#+0
   \   000000A6   1000               MOVS     R0,R2
   1006                  break;      
   1007              }
   1008            }  
   1009            
   1010            return Status; 
   \                     ??MRCC_OSC4MConfig_4:
   \   000000A8   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000AA   000E               LSRS     R0,R0,#+24
   \   000000AC   08BC               POP      {R3}
   \   000000AE   02BC               POP      {R1}
   \   000000B0   0847               BX       R1               ;; return
   \   000000B2   C046               Nop      
   \                     ??MRCC_OSC4MConfig_0:
   \   000000B4   20000060           DC32     0x60000020
   \   000000B8   28000060           DC32     0x60000028
   \   000000BC   FFFFFFFC           DC32     0xfcffffff
   \   000000C0   FFFFFAFF           DC32     0xfffaffff
   \   000000C4   FFFFFCFF           DC32     0xfffcffff
   \   000000C8   FFFFFEFF           DC32     0xfffeffff
   \   000000CC   FFFFFDFF           DC32     0xfffdffff
   1011          }
   1012          
   1013          /*******************************************************************************
   1014          * Function Name  : MRCC_OSC32KConfig
   1015          * Description    : Configures the OSC32K oscillator.
   1016          *                  This function must be used when the CK_SYS is not clocked by
   1017          *                  the CK_RTC.
   1018          * Input          : - MRCC_OSC32K: specifies the new state of the OSC32K oscillator.
   1019          *                    This parameter can be one of the following values:
   1020          *                          - MRCC_OSC32K_Disable: OSC32K disabled
   1021          *                          - MRCC_OSC32K_Enable: OSC32K enabled
   1022          *                  - MRCC_OSC32KBypass: specifies if the OSC32K oscillator is
   1023          *                    bypassed or not.
   1024          *                    This parameter can be one of the following values:
   1025          *                          - MRCC_OSC32KBypass_Disable: OSC32K selected
   1026          *                          - MRCC_OSC32KBypass_Enable: OSC32K bypassed                          
   1027          * Output         : None
   1028          * Return         : An ErrorStatus enumuration value:
   1029          *                         - SUCCESS: Clock configuration succeeded
   1030          *                         - ERROR: Clock configuration failed
   1031          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1032          ErrorStatus MRCC_OSC32KConfig(u32 MRCC_OSC32K, u32 MRCC_OSC32KBypass)
   1033          { 
   \                     MRCC_OSC32KConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0200               MOVS     R2,R0
   1034          /* If CK_SYS is driven by CK_RTC, exit ---------------------------------------*/     
   1035            if(((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET) &&
   1036                ((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET))
   \   00000004   1848               LDR      R0,??MRCC_OSC32KConfig_0  ;; 0x60000020
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0002               LSLS     R0,R0,#+8
   \   0000000A   05D5               BPL      ??MRCC_OSC32KConfig_1
   \   0000000C   1648               LDR      R0,??MRCC_OSC32KConfig_0  ;; 0x60000020
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   8002               LSLS     R0,R0,#+10
   \   00000012   01D5               BPL      ??MRCC_OSC32KConfig_1
   1037            {
   1038              return ERROR;
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   24E0               B        ??MRCC_OSC32KConfig_2
   1039            }
   1040          /* Else configure the OSC32KEN and OSC32KBYP bits ----------------------------*/ 
   1041            else
   1042            { 
   1043              /* Configure OSC32KEN bit */
   1044              if(MRCC_OSC32K == MRCC_OSC32K_Enable)
   \                     ??MRCC_OSC32KConfig_1:
   \   00000018   8020               MOVS     R0,#+128
   \   0000001A   8005               LSLS     R0,R0,#+22       ;; #+536870912
   \   0000001C   8242               CMP      R2,R0
   \   0000001E   07D1               BNE      ??MRCC_OSC32KConfig_3
   1045              {
   1046                MRCC->PWRCTRL |= MRCC_OSC32K_Enable;
   \   00000020   1248               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   8023               MOVS     R3,#+128
   \   00000026   9B05               LSLS     R3,R3,#+22       ;; #+536870912
   \   00000028   0343               ORRS     R3,R3,R0
   \   0000002A   1048               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   0000002C   0360               STR      R3,[R0, #+0]
   \   0000002E   05E0               B        ??MRCC_OSC32KConfig_4
   1047              }
   1048              else
   1049              {
   1050                MRCC->PWRCTRL &= MRCC_OSC32K_Disable;
   \                     ??MRCC_OSC32KConfig_3:
   \   00000030   0E48               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   0E4B               LDR      R3,??MRCC_OSC32KConfig_0+0x8  ;; 0xdfffffff
   \   00000036   0340               ANDS     R3,R3,R0
   \   00000038   0C48               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   0000003A   0360               STR      R3,[R0, #+0]
   1051              }
   1052              
   1053              /* Configure OSC32KBYP bit */
   1054              if(MRCC_OSC32KBypass == MRCC_OSC32KBypass_Enable)
   \                     ??MRCC_OSC32KConfig_4:
   \   0000003C   8020               MOVS     R0,#+128
   \   0000003E   C005               LSLS     R0,R0,#+23       ;; #+1073741824
   \   00000040   8142               CMP      R1,R0
   \   00000042   07D1               BNE      ??MRCC_OSC32KConfig_5
   1055              {
   1056                MRCC->PWRCTRL |= MRCC_OSC32KBypass_Enable;
   \   00000044   0948               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   8023               MOVS     R3,#+128
   \   0000004A   DB05               LSLS     R3,R3,#+23       ;; #+1073741824
   \   0000004C   0343               ORRS     R3,R3,R0
   \   0000004E   0748               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   00000050   0360               STR      R3,[R0, #+0]
   \   00000052   05E0               B        ??MRCC_OSC32KConfig_6
   1057              }
   1058              else
   1059              {
   1060                MRCC->PWRCTRL &= MRCC_OSC32KBypass_Disable;
   \                     ??MRCC_OSC32KConfig_5:
   \   00000054   0548               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   00000056   0068               LDR      R0,[R0, #+0]
   \   00000058   064B               LDR      R3,??MRCC_OSC32KConfig_0+0xC  ;; 0xbfffffff
   \   0000005A   0340               ANDS     R3,R3,R0
   \   0000005C   0348               LDR      R0,??MRCC_OSC32KConfig_0+0x4  ;; 0x60000028
   \   0000005E   0360               STR      R3,[R0, #+0]
   1061              }   
   1062               
   1063              return SUCCESS;   
   \                     ??MRCC_OSC32KConfig_6:
   \   00000060   0120               MOVS     R0,#+1
   \                     ??MRCC_OSC32KConfig_2:
   \   00000062   08BC               POP      {R3}
   \   00000064   02BC               POP      {R1}
   \   00000066   0847               BX       R1               ;; return
   \                     ??MRCC_OSC32KConfig_0:
   \   00000068   20000060           DC32     0x60000020
   \   0000006C   28000060           DC32     0x60000028
   \   00000070   FFFFFFDF           DC32     0xdfffffff
   \   00000074   FFFFFFBF           DC32     0xbfffffff
   1064            }
   1065          }
   1066          
   1067          /*******************************************************************************
   1068          * Function Name  : MRCC_LPOSCConfig
   1069          * Description    : Enables or disables the LPOSC oscillator.
   1070          *                  This function must be used when the CK_SYS is not clocked by
   1071          *                  the CK_RTC.
   1072          * Input          : - MRCC_LPOSC: specifies the new state of the LPOSC oscillator.
   1073          *                    This parameter can be one of the following values:
   1074          *                          - MRCC_LPOSC_Disable: LPOSC disabled
   1075          *                          - MRCC_LPOSC_Enable: LPOSC enabled
   1076          * Output         : None
   1077          * Return         : An ErrorStatus enumuration value:
   1078          *                         - SUCCESS: Clock configuration succeeded
   1079          *                         - ERROR: Clock configuration failed
   1080          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1081          ErrorStatus MRCC_LPOSCConfig(u32 MRCC_LPOSC)
   1082          {
   \                     MRCC_LPOSCConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
   1083          /* If CK_SYS is driven by CK_RTC or LPOSC is used as CK_RTC clock source, exit*/      
   1084            if((((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET) &&
   1085               ((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)) ||
   1086               ((MRCC->PWRCTRL & MRCC_CKRTCSEL_Set_Mask) == MRCC_CKRTC_LPOSC)) 
   \   00000004   1448               LDR      R0,??MRCC_LPOSCConfig_0  ;; 0x60000020
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   0002               LSLS     R0,R0,#+8
   \   0000000A   03D5               BPL      ??MRCC_LPOSCConfig_1
   \   0000000C   1248               LDR      R0,??MRCC_LPOSCConfig_0  ;; 0x60000020
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   8002               LSLS     R0,R0,#+10
   \   00000012   08D4               BMI      ??MRCC_LPOSCConfig_2
   \                     ??MRCC_LPOSCConfig_1:
   \   00000014   1148               LDR      R0,??MRCC_LPOSCConfig_0+0x4  ;; 0x60000028
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   C022               MOVS     R2,#+192
   \   0000001A   9204               LSLS     R2,R2,#+18       ;; #+50331648
   \   0000001C   0240               ANDS     R2,R2,R0
   \   0000001E   C020               MOVS     R0,#+192
   \   00000020   8004               LSLS     R0,R0,#+18       ;; #+50331648
   \   00000022   8242               CMP      R2,R0
   \   00000024   01D1               BNE      ??MRCC_LPOSCConfig_3
   1087            {
   1088              return ERROR;
   \                     ??MRCC_LPOSCConfig_2:
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   12E0               B        ??MRCC_LPOSCConfig_4
   1089            }
   1090          /* Else configure the LPOSCEN bit --------------------------------------------*/  
   1091            else
   1092            {   
   1093              if(MRCC_LPOSC == MRCC_LPOSC_Enable)
   \                     ??MRCC_LPOSCConfig_3:
   \   0000002A   8020               MOVS     R0,#+128
   \   0000002C   4005               LSLS     R0,R0,#+21       ;; #+268435456
   \   0000002E   8142               CMP      R1,R0
   \   00000030   07D1               BNE      ??MRCC_LPOSCConfig_5
   1094              {
   1095                MRCC->PWRCTRL |= MRCC_LPOSC_Enable;
   \   00000032   0A48               LDR      R0,??MRCC_LPOSCConfig_0+0x4  ;; 0x60000028
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   8022               MOVS     R2,#+128
   \   00000038   5205               LSLS     R2,R2,#+21       ;; #+268435456
   \   0000003A   0243               ORRS     R2,R2,R0
   \   0000003C   0748               LDR      R0,??MRCC_LPOSCConfig_0+0x4  ;; 0x60000028
   \   0000003E   0260               STR      R2,[R0, #+0]
   \   00000040   05E0               B        ??MRCC_LPOSCConfig_6
   1096              }
   1097              else
   1098              {
   1099                MRCC->PWRCTRL &= MRCC_LPOSC_Disable;
   \                     ??MRCC_LPOSCConfig_5:
   \   00000042   0648               LDR      R0,??MRCC_LPOSCConfig_0+0x4  ;; 0x60000028
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   064A               LDR      R2,??MRCC_LPOSCConfig_0+0x8  ;; 0xefffffff
   \   00000048   0240               ANDS     R2,R2,R0
   \   0000004A   0448               LDR      R0,??MRCC_LPOSCConfig_0+0x4  ;; 0x60000028
   \   0000004C   0260               STR      R2,[R0, #+0]
   1100              }
   1101          
   1102              return SUCCESS;
   \                     ??MRCC_LPOSCConfig_6:
   \   0000004E   0120               MOVS     R0,#+1
   \                     ??MRCC_LPOSCConfig_4:
   \   00000050   08BC               POP      {R3}
   \   00000052   02BC               POP      {R1}
   \   00000054   0847               BX       R1               ;; return
   \   00000056   C046               Nop      
   \                     ??MRCC_LPOSCConfig_0:
   \   00000058   20000060           DC32     0x60000020
   \   0000005C   28000060           DC32     0x60000028
   \   00000060   FFFFFFEF           DC32     0xefffffff
   1103            }     
   1104          }
   1105          
   1106          /*******************************************************************************
   1107          * Function Name  : MRCC_RTCMConfig
   1108          * Description    : Enables or disables RTC clock measurement.
   1109          * Input          : - MRCC_RTCM: specifies whether CK_RTC is connected to TB 
   1110          *                    timer IC1 or not.
   1111          *                    This parameter can be one of the following values:
   1112          *                          - MRCC_RTCM_Disable: CK_RTC not connected to TB timer IC1
   1113          *                          - MRCC_RTCM_Enable: CK_RTC connected to TB timer IC1
   1114          * Output         : None
   1115          * Return         : None
   1116          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1117          void MRCC_RTCMConfig(u32 MRCC_RTCM)
   1118          {
   \                     MRCC_RTCMConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   1119            if(MRCC_RTCM == MRCC_RTCM_Enable)
   \   00000002   8021               MOVS     R1,#+128
   \   00000004   C904               LSLS     R1,R1,#+19       ;; #+67108864
   \   00000006   8842               CMP      R0,R1
   \   00000008   07D1               BNE      ??MRCC_RTCMConfig_0
   1120            {
   1121              MRCC->PWRCTRL |= MRCC_RTCM_Enable;
   \   0000000A   0849               LDR      R1,??MRCC_RTCMConfig_1  ;; 0x60000028
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   8022               MOVS     R2,#+128
   \   00000010   D204               LSLS     R2,R2,#+19       ;; #+67108864
   \   00000012   0A43               ORRS     R2,R2,R1
   \   00000014   0549               LDR      R1,??MRCC_RTCMConfig_1  ;; 0x60000028
   \   00000016   0A60               STR      R2,[R1, #+0]
   \   00000018   05E0               B        ??MRCC_RTCMConfig_2
   1122            }
   1123            else
   1124            {
   1125              MRCC->PWRCTRL &= MRCC_RTCM_Disable;
   \                     ??MRCC_RTCMConfig_0:
   \   0000001A   0449               LDR      R1,??MRCC_RTCMConfig_1  ;; 0x60000028
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   044A               LDR      R2,??MRCC_RTCMConfig_1+0x4  ;; 0xfbffffff
   \   00000020   0A40               ANDS     R2,R2,R1
   \   00000022   0249               LDR      R1,??MRCC_RTCMConfig_1  ;; 0x60000028
   \   00000024   0A60               STR      R2,[R1, #+0]
   1126            }  
   1127          }
   \                     ??MRCC_RTCMConfig_2:
   \   00000026   08BC               POP      {R3}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??MRCC_RTCMConfig_1:
   \   0000002C   28000060           DC32     0x60000028
   \   00000030   FFFFFFFB           DC32     0xfbffffff
   1128          
   1129          /*******************************************************************************
   1130          * Function Name  : MRCC_SetBuilderCounter
   1131          * Description    : Sets the builder counter value which defines the delay for
   1132          *                  the 4MHz main oscillator (OSC4M) clock to be stabilized.
   1133          * Input          : - BuilderCounter: defines the delay for the OSC4M oscillator
   1134          *                    clock to be stabilized.
   1135          * Output         : None
   1136          * Return         : None
   1137          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1138          void MRCC_SetBuilderCounter(u8 BuilderCounter)
   1139          { 
   1140            *(u8 *) 0x60000026 = BuilderCounter;
   \                     MRCC_SetBuilderCounter:
   \   00000000   0149               LDR      R1,??MRCC_SetBuilderCounter_0  ;; 0x60000026
   \   00000002   0870               STRB     R0,[R1, #+0]
   1141          }
   \   00000004   7047               BX       LR               ;; return
   \   00000006   C046               Nop      
   \                     ??MRCC_SetBuilderCounter_0:
   \   00000008   26000060           DC32     0x60000026
   1142          
   1143          /*******************************************************************************
   1144          * Function Name  : MRCC_GetCKSYSCounter
   1145          * Description    : Gets the result of the delay applied to CK_SYS before
   1146          *                  starting the CPU.
   1147          * Input          : None
   1148          * Output         : None
   1149          * Return         : SCOUNT value.
   1150          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1151          u16 MRCC_GetCKSYSCounter(void)
   1152          {
   1153            return((u16)(MRCC->RFSR & 0x0FFF));
   \                     MRCC_GetCKSYSCounter:
   \   00000000   0248               LDR      R0,??MRCC_GetCKSYSCounter_0  ;; 0x60000024
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0005               LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   00000006   000D               LSRS     R0,R0,#+20
   \   00000008   7047               BX       LR               ;; return
   \   0000000A   C046               Nop      
   \                     ??MRCC_GetCKSYSCounter_0:
   \   0000000C   24000060           DC32     0x60000024
   1154          }
   1155          
   1156          /*******************************************************************************
   1157          * Function Name  : MRCC_GetFlagStatus
   1158          * Description    : Checks whether the specified MRCC flag is set or not.
   1159          * Input          : - MRCC_FLAG: specifies the flag to check.
   1160          *                    This parameter can be one of the following values:
   1161          *                          - MRCC_FLAG_LOCK: PLL Locked flag
   1162          *                          - MRCC_FLAG_LOCKIF: PLL Lock Interrupt status flag
   1163          *                          - MRCC_FLAG_CKSEL: CK_SYS source staus flag
   1164          *                          - MRCC_FLAG_CKOSCSEL: CK_OSC clock source staus flag
   1165          *                          - MRCC_FLAG_NCKD: No Clock Detected flag
   1166          *                          - MRCC_FLAG_SWR: Software Reset flag
   1167          *                          - MRCC_FLAG_WDGR: Watchdog Reset flag
   1168          *                          - MRCC_FLAG_EXTR: External Reset flag
   1169          *                          - MRCC_FLAG_WKP: Wake-Up flag
   1170          *                          - MRCC_FLAG_STDB: STANDBY flag
   1171          *                          - MRCC_FLAG_BCOUNT:   Builder Counter Flag
   1172          *                          - MRCC_FLAG_OSC32KRDY: Oscillator 32K Ready
   1173          *                          - MRCC_FLAG_CKRTCOK: CK_RTC OK
   1174          *                          - MRCC_FLAG_LPDONE: Low Power Bit Sequence has been performed
   1175          *                          - MRCC_FLAG_LP: Low Power Mode Entry
   1176          * Output         : None
   1177          * Return         : The new state of MRCC_FLAG (SET or RESET).
   1178          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1179          FlagStatus MRCC_GetFlagStatus(u8 MRCC_FLAG)
   1180          {
   \                     MRCC_GetFlagStatus:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0100               MOVS     R1,R0
   1181            u32 MRCCReg = 0, FlagPos = 0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0200               MOVS     R2,R0
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0300               MOVS     R3,R0
   1182            u32 StatusReg = 0;
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0400               MOVS     R4,R0
   1183          
   1184            /* Get the MRCC register index */
   1185            MRCCReg = MRCC_FLAG >> 5;
   \   00000010   0800               MOVS     R0,R1
   \   00000012   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000014   000E               LSRS     R0,R0,#+24
   \   00000016   4009               LSRS     R0,R0,#+5
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   0200               MOVS     R2,R0
   1186          
   1187            /* Get the flag position */
   1188            FlagPos = MRCC_FLAG & MRCC_FLAG_Mask;
   \   0000001E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000020   090E               LSRS     R1,R1,#+24
   \   00000022   C806               LSLS     R0,R1,#+27       ;; ZeroExtS R0,R1,#+27,#+27
   \   00000024   C00E               LSRS     R0,R0,#+27
   \   00000026   0300               MOVS     R3,R0
   1189          
   1190            if(MRCCReg == 1) /* The flag to check is in CLKCTL register */
   \   00000028   012A               CMP      R2,#+1
   \   0000002A   03D1               BNE      ??MRCC_GetFlagStatus_0
   1191            {
   1192              StatusReg = MRCC->CLKCTL;
   \   0000002C   0D48               LDR      R0,??MRCC_GetFlagStatus_1  ;; 0x60000020
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   0400               MOVS     R4,R0
   \   00000032   0AE0               B        ??MRCC_GetFlagStatus_2
   1193            }
   1194            else if (MRCCReg == 2) /* The flag to check is in RFSR register */
   \                     ??MRCC_GetFlagStatus_0:
   \   00000034   022A               CMP      R2,#+2
   \   00000036   03D1               BNE      ??MRCC_GetFlagStatus_3
   1195            {
   1196              StatusReg = MRCC->RFSR;
   \   00000038   0B48               LDR      R0,??MRCC_GetFlagStatus_1+0x4  ;; 0x60000024
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   0400               MOVS     R4,R0
   \   0000003E   04E0               B        ??MRCC_GetFlagStatus_2
   1197            }
   1198            else if(MRCCReg == 3) /* The flag to check is in PWRCTRL register */
   \                     ??MRCC_GetFlagStatus_3:
   \   00000040   032A               CMP      R2,#+3
   \   00000042   02D1               BNE      ??MRCC_GetFlagStatus_2
   1199            {
   1200              StatusReg = MRCC->PWRCTRL;
   \   00000044   0948               LDR      R0,??MRCC_GetFlagStatus_1+0x8  ;; 0x60000028
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   0400               MOVS     R4,R0
   1201            }
   1202            
   1203            if((StatusReg & (1 << FlagPos))!= RESET)
   \                     ??MRCC_GetFlagStatus_2:
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   9840               LSLS     R0,R0,R3
   \   0000004E   2040               ANDS     R0,R0,R4
   \   00000050   401E               SUBS     R0,R0,#+1
   \   00000052   8041               SBCS     R0,R0,R0
   \   00000054   C043               MVNS     R0,R0
   \   00000056   C00F               LSRS     R0,R0,#+31
   \   00000058   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000005A   000E               LSRS     R0,R0,#+24
   1204            {
   1205              return SET;
   1206            }
   1207            else
   1208            {
   1209              return RESET;
   \   0000005C   10BC               POP      {R4}
   \   0000005E   02BC               POP      {R1}
   \   00000060   0847               BX       R1               ;; return
   \   00000062   C046               Nop      
   \                     ??MRCC_GetFlagStatus_1:
   \   00000064   20000060           DC32     0x60000020
   \   00000068   24000060           DC32     0x60000024
   \   0000006C   28000060           DC32     0x60000028
   1210            }
   1211          }
   1212          
   1213          /*******************************************************************************
   1214          * Function Name  : MRCC_ClearFlag
   1215          * Description    : Clears the MRCC’s pending flags.
   1216          * Input          : - MRCC_FLAG: specifies the flag to clear.
   1217          *                    This parameter can be one of the following values:
   1218          *                          - MRCC_FLAG_NCKD: No Clock Detected flag
   1219          *                          - MRCC_FLAG_SWR: Software Reset flag
   1220          *                          - MRCC_FLAG_WDGR: Watchdog Reset flag
   1221          *                          - MRCC_FLAG_EXTR: External Reset flag
   1222          *                          - MRCC_FLAG_WKP: Wake-Up flag
   1223          *                          - MRCC_FLAG_STDB: STANDBY flag
   1224          *                          - MRCC_FLAG_LPDONE: Low Power Bit Sequence has been performed
   1225          * Output         : None
   1226          * Return         : None
   1227          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1228          void MRCC_ClearFlag(u8 MRCC_FLAG)
   1229          {
   \                     MRCC_ClearFlag:
   \   00000000   10B5               PUSH     {R4,LR}
   1230            u32 MRCCReg = 0, FlagPos = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   1900               MOVS     R1,R3
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   1A00               MOVS     R2,R3
   1231          
   1232            /* Get the MRCC register index */
   1233            MRCCReg = MRCC_FLAG >> 5;
   \   0000000A   0300               MOVS     R3,R0
   \   0000000C   1B06               LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \   0000000E   1B0E               LSRS     R3,R3,#+24
   \   00000010   5B09               LSRS     R3,R3,#+5
   \   00000012   1B06               LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \   00000014   1B0E               LSRS     R3,R3,#+24
   \   00000016   1900               MOVS     R1,R3
   1234          
   1235            /* Get the flag position */
   1236            FlagPos = MRCC_FLAG & MRCC_FLAG_Mask;
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   C306               LSLS     R3,R0,#+27       ;; ZeroExtS R3,R0,#+27,#+27
   \   0000001E   DB0E               LSRS     R3,R3,#+27
   \   00000020   1A00               MOVS     R2,R3
   1237          
   1238            if(MRCCReg == 1) /* The flag to clear is in CLKCTL register */
   \   00000022   0129               CMP      R1,#+1
   \   00000024   07D1               BNE      ??MRCC_ClearFlag_0
   1239            {
   1240              MRCC->CLKCTL &= ~(1 << FlagPos);
   \   00000026   0F4B               LDR      R3,??MRCC_ClearFlag_1  ;; 0x60000020
   \   00000028   1B68               LDR      R3,[R3, #+0]
   \   0000002A   0124               MOVS     R4,#+1
   \   0000002C   9440               LSLS     R4,R4,R2
   \   0000002E   A343               BICS     R3,R3,R4
   \   00000030   0C4C               LDR      R4,??MRCC_ClearFlag_1  ;; 0x60000020
   \   00000032   2360               STR      R3,[R4, #+0]
   \   00000034   12E0               B        ??MRCC_ClearFlag_2
   1241            }
   1242            else if (MRCCReg == 2) /* The flag to clear is in RFSR register */
   \                     ??MRCC_ClearFlag_0:
   \   00000036   0229               CMP      R1,#+2
   \   00000038   07D1               BNE      ??MRCC_ClearFlag_3
   1243            {
   1244              MRCC->RFSR &= ~(1 << FlagPos);
   \   0000003A   0B4B               LDR      R3,??MRCC_ClearFlag_1+0x4  ;; 0x60000024
   \   0000003C   1B68               LDR      R3,[R3, #+0]
   \   0000003E   0124               MOVS     R4,#+1
   \   00000040   9440               LSLS     R4,R4,R2
   \   00000042   A343               BICS     R3,R3,R4
   \   00000044   084C               LDR      R4,??MRCC_ClearFlag_1+0x4  ;; 0x60000024
   \   00000046   2360               STR      R3,[R4, #+0]
   \   00000048   08E0               B        ??MRCC_ClearFlag_2
   1245            }
   1246            else if(MRCCReg == 3) /* The flag to clear is in PWRCTRL register */
   \                     ??MRCC_ClearFlag_3:
   \   0000004A   0329               CMP      R1,#+3
   \   0000004C   06D1               BNE      ??MRCC_ClearFlag_2
   1247            {
   1248              MRCC->PWRCTRL &= ~(1 << FlagPos);
   \   0000004E   074B               LDR      R3,??MRCC_ClearFlag_1+0x8  ;; 0x60000028
   \   00000050   1B68               LDR      R3,[R3, #+0]
   \   00000052   0124               MOVS     R4,#+1
   \   00000054   9440               LSLS     R4,R4,R2
   \   00000056   A343               BICS     R3,R3,R4
   \   00000058   044C               LDR      R4,??MRCC_ClearFlag_1+0x8  ;; 0x60000028
   \   0000005A   2360               STR      R3,[R4, #+0]
   1249            }
   1250          }
   \                     ??MRCC_ClearFlag_2:
   \   0000005C   10BC               POP      {R4}
   \   0000005E   01BC               POP      {R0}
   \   00000060   0047               BX       R0               ;; return
   \   00000062   C046               Nop      
   \                     ??MRCC_ClearFlag_1:
   \   00000064   20000060           DC32     0x60000020
   \   00000068   24000060           DC32     0x60000024
   \   0000006C   28000060           DC32     0x60000028
   1251          
   1252          /*******************************************************************************
   1253          * Function Name  : MRCC_GetITStatus
   1254          * Description    : Checks whether the specified MRCC interrupt has occurred or not.
   1255          * Input          : - MRCC_IT: specifies the MRCC interrupt source to check.
   1256          *                    This parameter can be one of the following values:
   1257          *                          - MRCC_IT_LOCK: PLL lock interrupt
   1258          *                          - MRCC_IT_NCKD: No Clock detected interrupt
   1259          * Output         : None
   1260          * Return         : The new state of MRCC_IT (SET or RESET).
   1261          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1262          ITStatus MRCC_GetITStatus(u32 MRCC_IT)
   1263          {
   \                     MRCC_GetITStatus:
   \   00000000   0100               MOVS     R1,R0
   1264            /* Check the specified interrupt pending bit */
   1265            if((MRCC->CLKCTL & (MRCC_IT >> 1)) != RESET)
   \   00000002   0648               LDR      R0,??MRCC_GetITStatus_0  ;; 0x60000020
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   5208               LSRS     R2,R2,#+1
   \   0000000A   0240               ANDS     R2,R2,R0
   \   0000000C   1000               MOVS     R0,R2
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   8041               SBCS     R0,R0,R0
   \   00000012   C043               MVNS     R0,R0
   \   00000014   C00F               LSRS     R0,R0,#+31
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   1266            {
   1267              return SET;
   1268            }
   1269            else
   1270            {
   1271              return RESET;
   \   0000001A   7047               BX       LR               ;; return
   \                     ??MRCC_GetITStatus_0:
   \   0000001C   20000060           DC32     0x60000020
   1272            }
   1273          }
   1274          
   1275          /*******************************************************************************
   1276          * Function Name  : MRCC_ClearITPendingBit
   1277          * Description    : Clears the MRCC’s interrupt pending bits.
   1278          * Input          : - MRCC_IT: specifies the interrupt pending bit to clear.
   1279          *                    This parameter can be any combination of the following
   1280          *                    values:
   1281          *                          - MRCC_IT_LOCK: PLL lock interrupt
   1282          *                          - MRCC_IT_NCKD: No Clock detected interrupt
   1283          * Output         : None
   1284          * Return         : None
   1285          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1286          void MRCC_ClearITPendingBit(u32 MRCC_IT)
   1287          {
   1288            /* Clear the specified interrupt pending bit */
   1289            MRCC->CLKCTL &= ~(MRCC_IT >> 1);
   \                     MRCC_ClearITPendingBit:
   \   00000000   0349               LDR      R1,??MRCC_ClearITPendingBit_0  ;; 0x60000020
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   0200               MOVS     R2,R0
   \   00000006   5208               LSRS     R2,R2,#+1
   \   00000008   9143               BICS     R1,R1,R2
   \   0000000A   014A               LDR      R2,??MRCC_ClearITPendingBit_0  ;; 0x60000020
   \   0000000C   1160               STR      R1,[R2, #+0]
   1290          }
   \   0000000E   7047               BX       LR               ;; return
   \                     ??MRCC_ClearITPendingBit_0:
   \   00000010   20000060           DC32     0x60000020
   1291          
   1292          /*******************************************************************************
   1293          * Function Name  : MRCC_WaitForOSC4MStartUp
   1294          * Description    : Waits for OSC4M start-up.
   1295          * Input          : None
   1296          * Output         : None
   1297          * Return         : An ErrorStatus enumuration value:
   1298          *                         - SUCCESS: OSC4M oscillator is stable and ready to use
   1299          *                         - ERROR: no clock is detected on OSC4M
   1300          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1301          ErrorStatus MRCC_WaitForOSC4MStartUp(void)
   1302          {
   \                     MRCC_WaitForOSC4MStartUp:
   \   00000000   10B5               PUSH     {R4,LR}
   1303            u32 StartUpCounter = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0400               MOVS     R4,R0
   1304          
   1305            do
   1306            {
   1307              /* Clear No Clock Detected flag */
   1308              if(MRCC_GetFlagStatus(MRCC_FLAG_NCKD) != RESET)
   \                     ??MRCC_WaitForOSC4MStartUp_0:
   \   00000006   3220               MOVS     R0,#+50
   \   00000008   ........           BL       MRCC_GetFlagStatus
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   02D0               BEQ      ??MRCC_WaitForOSC4MStartUp_1
   1309              {
   1310                MRCC_ClearFlag(MRCC_FLAG_NCKD);
   \   00000010   3220               MOVS     R0,#+50
   \   00000012   ........           BL       MRCC_ClearFlag
   1311              }
   1312          
   1313              StartUpCounter++;
   \                     ??MRCC_WaitForOSC4MStartUp_1:
   \   00000016   641C               ADDS     R4,R4,#+1
   1314          
   1315            }while((MRCC_GetFlagStatus(MRCC_FLAG_BCOUNT) == RESET)&&
   1316                   (StartUpCounter != OSC4MStartUp_TimeOut));
   \   00000018   5820               MOVS     R0,#+88
   \   0000001A   ........           BL       MRCC_GetFlagStatus
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   01D1               BNE      ??MRCC_WaitForOSC4MStartUp_2
   \   00000022   FE2C               CMP      R4,#+254
   \   00000024   EFD1               BNE      ??MRCC_WaitForOSC4MStartUp_0
   1317            
   1318            if(MRCC_GetFlagStatus(MRCC_FLAG_BCOUNT) != RESET)
   \                     ??MRCC_WaitForOSC4MStartUp_2:
   \   00000026   5820               MOVS     R0,#+88
   \   00000028   ........           BL       MRCC_GetFlagStatus
   \   0000002C   401E               SUBS     R0,R0,#+1
   \   0000002E   8041               SBCS     R0,R0,R0
   \   00000030   C043               MVNS     R0,R0
   \   00000032   C00F               LSRS     R0,R0,#+31
   \   00000034   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000036   000E               LSRS     R0,R0,#+24
   1319            {
   1320              return SUCCESS;
   1321            }
   1322            else
   1323            {
   1324              return ERROR;
   \   00000038   10BC               POP      {R4}
   \   0000003A   02BC               POP      {R1}
   \   0000003C   0847               BX       R1               ;; return
   1325            }  
   1326          }
   1327          
   1328          /*******************************************************************************
   1329          * Function Name  : SetCKSYS_FREEOSC
   1330          * Description    : Selects FREEOSC as CK_SYS clock source.
   1331          * Input          : None
   1332          * Output         : None
   1333          * Return         : An ErrorStatus enumuration value:
   1334          *                         - SUCCESS: Clock configuration succeeded
   1335          *                         - ERROR: Clock configuration failed
   1336          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1337          static ErrorStatus SetCKSYS_FREEOSC(void)
   1338          {
   \                     SetCKSYS_FREEOSC:
   \   00000000   01B5               PUSH     {R0,LR}
   1339            /* Check if the PLL is enabled */
   1340            if((MRCC->CLKCTL & MRCC_PLLEN_Set_Mask) != RESET)
   \   00000002   1A48               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   C001               LSLS     R0,R0,#+7
   \   00000008   1DD5               BPL      ??SetCKSYS_FREEOSC_1
   1341            {  
   1342              if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) == RESET)
   \   0000000A   1848               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   0002               LSLS     R0,R0,#+8
   \   00000010   13D4               BMI      ??SetCKSYS_FREEOSC_2
   1343              { /* CK_PLL1 used as Ck_SYS clock source*/
   1344          
   1345                if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \   00000012   1648               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   8002               LSLS     R0,R0,#+10
   \   00000018   08D5               BPL      ??SetCKSYS_FREEOSC_3
   1346                {/* Check if CK_RTC source clock is present*/ 
   1347                  if((MRCC->PWRCTRL & MRCC_CKRTCSEL_Set_Mask) == RESET) 
   \   0000001A   1548               LDR      R0,??SetCKSYS_FREEOSC_0+0x4  ;; 0x60000028
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   C021               MOVS     R1,#+192
   \   00000020   8904               LSLS     R1,R1,#+18       ;; #+50331648
   \   00000022   0140               ANDS     R1,R1,R0
   \   00000024   0029               CMP      R1,#+0
   \   00000026   01D1               BNE      ??SetCKSYS_FREEOSC_3
   1348                  {
   1349                    /* CK_RTC disabled*/
   1350                    return ERROR;
   \   00000028   0020               MOVS     R0,#+0
   \   0000002A   1CE0               B        ??SetCKSYS_FREEOSC_4
   1351                  }
   1352                }
   1353                
   1354                /* Select CK_OSC as CK_SYS clock source */
   1355                MRCC->CLKCTL |= MRCC_CKSEL_Set_Mask;
   \                     ??SetCKSYS_FREEOSC_3:
   \   0000002C   0F48               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   8021               MOVS     R1,#+128
   \   00000032   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000034   0143               ORRS     R1,R1,R0
   \   00000036   0D48               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000038   0160               STR      R1,[R0, #+0]
   1356              }  
   1357              
   1358              /* Disable PLL */
   1359              MRCC->CLKCTL &= MRCC_PLLEN_Reset_Mask;
   \                     ??SetCKSYS_FREEOSC_2:
   \   0000003A   0C48               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   0D49               LDR      R1,??SetCKSYS_FREEOSC_0+0x8  ;; 0xfeffffff
   \   00000040   0140               ANDS     R1,R1,R0
   \   00000042   0A48               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000044   0160               STR      R1,[R0, #+0]
   1360            }
   1361          
   1362            /* Select CK_PLL1 as CK_SYS clock source */
   1363            MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \                     ??SetCKSYS_FREEOSC_1:
   \   00000046   0948               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   0B49               LDR      R1,??SetCKSYS_FREEOSC_0+0xC  ;; 0xff7fffff
   \   0000004C   0140               ANDS     R1,R1,R0
   \   0000004E   0748               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000050   0160               STR      R1,[R0, #+0]
   1364          
   1365            if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) == RESET)
   \   00000052   0648               LDR      R0,??SetCKSYS_FREEOSC_0  ;; 0x60000020
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   8021               MOVS     R1,#+128
   \   00000058   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   0000005A   0140               ANDS     R1,R1,R0
   \   0000005C   481E               SUBS     R0,R1,#+1
   \   0000005E   8041               SBCS     R0,R0,R0
   \   00000060   C00F               LSRS     R0,R0,#+31
   \   00000062   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000064   000E               LSRS     R0,R0,#+24
   1366            {
   1367              return SUCCESS;
   \                     ??SetCKSYS_FREEOSC_4:
   \   00000066   08BC               POP      {R3}
   \   00000068   02BC               POP      {R1}
   \   0000006A   0847               BX       R1               ;; return
   \                     ??SetCKSYS_FREEOSC_0:
   \   0000006C   20000060           DC32     0x60000020
   \   00000070   28000060           DC32     0x60000028
   \   00000074   FFFFFFFE           DC32     0xfeffffff
   \   00000078   FFFF7FFF           DC32     0xff7fffff
   1368            }
   1369            else
   1370            {
   1371              return ERROR;
   1372            }
   1373          }
   1374          
   1375          /*******************************************************************************
   1376          * Function Name  : SetCKSYS_OSC4M
   1377          * Description    : Selects 4MHz main oscillator (OSC4M) as CK_SYS clock source.
   1378          * Input          : PLL_State: specifies the PLL state.
   1379          * Output         : None
   1380          * Return         : An ErrorStatus enumuration value:
   1381          *                         - SUCCESS: Clock configuration succeeded
   1382          *                         - ERROR: Clock configuration failed
   1383          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1384          static ErrorStatus SetCKSYS_OSC4M(u32 PLL_State)
   1385          {
   \                     SetCKSYS_OSC4M:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1386          /* If OSC4M is not present, exit ---------------------------------------------*/      
   1387            if(((MRCC->CLKCTL & MRCC_NCKDF_Set_Mask) != RESET) || 
   1388               ((MRCC->CLKCTL & MRCC_OSC4MOFF_Set_Mask) != RESET) ) 
   \   00000004   1C48               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   4003               LSLS     R0,R0,#+13
   \   0000000A   03D4               BMI      ??SetCKSYS_OSC4M_1
   \   0000000C   1A48               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   8003               LSLS     R0,R0,#+14
   \   00000012   01D5               BPL      ??SetCKSYS_OSC4M_2
   1389            {
   1390              /* OSC4M disabled or OSC4M clock is not present*/
   1391              return ERROR;
   \                     ??SetCKSYS_OSC4M_1:
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   2CE0               B        ??SetCKSYS_OSC4M_3
   1392            }
   1393          
   1394          /* Else configure CKSEL and CKOSCSEL bits ------------------------------------*/          
   1395            if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \                     ??SetCKSYS_OSC4M_2:
   \   00000018   1748               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   8002               LSLS     R0,R0,#+10
   \   0000001E   11D5               BPL      ??SetCKSYS_OSC4M_4
   1396            { /* CK_RTC used as CK_OSC clock */   
   1397            
   1398              if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET) 
   \   00000020   1548               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   0002               LSLS     R0,R0,#+8
   \   00000026   05D5               BPL      ??SetCKSYS_OSC4M_5
   1399              {
   1400                /* Select CK_PLL1 as CK_SYS clock source */
   1401                MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   00000028   1348               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   1349               LDR      R1,??SetCKSYS_OSC4M_0+0x4  ;; 0xff7fffff
   \   0000002E   0140               ANDS     R1,R1,R0
   \   00000030   1148               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000032   0160               STR      R1,[R0, #+0]
   1402              }
   1403              
   1404              /* Clear CKOSCSEL bit ----------------------------------------------------*/
   1405              /* Execute CKOSCSEL bit writing sequence */
   1406              WriteCKOSCSELBit();
   \                     ??SetCKSYS_OSC4M_5:
   \   00000034   ........           BL       WriteCKOSCSELBit
   1407          
   1408              /* Check if CKOSCSEL is set to 0 */
   1409              if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \   00000038   0F48               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   8002               LSLS     R0,R0,#+10
   \   0000003E   01D5               BPL      ??SetCKSYS_OSC4M_4
   1410              {
   1411                return ERROR;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   16E0               B        ??SetCKSYS_OSC4M_3
   1412              }
   1413            }  
   1414           
   1415            /* Select CK_OSC as CK_SYS clock source */
   1416            MRCC->CLKCTL |= MRCC_CKSEL_Set_Mask;
   \                     ??SetCKSYS_OSC4M_4:
   \   00000044   0C48               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   8021               MOVS     R1,#+128
   \   0000004A   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   0000004C   0143               ORRS     R1,R1,R0
   \   0000004E   0A48               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000050   0160               STR      R1,[R0, #+0]
   1417          
   1418            if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET)
   \   00000052   0948               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   0002               LSLS     R0,R0,#+8
   \   00000058   0AD5               BPL      ??SetCKSYS_OSC4M_6
   1419            {
   1420              if(PLL_State == MRCC_PLL_Disabled)
   \   0000005A   0948               LDR      R0,??SetCKSYS_OSC4M_0+0x8  ;; 0xfeffffff
   \   0000005C   8442               CMP      R4,R0
   \   0000005E   05D1               BNE      ??SetCKSYS_OSC4M_7
   1421              {
   1422                /* Disable PLL */
   1423                MRCC->CLKCTL &= MRCC_PLLEN_Reset_Mask;
   \   00000060   0548               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   00000062   0068               LDR      R0,[R0, #+0]
   \   00000064   0649               LDR      R1,??SetCKSYS_OSC4M_0+0x8  ;; 0xfeffffff
   \   00000066   0140               ANDS     R1,R1,R0
   \   00000068   0348               LDR      R0,??SetCKSYS_OSC4M_0  ;; 0x60000020
   \   0000006A   0160               STR      R1,[R0, #+0]
   1424              }
   1425              
   1426              return SUCCESS;
   \                     ??SetCKSYS_OSC4M_7:
   \   0000006C   0120               MOVS     R0,#+1
   \   0000006E   00E0               B        ??SetCKSYS_OSC4M_3
   1427            }
   1428            else
   1429            {
   1430              return ERROR;
   \                     ??SetCKSYS_OSC4M_6:
   \   00000070   0020               MOVS     R0,#+0
   \                     ??SetCKSYS_OSC4M_3:
   \   00000072   10BC               POP      {R4}
   \   00000074   02BC               POP      {R1}
   \   00000076   0847               BX       R1               ;; return
   \                     ??SetCKSYS_OSC4M_0:
   \   00000078   20000060           DC32     0x60000020
   \   0000007C   FFFF7FFF           DC32     0xff7fffff
   \   00000080   FFFFFFFE           DC32     0xfeffffff
   1431            }  
   1432          }
   1433          
   1434          /*******************************************************************************
   1435          * Function Name  : SetCKSYS_OSC4MPLL
   1436          * Description    : Selects 4MHz main oscillator (OSC4M) followed by PLL as
   1437          *                  CK_SYS clock source.
   1438          * Input          : PLL_Mul: specifies the PLL factor.
   1439          * Output         : None
   1440          * Return         : An ErrorStatus enumuration value:
   1441          *                         - SUCCESS: Clock configuration succeeded
   1442          *                         - ERROR: Clock configuration failed
   1443          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1444          static ErrorStatus SetCKSYS_OSC4MPLL(u32 PLL_Mul)
   1445          {
   \                     SetCKSYS_OSC4MPLL:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1446            /* Check if 4MHz main oscillator clock is present */
   1447            if(((MRCC->CLKCTL & MRCC_NCKDF_Set_Mask) == RESET) && 
   1448               ((MRCC->CLKCTL & MRCC_OSC4MOFF_Set_Mask) == RESET)) 
   \   00000004   4C48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   4003               LSLS     R0,R0,#+13
   \   0000000A   00D5               BPL      .+4
   \   0000000C   90E0               B        ??SetCKSYS_OSC4MPLL_1
   \   0000000E   4A48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   8003               LSLS     R0,R0,#+14
   \   00000014   00D5               BPL      .+4
   \   00000016   8BE0               B        ??SetCKSYS_OSC4MPLL_1
   1449            {    
   1450              if(((MRCC->CLKCTL & MRCC_PLLEN_Set_Mask) != RESET) &&
   1451                 ((MRCC->CLKCTL & MRCC_MX_Set_Mask) == PLL_Mul))
   \   00000018   4748               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   C001               LSLS     R0,R0,#+7
   \   0000001E   17D5               BPL      ??SetCKSYS_OSC4MPLL_2
   \   00000020   4548               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   C021               MOVS     R1,#+192
   \   00000026   4905               LSLS     R1,R1,#+21       ;; #+402653184
   \   00000028   0140               ANDS     R1,R1,R0
   \   0000002A   A142               CMP      R1,R4
   \   0000002C   10D1               BNE      ??SetCKSYS_OSC4MPLL_2
   1452              {
   1453                /* Select CK_PLL1 as CK_SYS clock source */
   1454                MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   0000002E   4248               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   4249               LDR      R1,??SetCKSYS_OSC4MPLL_0+0x4  ;; 0xff7fffff
   \   00000034   0140               ANDS     R1,R1,R0
   \   00000036   4048               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000038   0160               STR      R1,[R0, #+0]
   1455          
   1456                if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) == RESET)
   \   0000003A   3F48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   8021               MOVS     R1,#+128
   \   00000040   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000042   0140               ANDS     R1,R1,R0
   \   00000044   481E               SUBS     R0,R1,#+1
   \   00000046   8041               SBCS     R0,R0,R0
   \   00000048   C00F               LSRS     R0,R0,#+31
   \   0000004A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000004C   000E               LSRS     R0,R0,#+24
   1457                {
   1458                  return SUCCESS;
   \   0000004E   70E0               B        ??SetCKSYS_OSC4MPLL_3
   1459                }
   1460                else
   1461                {
   1462                  return ERROR;
   1463                }
   1464              }
   1465              else
   1466              {
   1467                /* If CK_RTC is selected as CK_OSC clock source */
   1468                if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \                     ??SetCKSYS_OSC4MPLL_2:
   \   00000050   3948               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000052   0068               LDR      R0,[R0, #+0]
   \   00000054   8002               LSLS     R0,R0,#+10
   \   00000056   11D5               BPL      ??SetCKSYS_OSC4MPLL_4
   1469                {
   1470                  if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET)
   \   00000058   3748               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000005A   0068               LDR      R0,[R0, #+0]
   \   0000005C   0002               LSLS     R0,R0,#+8
   \   0000005E   05D5               BPL      ??SetCKSYS_OSC4MPLL_5
   1471                  {
   1472                    /* Clear CKSEL bit */
   1473                    MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   00000060   3548               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000062   0068               LDR      R0,[R0, #+0]
   \   00000064   3549               LDR      R1,??SetCKSYS_OSC4MPLL_0+0x4  ;; 0xff7fffff
   \   00000066   0140               ANDS     R1,R1,R0
   \   00000068   3348               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000006A   0160               STR      R1,[R0, #+0]
   1474                  }
   1475          
   1476                  /* Clear CKOSCSEL bit ------------------------------------------------*/
   1477                  /* Execute CKOSCSEL bit writing sequence */
   1478                  WriteCKOSCSELBit();
   \                     ??SetCKSYS_OSC4MPLL_5:
   \   0000006C   ........           BL       WriteCKOSCSELBit
   1479                
   1480                  /* Check if CKOSCSEL is set to 0 */
   1481                  if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) != RESET)
   \   00000070   3148               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   8002               LSLS     R0,R0,#+10
   \   00000076   01D5               BPL      ??SetCKSYS_OSC4MPLL_4
   1482                  {
   1483                    return ERROR;
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   5AE0               B        ??SetCKSYS_OSC4MPLL_3
   1484                  }
   1485                }
   1486          
   1487                /* Select CK_OSC as CK_SYS clock source */
   1488                MRCC->CLKCTL |= MRCC_CKSEL_Set_Mask;
   \                     ??SetCKSYS_OSC4MPLL_4:
   \   0000007C   2E48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000007E   0068               LDR      R0,[R0, #+0]
   \   00000080   8021               MOVS     R1,#+128
   \   00000082   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000084   0143               ORRS     R1,R1,R0
   \   00000086   2C48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000088   0160               STR      R1,[R0, #+0]
   1489          
   1490                /* Disable PLL */
   1491                MRCC->CLKCTL &= MRCC_PLLEN_Reset_Mask;
   \   0000008A   2B48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000008C   0068               LDR      R0,[R0, #+0]
   \   0000008E   2C49               LDR      R1,??SetCKSYS_OSC4MPLL_0+0x8  ;; 0xfeffffff
   \   00000090   0140               ANDS     R1,R1,R0
   \   00000092   2948               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000094   0160               STR      R1,[R0, #+0]
   1492          
   1493                /* Configure PLL factor */
   1494                if(PLL_Mul == MRCC_PLL_Mul_16)
   \   00000096   002C               CMP      R4,#+0
   \   00000098   06D1               BNE      ??SetCKSYS_OSC4MPLL_6
   1495                {
   1496                  MRCC->CLKCTL &= MRCC_MX_Reset_Mask;
   \   0000009A   2748               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000009C   0068               LDR      R0,[R0, #+0]
   \   0000009E   2949               LDR      R1,??SetCKSYS_OSC4MPLL_0+0xC  ;; 0xe7ffffff
   \   000000A0   0140               ANDS     R1,R1,R0
   \   000000A2   2548               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000A4   0160               STR      R1,[R0, #+0]
   \   000000A6   16E0               B        ??SetCKSYS_OSC4MPLL_7
   1497                }
   1498                else if((PLL_Mul == MRCC_PLL_Mul_15) || (PLL_Mul == MRCC_PLL_Mul_14) ||
   1499                      (PLL_Mul == MRCC_PLL_Mul_12))
   \                     ??SetCKSYS_OSC4MPLL_6:
   \   000000A8   8020               MOVS     R0,#+128
   \   000000AA   0005               LSLS     R0,R0,#+20       ;; #+134217728
   \   000000AC   8442               CMP      R4,R0
   \   000000AE   07D0               BEQ      ??SetCKSYS_OSC4MPLL_8
   \   000000B0   8020               MOVS     R0,#+128
   \   000000B2   4005               LSLS     R0,R0,#+21       ;; #+268435456
   \   000000B4   8442               CMP      R4,R0
   \   000000B6   03D0               BEQ      ??SetCKSYS_OSC4MPLL_8
   \   000000B8   C020               MOVS     R0,#+192
   \   000000BA   4005               LSLS     R0,R0,#+21       ;; #+402653184
   \   000000BC   8442               CMP      R4,R0
   \   000000BE   0AD1               BNE      ??SetCKSYS_OSC4MPLL_7
   1500                {
   1501                  /* Clear MX[1:0] bits */
   1502                  MRCC->CLKCTL &= MRCC_MX_Reset_Mask;
   \                     ??SetCKSYS_OSC4MPLL_8:
   \   000000C0   1D48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000C2   0068               LDR      R0,[R0, #+0]
   \   000000C4   1F49               LDR      R1,??SetCKSYS_OSC4MPLL_0+0xC  ;; 0xe7ffffff
   \   000000C6   0140               ANDS     R1,R1,R0
   \   000000C8   1B48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000CA   0160               STR      R1,[R0, #+0]
   1503                  /* Set MX[1:0] bits according to PLL_Mul value */
   1504                  MRCC->CLKCTL |= PLL_Mul;
   \   000000CC   1A48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000CE   0068               LDR      R0,[R0, #+0]
   \   000000D0   2043               ORRS     R0,R0,R4
   \   000000D2   1949               LDR      R1,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000D4   0860               STR      R0,[R1, #+0]
   1505                }
   1506                 
   1507                if(Main_Oscillator == 4000000)
   1508                {/* 4 MHz external Quartz oscillator used as main oscillator */
   1509                  /* Disable Oscillator Divider by 2 */
   1510                  MRCC->CLKCTL &= MRCC_XTDIV2_Reset_Mask;
   1511                }
   1512                else if(Main_Oscillator == 8000000)
   1513                {/* 8 MHz external Quartz oscillator used as main oscillator */
   1514                  /* Enable Oscillator Divider by 2 */
   1515                  MRCC->CLKCTL |= MRCC_XTDIV2_Set_Mask;
   \                     ??SetCKSYS_OSC4MPLL_7:
   \   000000D6   1848               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000D8   0068               LDR      R0,[R0, #+0]
   \   000000DA   8021               MOVS     R1,#+128
   \   000000DC   0902               LSLS     R1,R1,#+8        ;; #+32768
   \   000000DE   0143               ORRS     R1,R1,R0
   \   000000E0   1548               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000E2   0160               STR      R1,[R0, #+0]
   1516                }
   1517          
   1518                /* Enable PLL */
   1519                MRCC->CLKCTL |= MRCC_PLLEN_Set_Mask;
   \   000000E4   1448               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000E6   0068               LDR      R0,[R0, #+0]
   \   000000E8   8021               MOVS     R1,#+128
   \   000000EA   4904               LSLS     R1,R1,#+17       ;; #+16777216
   \   000000EC   0143               ORRS     R1,R1,R0
   \   000000EE   1248               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000F0   0160               STR      R1,[R0, #+0]
   1520             
   1521                /* Wait until the PLL is locked */
   1522                while((MRCC->CLKCTL & MRCC_LOCK_Mask) == RESET)
   \                     ??SetCKSYS_OSC4MPLL_9:
   \   000000F2   1148               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000F4   0068               LDR      R0,[R0, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   09D4               BMI      ??SetCKSYS_OSC4MPLL_10
   1523                {
   1524                  /* If OSC4M clock disapear or the PLL is disabled, exit */
   1525                  if(((MRCC->CLKCTL & MRCC_NCKDF_Set_Mask) != RESET) ||
   1526                     ((MRCC->CLKCTL & MRCC_PLLEN_Set_Mask) == RESET))       
   \   000000FA   0F48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   000000FC   0068               LDR      R0,[R0, #+0]
   \   000000FE   4003               LSLS     R0,R0,#+13
   \   00000100   03D4               BMI      ??SetCKSYS_OSC4MPLL_11
   \   00000102   0D48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000104   0068               LDR      R0,[R0, #+0]
   \   00000106   C001               LSLS     R0,R0,#+7
   \   00000108   F3D4               BMI      ??SetCKSYS_OSC4MPLL_9
   1527                  {
   1528                    return ERROR;
   \                     ??SetCKSYS_OSC4MPLL_11:
   \   0000010A   0020               MOVS     R0,#+0
   \   0000010C   11E0               B        ??SetCKSYS_OSC4MPLL_3
   1529                  }
   1530                }
   1531          
   1532                /* Select CK_PLL1 as CK_SYS clock source */
   1533                MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \                     ??SetCKSYS_OSC4MPLL_10:
   \   0000010E   0A48               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000110   0068               LDR      R0,[R0, #+0]
   \   00000112   0A49               LDR      R1,??SetCKSYS_OSC4MPLL_0+0x4  ;; 0xff7fffff
   \   00000114   0140               ANDS     R1,R1,R0
   \   00000116   0848               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   00000118   0160               STR      R1,[R0, #+0]
   1534          
   1535                if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) == RESET)
   \   0000011A   0748               LDR      R0,??SetCKSYS_OSC4MPLL_0  ;; 0x60000020
   \   0000011C   0068               LDR      R0,[R0, #+0]
   \   0000011E   8021               MOVS     R1,#+128
   \   00000120   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000122   0140               ANDS     R1,R1,R0
   \   00000124   481E               SUBS     R0,R1,#+1
   \   00000126   8041               SBCS     R0,R0,R0
   \   00000128   C00F               LSRS     R0,R0,#+31
   \   0000012A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000012C   000E               LSRS     R0,R0,#+24
   1536                {
   1537                  return SUCCESS;
   \   0000012E   00E0               B        ??SetCKSYS_OSC4MPLL_3
   1538                }
   1539                else
   1540                {
   1541                  return ERROR;
   1542                }
   1543              }
   1544            }
   1545            else 
   1546            {
   1547              /* OSC4M disabled or OSC4M clock is not present*/
   1548              return ERROR;
   \                     ??SetCKSYS_OSC4MPLL_1:
   \   00000130   0020               MOVS     R0,#+0
   \                     ??SetCKSYS_OSC4MPLL_3:
   \   00000132   10BC               POP      {R4}
   \   00000134   02BC               POP      {R1}
   \   00000136   0847               BX       R1               ;; return
   \                     ??SetCKSYS_OSC4MPLL_0:
   \   00000138   20000060           DC32     0x60000020
   \   0000013C   FFFF7FFF           DC32     0xff7fffff
   \   00000140   FFFFFFFE           DC32     0xfeffffff
   \   00000144   FFFFFFE7           DC32     0xe7ffffff
   1549            }
   1550          }
   1551          
   1552          /*******************************************************************************
   1553          * Function Name  : SetCKSYS_RTC
   1554          * Description    : Selects RTC clock (CK_RTC) as CK_SYS clock source.
   1555          * Input          : PLL_State: specifies the PLL state.
   1556          * Output         : None
   1557          * Return         : An ErrorStatus enumuration value:
   1558          *                         - SUCCESS: Clock configuration succeeded
   1559          *                         - ERROR: Clock configuration failed
   1560          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1561          static ErrorStatus SetCKSYS_RTC(u32 PLL_State)
   1562          {
   \                     SetCKSYS_RTC:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1563            /* Check if CK_RTC clock is enabled and ready to use */
   1564            if(((MRCC->PWRCTRL & MRCC_CKRTCSEL_Set_Mask) != RESET)||
   1565               ((MRCC->CLKCTL & MRCC_CKRTCOK_Mask) == RESET))
   \   00000004   1C48               LDR      R0,??SetCKSYS_RTC_0  ;; 0x60000028
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   C021               MOVS     R1,#+192
   \   0000000A   8904               LSLS     R1,R1,#+18       ;; #+50331648
   \   0000000C   0140               ANDS     R1,R1,R0
   \   0000000E   0029               CMP      R1,#+0
   \   00000010   03D1               BNE      ??SetCKSYS_RTC_1
   \   00000012   1A48               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   0001               LSLS     R0,R0,#+4
   \   00000018   29D4               BMI      ??SetCKSYS_RTC_2
   1566            {
   1567          /* Configure CK_RTC as Ck_SYS clock source -----------------------------------*/
   1568              if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) == RESET)
   \                     ??SetCKSYS_RTC_1:
   \   0000001A   1848               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   8002               LSLS     R0,R0,#+10
   \   00000020   0DD4               BMI      ??SetCKSYS_RTC_3
   1569              { 
   1570                /* Select CK_PLL1 as CK_SYS clock source */
   1571                MRCC->CLKCTL &= MRCC_CKSEL_Reset_Mask;
   \   00000022   1648               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   1649               LDR      R1,??SetCKSYS_RTC_0+0x8  ;; 0xff7fffff
   \   00000028   0140               ANDS     R1,R1,R0
   \   0000002A   1448               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   0000002C   0160               STR      R1,[R0, #+0]
   1572              
   1573                /* Set CKOSCSEL bit ----------------------------------------------------*/
   1574                /* Execute CKOSCSEL bit writing sequence */
   1575                WriteCKOSCSELBit();
   \   0000002E   ........           BL       WriteCKOSCSELBit
   1576                
   1577                /* Check if CKOSCSEL is set to 1 */
   1578                if((MRCC->CLKCTL & MRCC_CKOSCSEL_Set_Mask) == RESET)
   \   00000032   1248               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   8002               LSLS     R0,R0,#+10
   \   00000038   01D4               BMI      ??SetCKSYS_RTC_3
   1579                {
   1580                   return ERROR;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   18E0               B        ??SetCKSYS_RTC_4
   1581                }
   1582              }
   1583              
   1584              /* Select CK_OSC as CK_SYS clock source */
   1585              MRCC->CLKCTL |= MRCC_CKSEL_Set_Mask;          
   \                     ??SetCKSYS_RTC_3:
   \   0000003E   0F48               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   8021               MOVS     R1,#+128
   \   00000044   0904               LSLS     R1,R1,#+16       ;; #+8388608
   \   00000046   0143               ORRS     R1,R1,R0
   \   00000048   0C48               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   0000004A   0160               STR      R1,[R0, #+0]
   1586              
   1587              if((MRCC->CLKCTL & MRCC_CKSEL_Set_Mask) != RESET)
   \   0000004C   0B48               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   0000004E   0068               LDR      R0,[R0, #+0]
   \   00000050   0002               LSLS     R0,R0,#+8
   \   00000052   0AD5               BPL      ??SetCKSYS_RTC_5
   1588              {
   1589                if(PLL_State == MRCC_PLL_Disabled)
   \   00000054   0B48               LDR      R0,??SetCKSYS_RTC_0+0xC  ;; 0xfeffffff
   \   00000056   8442               CMP      R4,R0
   \   00000058   05D1               BNE      ??SetCKSYS_RTC_6
   1590                {
   1591                  /* Disable PLL */
   1592                  MRCC->CLKCTL &= MRCC_PLLEN_Reset_Mask;
   \   0000005A   0848               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   0000005C   0068               LDR      R0,[R0, #+0]
   \   0000005E   0949               LDR      R1,??SetCKSYS_RTC_0+0xC  ;; 0xfeffffff
   \   00000060   0140               ANDS     R1,R1,R0
   \   00000062   0648               LDR      R0,??SetCKSYS_RTC_0+0x4  ;; 0x60000020
   \   00000064   0160               STR      R1,[R0, #+0]
   1593                }
   1594              
   1595                return SUCCESS;
   \                     ??SetCKSYS_RTC_6:
   \   00000066   0120               MOVS     R0,#+1
   \   00000068   02E0               B        ??SetCKSYS_RTC_4
   1596              }
   1597              else
   1598              {
   1599                return ERROR;
   \                     ??SetCKSYS_RTC_5:
   \   0000006A   0020               MOVS     R0,#+0
   \   0000006C   00E0               B        ??SetCKSYS_RTC_4
   1600              }    
   1601            }
   1602            else
   1603            {      
   1604              /* CK_RTC disabled */
   1605              return ERROR;
   \                     ??SetCKSYS_RTC_2:
   \   0000006E   0020               MOVS     R0,#+0
   \                     ??SetCKSYS_RTC_4:
   \   00000070   10BC               POP      {R4}
   \   00000072   02BC               POP      {R1}
   \   00000074   0847               BX       R1               ;; return
   \   00000076   C046               Nop      
   \                     ??SetCKSYS_RTC_0:
   \   00000078   28000060           DC32     0x60000028
   \   0000007C   20000060           DC32     0x60000020
   \   00000080   FFFF7FFF           DC32     0xff7fffff
   \   00000084   FFFFFFFE           DC32     0xfeffffff
   1606            }  
   1607          }
   1608          
   1609          /*******************************************************************************
   1610          * Function Name  : WriteLPBit
   1611          * Description    : Executes the Low Power bit writing sequence.
   1612          * Input          : None
   1613          * Output         : None
   1614          * Return         : None
   1615          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1616          static void WriteLPBit(void)
   1617          {
   \                     WriteLPBit:
   \   00000000   11B4               PUSH     {R0,R4}
   1618            u32 Tmp = 0, Tmp1 = 0, Tmp2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   1800               MOVS     R0,R3
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   1900               MOVS     R1,R3
   \   0000000A   0023               MOVS     R3,#+0
   \   0000000C   1A00               MOVS     R2,R3
   1619          
   1620            /* Clear LP_DONE flag */
   1621            MRCC->PWRCTRL &= MRCC_LPDONE_Reset_Mask;
   \   0000000E   0E4B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   00000010   1B68               LDR      R3,[R3, #+0]
   \   00000012   8024               MOVS     R4,#+128
   \   00000014   A343               BICS     R3,R3,R4
   \   00000016   0C4C               LDR      R4,??WriteLPBit_0  ;; 0x60000028
   \   00000018   2360               STR      R3,[R4, #+0]
   1622          
   1623            Tmp = MRCC->PWRCTRL;
   \   0000001A   0B4B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   0000001C   1B68               LDR      R3,[R3, #+0]
   \   0000001E   1800               MOVS     R0,R3
   1624            Tmp1 = Tmp | MRCC_LP_Set_Mask;
   \   00000020   0123               MOVS     R3,#+1
   \   00000022   0343               ORRS     R3,R3,R0
   \   00000024   1900               MOVS     R1,R3
   1625            Tmp2 = Tmp & MRCC_LP_Reset_Mask;
   \   00000026   4308               LSRS     R3,R0,#+1
   \   00000028   5B00               LSLS     R3,R3,#+1
   \   0000002A   1A00               MOVS     R2,R3
   1626          
   1627            /* Set LP bit */
   1628            MRCC->PWRCTRL = Tmp1;
   \   0000002C   064B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   0000002E   1960               STR      R1,[R3, #+0]
   1629          
   1630            /* Set LP bit */
   1631            MRCC->PWRCTRL = Tmp1;
   \   00000030   054B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   00000032   1960               STR      R1,[R3, #+0]
   1632          
   1633            /* Reset LP bit */
   1634            MRCC->PWRCTRL = Tmp2;
   \   00000034   044B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   00000036   1A60               STR      R2,[R3, #+0]
   1635          
   1636            /* Set LP bit */
   1637            MRCC->PWRCTRL = Tmp1;
   \   00000038   034B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   0000003A   1960               STR      R1,[R3, #+0]
   1638          
   1639            /* Read LP bit*/
   1640            Tmp = MRCC->PWRCTRL;  
   \   0000003C   024B               LDR      R3,??WriteLPBit_0  ;; 0x60000028
   \   0000003E   1B68               LDR      R3,[R3, #+0]
   \   00000040   1800               MOVS     R0,R3
   1641          }
   \   00000042   18BC               POP      {R3,R4}
   \   00000044   7047               BX       LR               ;; return
   \   00000046   C046               Nop      
   \                     ??WriteLPBit_0:
   \   00000048   28000060           DC32     0x60000028
   1642          
   1643          /*******************************************************************************
   1644          * Function Name  : WriteCKOSCSELBit
   1645          * Description    : Executes the CKOSCSEL bit writing sequence.
   1646          * Input          : None
   1647          * Output         : None
   1648          * Return         : None
   1649          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1650          static void WriteCKOSCSELBit(void)
   1651          {
   1652            u32 Tmp = 0, Tmp1 = 0, Tmp2 = 0;
   \                     WriteCKOSCSELBit:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   1800               MOVS     R0,R3
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   1900               MOVS     R1,R3
   \   00000008   0023               MOVS     R3,#+0
   \   0000000A   1A00               MOVS     R2,R3
   1653          
   1654            Tmp = MRCC->CLKCTL;
   \   0000000C   0A4B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   0000000E   1B68               LDR      R3,[R3, #+0]
   \   00000010   1800               MOVS     R0,R3
   1655            Tmp1 = Tmp | MRCC_CKOSCSEL_Set_Mask;
   \   00000012   8023               MOVS     R3,#+128
   \   00000014   9B03               LSLS     R3,R3,#+14       ;; #+2097152
   \   00000016   0343               ORRS     R3,R3,R0
   \   00000018   1900               MOVS     R1,R3
   1656            Tmp2 = Tmp & MRCC_CKOSCSEL_Reset_Mask;
   \   0000001A   084B               LDR      R3,??WriteCKOSCSELBit_0+0x4  ;; 0xffdfffff
   \   0000001C   0340               ANDS     R3,R3,R0
   \   0000001E   1A00               MOVS     R2,R3
   1657          
   1658            /* Set CKOSCSEL bit */
   1659            MRCC->CLKCTL = Tmp1;
   \   00000020   054B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   00000022   1960               STR      R1,[R3, #+0]
   1660          
   1661            /* Set CKOSCSEL bit */
   1662            MRCC->CLKCTL = Tmp1;
   \   00000024   044B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   00000026   1960               STR      R1,[R3, #+0]
   1663          
   1664            /* Reset CKOSCSEL bit */
   1665            MRCC->CLKCTL = Tmp2;
   \   00000028   034B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   0000002A   1A60               STR      R2,[R3, #+0]
   1666          
   1667            /* Set CKOSCSEL bit */
   1668            MRCC->CLKCTL = Tmp1;
   \   0000002C   024B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   0000002E   1960               STR      R1,[R3, #+0]
   1669            
   1670            /* Read CKOSCSEL bit */
   1671            Tmp = MRCC->CLKCTL;
   \   00000030   014B               LDR      R3,??WriteCKOSCSELBit_0  ;; 0x60000020
   \   00000032   1B68               LDR      R3,[R3, #+0]
   \   00000034   1800               MOVS     R0,R3
   1672          }
   \   00000036   7047               BX       LR               ;; return
   \                     ??WriteCKOSCSELBit_0:
   \   00000038   20000060           DC32     0x60000020
   \   0000003C   FFFFDFFF           DC32     0xffdfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   FFFF7FFF           DC32     0xff7fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   FFFFFCFF           DC32     0xfffcffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   30000060           DC32     0x60000030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   34000060           DC32     0x60000034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   FFFFFFFE           DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   FFFFFFFC           DC32     0xfcffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   28000060           DC32     0x60000028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   20000060           DC32     0x60000020
   1673          /******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                     .cstack
     --------                     -------
     MRCC_CKRTCConfig                  8
     MRCC_CKSYSConfig                 16
     MRCC_CKTIMConfig                  0
     MRCC_CKUSBConfig                  8
     MRCC_ClearFlag                    8
     MRCC_ClearITPendingBit            0
     MRCC_DeInit                       8
     MRCC_EnterSTANDBYMode             8
     MRCC_EnterSTOPMode                8
     MRCC_EnterWFIMode                 8
     MRCC_GenerateSWReset              8
     MRCC_GetCKSYSCounter              0
     MRCC_GetClocksStatus             16
     MRCC_GetFlagStatus                8
     MRCC_GetITStatus                  0
     MRCC_HCLKConfig                   0
     MRCC_IOVoltageRangeConfig         8
     MRCC_ITConfig                     8
     MRCC_LPMC_DBGConfig               8
     MRCC_LPOSCConfig                  8
     MRCC_MCOConfig                    8
     MRCC_OSC32KConfig                 8
     MRCC_OSC4MConfig                  8
     MRCC_PCLKConfig                   8
     MRCC_PeripheralClockConfig        8
     MRCC_PeripheralSWResetConfig      8
     MRCC_RTCMConfig                   8
     MRCC_ReadBackupRegister           8
     MRCC_SetBuilderCounter            0
     MRCC_WaitForOSC4MStartUp          8
     MRCC_WriteBackupRegister          8
     MRCC_XTDIV2Config                 8
     SetCKSYS_FREEOSC                  8
     SetCKSYS_OSC4M                    8
     SetCKSYS_OSC4MPLL                 8
     SetCKSYS_RTC                      8
     WriteCKOSCSELBit                  0
     WriteLPBit                        8


   Section sizes:

     Function/Label               Bytes
     --------------               -----
     MRCC_DeInit                   200
     MRCC_XTDIV2Config              48
     MRCC_CKSYSConfig              142
     MRCC_HCLKConfig                22
     MRCC_CKTIMConfig               22
     MRCC_PCLKConfig                38
     MRCC_CKRTCConfig               52
     MRCC_CKUSBConfig              104
     MRCC_ITConfig                  44
     MRCC_PeripheralClockConfig     44
     MRCC_PeripheralSWResetConfig   44
     MRCC_GetClocksStatus          436
     MRCC_LPMC_DBGConfig            44
     MRCC_EnterWFIMode              72
     MRCC_EnterSTOPMode             60
     MRCC_EnterSTANDBYMode          40
     MRCC_GenerateSWReset           40
     MRCC_WriteBackupRegister       36
     MRCC_ReadBackupRegister        36
     MRCC_IOVoltageRangeConfig      52
     MRCC_MCOConfig                 64
     MRCC_OSC4MConfig              208
     MRCC_OSC32KConfig             120
     MRCC_LPOSCConfig              100
     MRCC_RTCMConfig                52
     MRCC_SetBuilderCounter         12
     MRCC_GetCKSYSCounter           16
     MRCC_GetFlagStatus            112
     MRCC_ClearFlag                112
     MRCC_GetITStatus               32
     MRCC_ClearITPendingBit         20
     MRCC_WaitForOSC4MStartUp       62
     SetCKSYS_FREEOSC              124
     SetCKSYS_OSC4M                132
     SetCKSYS_OSC4MPLL             328
     SetCKSYS_RTC                  136
     WriteLPBit                     76
     WriteCKOSCSELBit               64
     ??DataTable19                   4
     ??DataTable22                   4
     ??DataTable26                   4
     ??DataTable27                   4
     ??DataTable36                   4
     ??DataTable48                   4
     ??DataTable49                   4
     ??DataTable58                   4

 
 3 378 bytes in section .text
 
 3 378 bytes of CODE memory

Errors: none
Warnings: none
