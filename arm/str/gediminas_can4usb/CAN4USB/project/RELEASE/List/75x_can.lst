###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:17 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\development\vscp\firmware\arm\str\cantest_str75x_iar\ #
#                    str75x_lib\src\75x_can.c                                 #
#    Command line =  D:\development\vscp\firmware\arm\str\cantest_str75x_iar\ #
#                    str75x_lib\src\75x_can.c -lC                             #
#                    D:\development\gediminas\CAN4USB\project\RELEASE\List\   #
#                    -lA D:\development\gediminas\CAN4USB\project\RELEASE\Lis #
#                    t\ -o D:\development\gediminas\CAN4USB\project\RELEASE\O #
#                    bj\ --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian little --cpu ARM7TDMI-S -e --fpu None           #
#                    --dlib_config "D:\Program\IAR Systems\Embedded           #
#                    Workbench 5.0\ARM\INC\DLib_Config_Normal.h" -I           #
#                    D:\development\gediminas\CAN4USB\project\ -I             #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\75 #
#                    x_can.lst                                                #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\75x #
#                    _can.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\development\vscp\firmware\arm\str\cantest_str75x_iar\str75x_lib\src\75x_can.c
      1          /******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
      2          * File Name          : 75x_can.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 03/10/2006
      5          * Description        : This file provides all the CAN software functions.
      6          ********************************************************************************
      7          * History:
      8          * 07/17/2006 : V1.0
      9          * 03/10/2006 : V0.1
     10          ********************************************************************************
     11          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     13          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     14          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     15          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     16          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *******************************************************************************/
     18          
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "75x_can.h"
     21          #include "75x_mrcc.h"
     22          
     23          /* Private typedef -----------------------------------------------------------*/
     24          /* Private define ------------------------------------------------------------*/
     25          /* Private macro -------------------------------------------------------------*/
     26          /*----------------------------------------------------------------------------*/
     27          /* Macro Name     : xxx_ID_MSK, xxx_ID_ARB                                    */
     28          /* Description    : Form the Mask and Arbitration registers value to filter   */
     29          /*                  a range of identifiers or a fixed identifier, for standard*/
     30          /*                  and extended IDs                                          */
     31          /*----------------------------------------------------------------------------*/
     32          #define RANGE_ID_MSK(range_start, range_end)	(~((range_end) - (range_start)))
     33          #define RANGE_ID_ARB(range_start, range_end)	((range_start) & (range_end))
     34          
     35          #define FIXED_ID_MSK(id)	RANGE_ID_MSK((id), (id))
     36          #define FIXED_ID_ARB(id)	RANGE_ID_ARB((id), (id))
     37          
     38          #define STD_RANGE_ID_MSK(range_start, range_end)	((u16)((RANGE_ID_MSK((range_start), (range_end)) & 0x7FF) << 2))
     39          #define STD_RANGE_ID_ARB(range_start, range_end)	((u16)(RANGE_ID_ARB((range_start), (range_end)) << 2))
     40          
     41          #define STD_FIXED_ID_MSK(id)	((u16)((FIXED_ID_MSK(id) & 0x7FF) << 2))
     42          #define STD_FIXED_ID_ARB(id)	((u16)(FIXED_ID_ARB(id) << 2))
     43          
     44          #define EXT_RANGE_ID_MSK_L(range_start, range_end)	((u16)(RANGE_ID_MSK((range_start), (range_end)) >> 11))
     45          #define EXT_RANGE_ID_MSK_H(range_start, range_end)	((u16)(STD_RANGE_ID_MSK((range_start), (range_end)) | ((RANGE_ID_MSK((range_start), (range_end)) >> 27) & 0x03)))
     46          #define EXT_RANGE_ID_ARB_L(range_start, range_end)	((u16)(RANGE_ID_ARB((range_start), (range_end)) >> 11))
     47          #define EXT_RANGE_ID_ARB_H(range_start, range_end)	((u16)(STD_RANGE_ID_ARB((range_start), (range_end)) | ((RANGE_ID_ARB((range_start), (range_end)) >> 27) & 0x03)))
     48          
     49          #define EXT_FIXED_ID_MSK_L(id)	((u16)(FIXED_ID_MSK(id) >> 11))
     50          #define EXT_FIXED_ID_MSK_H(id)	((u16)(STD_FIXED_ID_MSK(id) | ((FIXED_ID_MSK(id) >> 27) & 0x03)))
     51          #define EXT_FIXED_ID_ARB_L(id)	((u16)(FIXED_ID_ARB(id) >> 11))
     52          #define EXT_FIXED_ID_ARB_H(id)	((u16)(STD_FIXED_ID_ARB(id) | ((FIXED_ID_ARB(id) >> 27) & 0x03)))
     53          
     54          /* macro to format the timing register value from the timing parameters*/
     55          #define CAN_TIMING(tseg1, tseg2, sjw, brp)	((((tseg2-1) & 0x07) << 12) | (((tseg1-1) & 0x0F) << 8) | (((sjw-1) & 0x03) << 6) | ((brp-1) & 0x3F))
     56          
     57          /* Private variables ---------------------------------------------------------*/
     58          /* array of pre-defined timing parameters for standard bitrates*/

   \                                 In section .data, align 4
     59          u16 CanTimings[] = {        /* value   bitrate     NTQ  TSEG1  TSEG2  SJW  BRP Sample point  */
   \                     CanTimings:
   \   00000000   C43A581B491B       DC16 15044, 7000, 6985, 15044, 15043, 9091, 7168, 7168, 8960
   \              C43AC33A8323
   \              001C001C0023
   \   00000012   0000               DC8 0, 0
     60            CAN_TIMING(11, 4, 4, 5),  /*          10 kbit/s  24   16     7      4    32  70.8%         */
     61            CAN_TIMING(12, 2, 2, 25), /*          20 kbit/s  16   12     2      1    25  87.5%         */
     62            CAN_TIMING(12, 2, 2, 10), /*          50 kbit/s  16   12     2      1    10  87.5%         */
     63            CAN_TIMING(11, 4, 4, 5),  /* 0x3AC4  100 kbit/s  16   11     4      4    5   75%           */
     64            CAN_TIMING(11, 4, 4, 4),  /* 0x3AC3  125 kbit/s  16   11     4      4    4   75%           */
     65            CAN_TIMING( 4, 3, 3, 4),  /* 0x2383  250 kbit/s   8    4     3      3    4   62.5%         */
     66            CAN_TIMING(13, 2, 1, 1),  /* 0x1C00  500 kbit/s  16   13     2      1    1   87.5%         */
     67            CAN_TIMING(13, 2, 1, 1),  /*         800 kbit/s  10    7     2      1    1   80%           */
     68            CAN_TIMING( 4, 3, 1, 1),  /* 0x2300  1 Mbit/s     8    4     3      1    1   62.5%         */
     69          };
     70          
     71          /* Private function prototypes -----------------------------------------------*/
     72          static u32 GetFreeIF(void);
     73          /* Private functions ---------------------------------------------------------*/
     74          
     75          /*******************************************************************************
     76          * Function Name  : CAN_DeInit                                                
     77          * Description    : Deinitializes the CAN peripheral registers to their default     
     78          *                  reset values.                                     
     79          * Input          : None                                                      
     80          * Output         : None                                                      
     81          * Return         : None                                                      
     82          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     83          void CAN_DeInit (void)
     84          {
   \                     CAN_DeInit:
   \   00000000   01B5               PUSH     {R0,LR}
     85            /* Reset the CAN registers values*/
     86            MRCC_PeripheralSWResetConfig(MRCC_Peripheral_CAN,ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   8020               MOVS     R0,#+128
   \   00000006   4002               LSLS     R0,R0,#+9        ;; #+65536
   \   00000008   ........           BL       MRCC_PeripheralSWResetConfig
     87            MRCC_PeripheralSWResetConfig(MRCC_Peripheral_CAN,DISABLE);
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   8020               MOVS     R0,#+128
   \   00000010   4002               LSLS     R0,R0,#+9        ;; #+65536
   \   00000012   ........           BL       MRCC_PeripheralSWResetConfig
     88          }
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
     89          
     90          /*******************************************************************************
     91          * Function Name  : CAN_Init                                                  
     92          * Description    : Initializes the CAN peripheral according to the specified 
     93          *                  parameters in the CAN_InitStruct.                                            
     94          * Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
     95          *                  contains the configuration information for the CAN peripheral. 
     96          * Output         : None                                                      
     97          * Return         : None                                                      
     98          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     99          void CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
    100          {
   \                     CAN_Init:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    101            CAN_EnterInitMode(CAN_CR_CCE | CAN_InitStruct->CAN_ConfigParameters);
   \   00000004   2178               LDRB     R1,[R4, #+0]
   \   00000006   4020               MOVS     R0,#+64
   \   00000008   0843               ORRS     R0,R0,R1
   \   0000000A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000C   000E               LSRS     R0,R0,#+24
   \   0000000E   ........           BL       CAN_EnterInitMode
    102            CAN_SetBitrate(CAN_InitStruct->CAN_Bitrate);
   \   00000012   6068               LDR      R0,[R4, #+4]
   \   00000014   ........           BL       CAN_SetBitrate
    103            CAN_LeaveInitMode();
   \   00000018   ........           BL       CAN_LeaveInitMode
    104            CAN_LeaveTestMode();
   \   0000001C   ........           BL       CAN_LeaveTestMode
    105          }
   \   00000020   10BC               POP      {R4}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
    106          
    107          /*******************************************************************************
    108          * Function Name  : CAN_StructInit		                        
    109          * Description    : Fills each CAN_InitStruct member with its reset value.	      
    110          * Input          : CAN_InitStruct : pointer to a CAN_InitTypeDef structure which       
    111          *                  will be initialized. 
    112          * Output         : None                  
    113          * Return         : None.						      
    114          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    115          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    116          {
    117          /* Reset CAN init structure parameters values */
    118            CAN_InitStruct->CAN_ConfigParameters = 0x0;
   \                     CAN_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0170               STRB     R1,[R0, #+0]
    119            CAN_InitStruct->CAN_Bitrate = 0x2301;
   \   00000004   0149               LDR      R1,??CAN_StructInit_0  ;; 0x2301
   \   00000006   4160               STR      R1,[R0, #+4]
    120          }
   \   00000008   7047               BX       LR               ;; return
   \   0000000A   C046               Nop      
   \                     ??CAN_StructInit_0:
   \   0000000C   01230000           DC32     0x2301
    121          
    122          /*******************************************************************************
    123          * Function Name  : CAN_SetBitrate                                            
    124          * Description    : Setups a standard CAN bitrate.                              
    125          * Input          : bitrate: specifies the bit rate.                       
    126          * Output         : None                                                      
    127          * Return         : None                                                                         
    128          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    129          void CAN_SetBitrate(u32 bitrate)
    130          {
    131            CAN->BTR = CanTimings[bitrate];     /* write the predefined timing value */
   \                     CAN_SetBitrate:
   \   00000000   0221               MOVS     R1,#+2
   \   00000002   4143               MULS     R1,R0,R1
   \   00000004   034A               LDR      R2,??CAN_SetBitrate_0  ;; CanTimings
   \   00000006   515A               LDRH     R1,[R2, R1]
   \   00000008   ....               LDR      R2,??DataTable2  ;; 0xffffc40c
   \   0000000A   1180               STRH     R1,[R2, #+0]
    132            CAN->BRPR = 0; 		       /* clear the Extended Baud Rate Prescaler */
   \   0000000C   ....               LDR      R1,??DataTable3  ;; 0xffffc418
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   0A80               STRH     R2,[R1, #+0]
    133          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??CAN_SetBitrate_0:
   \   00000014   ........           DC32     CanTimings
    134          
    135          /*******************************************************************************
    136          * Function Name  : CAN_SetTiming                                             
    137          * Description    : Setups the CAN timing with specific parameters             
    138          * Input          : - tseg1: specifies Time Segment before the sample point.
    139          *                    This parameter must be a number between 1 and 16.       
    140          *                  - tseg2: Time Segment after the sample point. This parameter 
    141          *                    must be a number between 1 and 8.        
    142          *                  - sjw: Synchronisation Jump Width. This parameter must be                 
    143          *                     a number between 1 and 4.
    144          *                  - brp: Baud Rate Prescaler. This parameter must be a number
    145          *                    between 1 and 1024.                                         
    146          * Output         : None                                                      
    147          * Return         : None                                                                       
    148          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    149          void CAN_SetTiming(u32 tseg1, u32 tseg2, u32 sjw, u32 brp)
    150          {
   \                     CAN_SetTiming:
   \   00000000   30B4               PUSH     {R4,R5}
    151            CAN->BTR = CAN_TIMING(tseg1, tseg2, sjw, brp);
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   641E               SUBS     R4,R4,#+1
   \   00000006   6407               LSLS     R4,R4,#+29       ;; ZeroExtS R4,R4,#+29,#+29
   \   00000008   640F               LSRS     R4,R4,#+29
   \   0000000A   2403               LSLS     R4,R4,#+12
   \   0000000C   0500               MOVS     R5,R0
   \   0000000E   6D1E               SUBS     R5,R5,#+1
   \   00000010   2D07               LSLS     R5,R5,#+28       ;; ZeroExtS R5,R5,#+28,#+28
   \   00000012   2D0F               LSRS     R5,R5,#+28
   \   00000014   2D02               LSLS     R5,R5,#+8
   \   00000016   2543               ORRS     R5,R5,R4
   \   00000018   1400               MOVS     R4,R2
   \   0000001A   641E               SUBS     R4,R4,#+1
   \   0000001C   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   0000001E   A40F               LSRS     R4,R4,#+30
   \   00000020   A401               LSLS     R4,R4,#+6
   \   00000022   2C43               ORRS     R4,R4,R5
   \   00000024   1D00               MOVS     R5,R3
   \   00000026   6D1E               SUBS     R5,R5,#+1
   \   00000028   AD06               LSLS     R5,R5,#+26       ;; ZeroExtS R5,R5,#+26,#+26
   \   0000002A   AD0E               LSRS     R5,R5,#+26
   \   0000002C   2543               ORRS     R5,R5,R4
   \   0000002E   ....               LDR      R4,??DataTable2  ;; 0xffffc40c
   \   00000030   2580               STRH     R5,[R4, #+0]
    152            CAN->BRPR = ((brp-1) >> 6) & 0x0F;
   \   00000032   5C1E               SUBS     R4,R3,#+1
   \   00000034   A409               LSRS     R4,R4,#+6
   \   00000036   2407               LSLS     R4,R4,#+28       ;; ZeroExtS R4,R4,#+28,#+28
   \   00000038   240F               LSRS     R4,R4,#+28
   \   0000003A   ....               LDR      R5,??DataTable3  ;; 0xffffc418
   \   0000003C   2C80               STRH     R4,[R5, #+0]
    153          }
   \   0000003E   30BC               POP      {R4,R5}
   \   00000040   7047               BX       LR               ;; return
    154          
    155          /*******************************************************************************
    156          * Function Name  : GetFreeIF                                             
    157          * Description    : Searchs the first free message interface, starting from 0.  
    158          * Input          : None                                                      
    159          * Output         : None                                                      
    160          * Return         : A free message interface number (0 or 1) if found, else 2 
    161          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    162          static u32 GetFreeIF(void)
    163          {
   \                     GetFreeIF:
   \   00000000   01B5               PUSH     {R0,LR}
    164            if ((CAN->sMsgObj[0].CRR & CAN_CRR_BUSY) == 0)
   \   00000002   ....               LDR      R0,??DataTable29  ;; 0xffffc420
   \   00000004   0088               LDRH     R0,[R0, #+0]
   \   00000006   0004               LSLS     R0,R0,#+16
   \   00000008   01D4               BMI      ??GetFreeIF_0
    165              return 0;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   06E0               B        ??GetFreeIF_1
    166            else if ((CAN->sMsgObj[1].CRR & CAN_CRR_BUSY) == 0)
   \                     ??GetFreeIF_0:
   \   0000000E   ....               LDR      R0,??DataTable5  ;; 0xffffc480
   \   00000010   0088               LDRH     R0,[R0, #+0]
   \   00000012   0004               LSLS     R0,R0,#+16
   \   00000014   01D4               BMI      ??GetFreeIF_2
    167              return 1;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   00E0               B        ??GetFreeIF_1
    168            else
    169             return 2;
   \                     ??GetFreeIF_2:
   \   0000001A   0220               MOVS     R0,#+2
   \                     ??GetFreeIF_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   02BC               POP      {R1}
   \   00000020   0847               BX       R1               ;; return
    170          }
    171          
    172          /*******************************************************************************
    173          * Function Name  : CAN_SetUnusedMsgObj                                       
    174          * Description    : Configures the message object as unused                   
    175          * Input          : msgobj: specifies the Message object number, from 0 to 31.                      
    176          * Output         : None                                                      
    177          * Return         : An ErrorStatus enumuration value:
    178          *                         - SUCCESS: Interface to treat the message
    179          *                         - ERROR: No interface found to treat the message
    180          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    181          ErrorStatus CAN_SetUnusedMsgObj(u32 msgobj)
    182          {
   \                     CAN_SetUnusedMsgObj:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    183            u32 msg_if=0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0500               MOVS     R5,R0
    184          
    185            if ((msg_if = GetFreeIF()) == 2)
   \   00000008   ........           BL       GetFreeIF
   \   0000000C   0500               MOVS     R5,R0
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   01D1               BNE      ??CAN_SetUnusedMsgObj_0
    186            {
    187              return ERROR;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   42E0               B        ??CAN_SetUnusedMsgObj_1
    188            }
    189          
    190            CAN->sMsgObj[msg_if].CMR = CAN_CMR_WRRD
    191                                     | CAN_CMR_MASK
    192                                     | CAN_CMR_ARB
    193                                     | CAN_CMR_CONTROL
    194                                     | CAN_CMR_DATAA
    195                                     | CAN_CMR_DATAB;
   \                     ??CAN_SetUnusedMsgObj_0:
   \   00000016   6020               MOVS     R0,#+96
   \   00000018   6843               MULS     R0,R5,R0
   \   0000001A   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000001C   0818               ADDS     R0,R1,R0
   \   0000001E   F321               MOVS     R1,#+243
   \   00000020   8180               STRH     R1,[R0, #+4]
    196          
    197            CAN->sMsgObj[msg_if].M1R = 0;
   \   00000022   6020               MOVS     R0,#+96
   \   00000024   6843               MULS     R0,R5,R0
   \   00000026   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000028   0818               ADDS     R0,R1,R0
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0181               STRH     R1,[R0, #+8]
    198            CAN->sMsgObj[msg_if].M2R = 0;
   \   0000002E   6020               MOVS     R0,#+96
   \   00000030   6843               MULS     R0,R5,R0
   \   00000032   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000034   0818               ADDS     R0,R1,R0
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   8181               STRH     R1,[R0, #+12]
    199          
    200            CAN->sMsgObj[msg_if].A1R = 0;
   \   0000003A   6020               MOVS     R0,#+96
   \   0000003C   6843               MULS     R0,R5,R0
   \   0000003E   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   0182               STRH     R1,[R0, #+16]
    201            CAN->sMsgObj[msg_if].A2R = 0;
   \   00000046   6020               MOVS     R0,#+96
   \   00000048   6843               MULS     R0,R5,R0
   \   0000004A   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000004C   0818               ADDS     R0,R1,R0
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   8182               STRH     R1,[R0, #+20]
    202          
    203            CAN->sMsgObj[msg_if].MCR = 0;
   \   00000052   6020               MOVS     R0,#+96
   \   00000054   6843               MULS     R0,R5,R0
   \   00000056   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000058   0818               ADDS     R0,R1,R0
   \   0000005A   0021               MOVS     R1,#+0
   \   0000005C   0183               STRH     R1,[R0, #+24]
    204          
    205            CAN->sMsgObj[msg_if].DA1R = 0;
   \   0000005E   6020               MOVS     R0,#+96
   \   00000060   6843               MULS     R0,R5,R0
   \   00000062   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000064   0818               ADDS     R0,R1,R0
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   8183               STRH     R1,[R0, #+28]
    206            CAN->sMsgObj[msg_if].DA2R = 0;
   \   0000006A   6020               MOVS     R0,#+96
   \   0000006C   6843               MULS     R0,R5,R0
   \   0000006E   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000070   0818               ADDS     R0,R1,R0
   \   00000072   0021               MOVS     R1,#+0
   \   00000074   0184               STRH     R1,[R0, #+32]
    207            CAN->sMsgObj[msg_if].DB1R = 0;
   \   00000076   6020               MOVS     R0,#+96
   \   00000078   6843               MULS     R0,R5,R0
   \   0000007A   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000007C   0818               ADDS     R0,R1,R0
   \   0000007E   0021               MOVS     R1,#+0
   \   00000080   8184               STRH     R1,[R0, #+36]
    208            CAN->sMsgObj[msg_if].DB2R = 0;
   \   00000082   6020               MOVS     R0,#+96
   \   00000084   6843               MULS     R0,R5,R0
   \   00000086   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000088   0818               ADDS     R0,R1,R0
   \   0000008A   0021               MOVS     R1,#+0
   \   0000008C   0185               STRH     R1,[R0, #+40]
    209          
    210           CAN->sMsgObj[msg_if].CRR = 1 + msgobj;
   \   0000008E   6020               MOVS     R0,#+96
   \   00000090   6843               MULS     R0,R5,R0
   \   00000092   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000094   2200               MOVS     R2,R4
   \   00000096   521C               ADDS     R2,R2,#+1
   \   00000098   0A52               STRH     R2,[R1, R0]
    211           
    212           return SUCCESS;
   \   0000009A   0120               MOVS     R0,#+1
   \                     ??CAN_SetUnusedMsgObj_1:
   \   0000009C   38BC               POP      {R3-R5}
   \   0000009E   02BC               POP      {R1}
   \   000000A0   0847               BX       R1               ;; return
    213          }
    214          
    215          /*******************************************************************************
    216          * Function Name  : CAN_SetTxMsgObj                                           
    217          * Description    : Configures the message object as TX.                        
    218          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                      
    219          *                  - idType: specifies the identifier type of the frames that
    220          *                    will be transmitted using this message object.
    221          *                    This parameter can be one of the following values:
    222          *                          - CAN_STD_ID (standard ID, 11-bit)
    223          *                          - CAN_EXT_ID (extended ID, 29-bit)                                
    224          * Output         : None                                                      
    225          * Return         : An ErrorStatus enumuration value:
    226          *                         - SUCCESS: Interface to treat the message
    227          *                         - ERROR: No interface found to treat the message
    228          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    229          ErrorStatus CAN_SetTxMsgObj(u32 msgobj, u32 idType)
    230          {
   \                     CAN_SetTxMsgObj:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    231            u32 msg_if=0;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0600               MOVS     R6,R0
    232          
    233            if ((msg_if = GetFreeIF()) == 2)
   \   0000000A   ........           BL       GetFreeIF
   \   0000000E   0600               MOVS     R6,R0
   \   00000010   0228               CMP      R0,#+2
   \   00000012   01D1               BNE      ??CAN_SetTxMsgObj_0
    234            {
    235              return ERROR;
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   56E0               B        ??CAN_SetTxMsgObj_1
    236            }
    237            
    238            CAN->sMsgObj[msg_if].CMR = CAN_CMR_WRRD
    239                                     | CAN_CMR_MASK
    240                                     | CAN_CMR_ARB
    241                                     | CAN_CMR_CONTROL
    242                                     | CAN_CMR_DATAA
    243                                     | CAN_CMR_DATAB;
   \                     ??CAN_SetTxMsgObj_0:
   \   00000018   6020               MOVS     R0,#+96
   \   0000001A   7043               MULS     R0,R6,R0
   \   0000001C   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000001E   0818               ADDS     R0,R1,R0
   \   00000020   F321               MOVS     R1,#+243
   \   00000022   8180               STRH     R1,[R0, #+4]
    244          
    245            CAN->sMsgObj[msg_if].M1R = 0;
   \   00000024   6020               MOVS     R0,#+96
   \   00000026   7043               MULS     R0,R6,R0
   \   00000028   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000002A   0818               ADDS     R0,R1,R0
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   0181               STRH     R1,[R0, #+8]
    246            CAN->sMsgObj[msg_if].A1R = 0;
   \   00000030   6020               MOVS     R0,#+96
   \   00000032   7043               MULS     R0,R6,R0
   \   00000034   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000036   0818               ADDS     R0,R1,R0
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   0182               STRH     R1,[R0, #+16]
    247          
    248            if (idType == CAN_STD_ID)
   \   0000003C   002D               CMP      R5,#+0
   \   0000003E   0ED1               BNE      ??CAN_SetTxMsgObj_2
    249            {
    250              CAN->sMsgObj[msg_if].M2R = CAN_M2R_MDIR;
   \   00000040   6020               MOVS     R0,#+96
   \   00000042   7043               MULS     R0,R6,R0
   \   00000044   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000046   0818               ADDS     R0,R1,R0
   \   00000048   8021               MOVS     R1,#+128
   \   0000004A   C901               LSLS     R1,R1,#+7        ;; #+16384
   \   0000004C   8181               STRH     R1,[R0, #+12]
    251              CAN->sMsgObj[msg_if].A2R = CAN_A2R_MSGVAL | CAN_A2R_DIR;
   \   0000004E   6020               MOVS     R0,#+96
   \   00000050   7043               MULS     R0,R6,R0
   \   00000052   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000054   0818               ADDS     R0,R1,R0
   \   00000056   A021               MOVS     R1,#+160
   \   00000058   0902               LSLS     R1,R1,#+8        ;; #+40960
   \   0000005A   8182               STRH     R1,[R0, #+20]
   \   0000005C   0DE0               B        ??CAN_SetTxMsgObj_3
    252            }
    253            else
    254            {
    255              CAN->sMsgObj[msg_if].M2R = CAN_M2R_MDIR | CAN_M2R_MXTD;
   \                     ??CAN_SetTxMsgObj_2:
   \   0000005E   6020               MOVS     R0,#+96
   \   00000060   7043               MULS     R0,R6,R0
   \   00000062   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000064   0818               ADDS     R0,R1,R0
   \   00000066   C021               MOVS     R1,#+192
   \   00000068   0902               LSLS     R1,R1,#+8        ;; #+49152
   \   0000006A   8181               STRH     R1,[R0, #+12]
    256              CAN->sMsgObj[msg_if].A2R = CAN_A2R_MSGVAL | CAN_A2R_DIR | CAN_A2R_XTD;
   \   0000006C   6020               MOVS     R0,#+96
   \   0000006E   7043               MULS     R0,R6,R0
   \   00000070   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000072   0818               ADDS     R0,R1,R0
   \   00000074   E021               MOVS     R1,#+224
   \   00000076   0902               LSLS     R1,R1,#+8        ;; #+57344
   \   00000078   8182               STRH     R1,[R0, #+20]
    257            }
    258          
    259            CAN->sMsgObj[msg_if].MCR = CAN_MCR_TXIE | CAN_MCR_EOB;
   \                     ??CAN_SetTxMsgObj_3:
   \   0000007A   6020               MOVS     R0,#+96
   \   0000007C   7043               MULS     R0,R6,R0
   \   0000007E   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   00000080   0818               ADDS     R0,R1,R0
   \   00000082   8821               MOVS     R1,#+136
   \   00000084   0901               LSLS     R1,R1,#+4        ;; #+2176
   \   00000086   0183               STRH     R1,[R0, #+24]
    260          
    261            CAN->sMsgObj[msg_if].DA1R = 0;
   \   00000088   6020               MOVS     R0,#+96
   \   0000008A   7043               MULS     R0,R6,R0
   \   0000008C   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000008E   0818               ADDS     R0,R1,R0
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   8183               STRH     R1,[R0, #+28]
    262            CAN->sMsgObj[msg_if].DA2R = 0;
   \   00000094   6020               MOVS     R0,#+96
   \   00000096   7043               MULS     R0,R6,R0
   \   00000098   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   0000009A   0818               ADDS     R0,R1,R0
   \   0000009C   0021               MOVS     R1,#+0
   \   0000009E   0184               STRH     R1,[R0, #+32]
    263            CAN->sMsgObj[msg_if].DB1R = 0;
   \   000000A0   6020               MOVS     R0,#+96
   \   000000A2   7043               MULS     R0,R6,R0
   \   000000A4   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   000000A6   0818               ADDS     R0,R1,R0
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   8184               STRH     R1,[R0, #+36]
    264            CAN->sMsgObj[msg_if].DB2R = 0;
   \   000000AC   6020               MOVS     R0,#+96
   \   000000AE   7043               MULS     R0,R6,R0
   \   000000B0   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   000000B2   0818               ADDS     R0,R1,R0
   \   000000B4   0021               MOVS     R1,#+0
   \   000000B6   0185               STRH     R1,[R0, #+40]
    265          
    266            CAN->sMsgObj[msg_if].CRR = 1 + msgobj;
   \   000000B8   6020               MOVS     R0,#+96
   \   000000BA   7043               MULS     R0,R6,R0
   \   000000BC   ....               LDR      R1,??DataTable29  ;; 0xffffc420
   \   000000BE   2200               MOVS     R2,R4
   \   000000C0   521C               ADDS     R2,R2,#+1
   \   000000C2   0A52               STRH     R2,[R1, R0]
    267            
    268            return SUCCESS;
   \   000000C4   0120               MOVS     R0,#+1
   \                     ??CAN_SetTxMsgObj_1:
   \   000000C6   70BC               POP      {R4-R6}
   \   000000C8   02BC               POP      {R1}
   \   000000CA   0847               BX       R1               ;; return
    269          }
    270          
    271          /*******************************************************************************
    272          * Function Name  : CAN_SetRxMsgObj                                           
    273          * Description    : Configures the message object as RX.                        
    274          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                    
    275          *                  - idType: specifies the identifier type of the frames that
    276          *                    will be transmitted using this message object.
    277          *                    This parameter can be one of the following values:
    278          *                          - CAN_STD_ID (standard ID, 11-bit)
    279          *                          - CAN_EXT_ID (extended ID, 29-bit)                               
    280          *                  - idLow: specifies the low part of the identifier range used      
    281          *                    for acceptance filtering.
    282          *                  - idHigh: specifies the high part of the identifier range    
    283          *                    used for acceptance filtering.
    284          *                  - singleOrFifoLast: specifies the end-of-buffer indicator.
    285          *                    This parameter can be one of the following values:
    286          *                          - TRUE: for a single receive object or a FIFO receive
    287          *                            object that is the last one of the FIFO. 
    288          *                          - FALSE: for a FIFO receive object that is not the 
    289          *                            last one. 
    290          * Output         : None                                                      
    291          * Return         : An ErrorStatus enumuration value:
    292          *                         - SUCCESS: Interface to treat the message
    293          *                         - ERROR: No interface found to treat the message
    294          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    295          ErrorStatus CAN_SetRxMsgObj(u32 msgobj, u32 idType, u32 idLow, u32 idHigh, bool singleOrFifoLast)
    296          {
   \                     CAN_SetRxMsgObj:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1400               MOVS     R4,R2
   \   00000006   1D00               MOVS     R5,R3
   \   00000008   08A8               ADD      R0,SP,#+32
   \   0000000A   0678               LDRB     R6,[R0, #+0]
    297            u32 msg_if=0;
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0700               MOVS     R7,R0
    298          
    299            if ((msg_if = GetFreeIF()) == 2)
   \   00000010   ........           BL       GetFreeIF
   \   00000014   0700               MOVS     R7,R0
   \   00000016   0228               CMP      R0,#+2
   \   00000018   01D1               BNE      ??CAN_SetRxMsgObj_0
    300            {
    301              return ERROR;
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   94E0               B        ??CAN_SetRxMsgObj_1
    302            }
    303            
    304            CAN->sMsgObj[msg_if].CMR = CAN_CMR_WRRD
    305                                     | CAN_CMR_MASK
    306                                     | CAN_CMR_ARB
    307                                     | CAN_CMR_CONTROL
    308                                     | CAN_CMR_DATAA
    309                                     | CAN_CMR_DATAB;
   \                     ??CAN_SetRxMsgObj_0:
   \   0000001E   6020               MOVS     R0,#+96
   \   00000020   7843               MULS     R0,R7,R0
   \   00000022   4B49               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000024   0818               ADDS     R0,R1,R0
   \   00000026   F321               MOVS     R1,#+243
   \   00000028   8180               STRH     R1,[R0, #+4]
    310          
    311            if (idType == CAN_STD_ID)
   \   0000002A   0298               LDR      R0,[SP, #+8]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   24D1               BNE      ??CAN_SetRxMsgObj_3
    312            {
    313              CAN->sMsgObj[msg_if].M1R = 0;
   \   00000030   6020               MOVS     R0,#+96
   \   00000032   7843               MULS     R0,R7,R0
   \   00000034   4649               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000036   0818               ADDS     R0,R1,R0
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   0181               STRH     R1,[R0, #+8]
    314              CAN->sMsgObj[msg_if].M2R = STD_RANGE_ID_MSK(idLow, idHigh);
   \   0000003C   2800               MOVS     R0,R5
   \   0000003E   2100               MOVS     R1,R4
   \   00000040   401A               SUBS     R0,R0,R1
   \   00000042   C143               MVNS     R1,R0
   \   00000044   4805               LSLS     R0,R1,#+21       ;; ZeroExtS R0,R1,#+21,#+21
   \   00000046   400D               LSRS     R0,R0,#+21
   \   00000048   8000               LSLS     R0,R0,#+2
   \   0000004A   6021               MOVS     R1,#+96
   \   0000004C   7943               MULS     R1,R7,R1
   \   0000004E   404A               LDR      R2,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000050   5118               ADDS     R1,R2,R1
   \   00000052   8881               STRH     R0,[R1, #+12]
    315          
    316              CAN->sMsgObj[msg_if].A1R = 0;
   \   00000054   6020               MOVS     R0,#+96
   \   00000056   7843               MULS     R0,R7,R0
   \   00000058   3D49               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   0000005A   0818               ADDS     R0,R1,R0
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0182               STRH     R1,[R0, #+16]
    317              CAN->sMsgObj[msg_if].A2R = CAN_A2R_MSGVAL | STD_RANGE_ID_ARB(idLow, idHigh);
   \   00000060   2000               MOVS     R0,R4
   \   00000062   2900               MOVS     R1,R5
   \   00000064   0140               ANDS     R1,R1,R0
   \   00000066   8900               LSLS     R1,R1,#+2
   \   00000068   8020               MOVS     R0,#+128
   \   0000006A   0002               LSLS     R0,R0,#+8        ;; #+32768
   \   0000006C   0843               ORRS     R0,R0,R1
   \   0000006E   6021               MOVS     R1,#+96
   \   00000070   7943               MULS     R1,R7,R1
   \   00000072   374A               LDR      R2,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000074   5118               ADDS     R1,R2,R1
   \   00000076   8882               STRH     R0,[R1, #+20]
   \   00000078   38E0               B        ??CAN_SetRxMsgObj_4
    318            }
    319            else
    320            {
    321              CAN->sMsgObj[msg_if].M1R = EXT_RANGE_ID_MSK_L(idLow, idHigh);
   \                     ??CAN_SetRxMsgObj_3:
   \   0000007A   6020               MOVS     R0,#+96
   \   0000007C   7843               MULS     R0,R7,R0
   \   0000007E   3449               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000080   0818               ADDS     R0,R1,R0
   \   00000082   291B               SUBS     R1,R5,R4
   \   00000084   CA43               MVNS     R2,R1
   \   00000086   1100               MOVS     R1,R2
   \   00000088   C90A               LSRS     R1,R1,#+11
   \   0000008A   0181               STRH     R1,[R0, #+8]
    322              CAN->sMsgObj[msg_if].M2R = CAN_M2R_MXTD | EXT_RANGE_ID_MSK_H(idLow, idHigh);
   \   0000008C   2800               MOVS     R0,R5
   \   0000008E   2100               MOVS     R1,R4
   \   00000090   401A               SUBS     R0,R0,R1
   \   00000092   C143               MVNS     R1,R0
   \   00000094   4805               LSLS     R0,R1,#+21       ;; ZeroExtS R0,R1,#+21,#+21
   \   00000096   400D               LSRS     R0,R0,#+21
   \   00000098   8000               LSLS     R0,R0,#+2
   \   0000009A   291B               SUBS     R1,R5,R4
   \   0000009C   CA43               MVNS     R2,R1
   \   0000009E   1100               MOVS     R1,R2
   \   000000A0   C90E               LSRS     R1,R1,#+27
   \   000000A2   8907               LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A4   890F               LSRS     R1,R1,#+30
   \   000000A6   0143               ORRS     R1,R1,R0
   \   000000A8   8020               MOVS     R0,#+128
   \   000000AA   0002               LSLS     R0,R0,#+8        ;; #+32768
   \   000000AC   0843               ORRS     R0,R0,R1
   \   000000AE   6021               MOVS     R1,#+96
   \   000000B0   7943               MULS     R1,R7,R1
   \   000000B2   274A               LDR      R2,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   000000B4   5118               ADDS     R1,R2,R1
   \   000000B6   8881               STRH     R0,[R1, #+12]
    323          
    324              CAN->sMsgObj[msg_if].A1R = EXT_RANGE_ID_ARB_L(idLow, idHigh);
   \   000000B8   6020               MOVS     R0,#+96
   \   000000BA   7843               MULS     R0,R7,R0
   \   000000BC   2449               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   000000BE   0818               ADDS     R0,R1,R0
   \   000000C0   2900               MOVS     R1,R5
   \   000000C2   2140               ANDS     R1,R1,R4
   \   000000C4   C90A               LSRS     R1,R1,#+11
   \   000000C6   0182               STRH     R1,[R0, #+16]
    325              CAN->sMsgObj[msg_if].A2R = CAN_A2R_MSGVAL | CAN_A2R_XTD | EXT_RANGE_ID_ARB_H(idLow, idHigh);
   \   000000C8   2000               MOVS     R0,R4
   \   000000CA   2900               MOVS     R1,R5
   \   000000CC   0140               ANDS     R1,R1,R0
   \   000000CE   8800               LSLS     R0,R1,#+2
   \   000000D0   2900               MOVS     R1,R5
   \   000000D2   2140               ANDS     R1,R1,R4
   \   000000D4   C90E               LSRS     R1,R1,#+27
   \   000000D6   8907               LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000D8   890F               LSRS     R1,R1,#+30
   \   000000DA   0143               ORRS     R1,R1,R0
   \   000000DC   C020               MOVS     R0,#+192
   \   000000DE   0002               LSLS     R0,R0,#+8        ;; #+49152
   \   000000E0   0843               ORRS     R0,R0,R1
   \   000000E2   6021               MOVS     R1,#+96
   \   000000E4   7943               MULS     R1,R7,R1
   \   000000E6   1A4A               LDR      R2,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   000000E8   5118               ADDS     R1,R2,R1
   \   000000EA   8882               STRH     R0,[R1, #+20]
    326            }
    327          
    328            CAN->sMsgObj[msg_if].MCR = CAN_MCR_RXIE | CAN_MCR_UMASK | (singleOrFifoLast ? CAN_MCR_EOB : 0);
   \                     ??CAN_SetRxMsgObj_4:
   \   000000EC   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   000000EE   360E               LSRS     R6,R6,#+24
   \   000000F0   002E               CMP      R6,#+0
   \   000000F2   01D0               BEQ      ??CAN_SetRxMsgObj_5
   \   000000F4   8020               MOVS     R0,#+128
   \   000000F6   00E0               B        ??CAN_SetRxMsgObj_6
   \                     ??CAN_SetRxMsgObj_5:
   \   000000F8   0020               MOVS     R0,#+0
   \                     ??CAN_SetRxMsgObj_6:
   \   000000FA   6021               MOVS     R1,#+96
   \   000000FC   7943               MULS     R1,R7,R1
   \   000000FE   144A               LDR      R2,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000100   5118               ADDS     R1,R2,R1
   \   00000102   A022               MOVS     R2,#+160
   \   00000104   5201               LSLS     R2,R2,#+5        ;; #+5120
   \   00000106   0243               ORRS     R2,R2,R0
   \   00000108   0A83               STRH     R2,[R1, #+24]
    329          
    330            CAN->sMsgObj[msg_if].DA1R = 0;
   \   0000010A   6020               MOVS     R0,#+96
   \   0000010C   7843               MULS     R0,R7,R0
   \   0000010E   1049               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000110   0818               ADDS     R0,R1,R0
   \   00000112   0021               MOVS     R1,#+0
   \   00000114   8183               STRH     R1,[R0, #+28]
    331            CAN->sMsgObj[msg_if].DA2R = 0;
   \   00000116   6020               MOVS     R0,#+96
   \   00000118   7843               MULS     R0,R7,R0
   \   0000011A   0D49               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   0000011C   0818               ADDS     R0,R1,R0
   \   0000011E   0021               MOVS     R1,#+0
   \   00000120   0184               STRH     R1,[R0, #+32]
    332            CAN->sMsgObj[msg_if].DB1R = 0;
   \   00000122   6020               MOVS     R0,#+96
   \   00000124   7843               MULS     R0,R7,R0
   \   00000126   0A49               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000128   0818               ADDS     R0,R1,R0
   \   0000012A   0021               MOVS     R1,#+0
   \   0000012C   8184               STRH     R1,[R0, #+36]
    333            CAN->sMsgObj[msg_if].DB2R = 0;
   \   0000012E   6020               MOVS     R0,#+96
   \   00000130   7843               MULS     R0,R7,R0
   \   00000132   0749               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000134   0818               ADDS     R0,R1,R0
   \   00000136   0021               MOVS     R1,#+0
   \   00000138   0185               STRH     R1,[R0, #+40]
    334          
    335            CAN->sMsgObj[msg_if].CRR = 1 + msgobj;
   \   0000013A   6020               MOVS     R0,#+96
   \   0000013C   7843               MULS     R0,R7,R0
   \   0000013E   0449               LDR      R1,??CAN_SetRxMsgObj_2  ;; 0xffffc420
   \   00000140   019A               LDR      R2,[SP, #+4]
   \   00000142   521C               ADDS     R2,R2,#+1
   \   00000144   0A52               STRH     R2,[R1, R0]
    336            
    337            return SUCCESS;
   \   00000146   0120               MOVS     R0,#+1
   \                     ??CAN_SetRxMsgObj_1:
   \   00000148   FEBC               POP      {R1-R7}
   \   0000014A   02BC               POP      {R1}
   \   0000014C   0847               BX       R1               ;; return
   \   0000014E   C046               Nop      
   \                     ??CAN_SetRxMsgObj_2:
   \   00000150   20C4FFFF           DC32     0xffffc420
    338          }
    339          
    340          /*******************************************************************************
    341          * Function Name  : CAN_InvalidateAllMsgObj				      
    342          * Description    : Configures all the message objects as unused.               
    343          * Input          : None                                                      
    344          * Output         : None                                                      
    345          * Return         : None                                                      
    346          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    347          void CAN_InvalidateAllMsgObj(void)
    348          {
   \                     CAN_InvalidateAllMsgObj:
   \   00000000   10B5               PUSH     {R4,LR}
    349            u32 i=0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0400               MOVS     R4,R0
    350            for (i = 0; i < 32; i++)
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0400               MOVS     R4,R0
   \                     ??CAN_InvalidateAllMsgObj_0:
   \   0000000A   202C               CMP      R4,#+32
   \   0000000C   04D2               BCS      ??CAN_InvalidateAllMsgObj_1
    351              CAN_SetUnusedMsgObj(i);
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       CAN_SetUnusedMsgObj
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   F8E7               B        ??CAN_InvalidateAllMsgObj_0
    352          }
   \                     ??CAN_InvalidateAllMsgObj_1:
   \   00000018   10BC               POP      {R4}
   \   0000001A   01BC               POP      {R0}
   \   0000001C   0047               BX       R0               ;; return
    353          
    354          
    355          /*******************************************************************************
    356          * Function Name  : CAN_ReleaseMessage					      
    357          * Description    : Releases the message object                                
    358          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                     
    359          * Output         : None                                                      
    360          * Return         : An ErrorStatus enumuration value:
    361          *                         - SUCCESS: Interface to treat the message
    362          *                         - ERROR: No interface found to treat the message
    363          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    364          ErrorStatus CAN_ReleaseMessage(u32 msgobj)
    365          {
   \                     CAN_ReleaseMessage:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    366            u32 msg_if=0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0500               MOVS     R5,R0
    367          
    368            if ((msg_if = GetFreeIF()) == 2)
   \   00000008   ........           BL       GetFreeIF
   \   0000000C   0500               MOVS     R5,R0
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   01D1               BNE      ??CAN_ReleaseMessage_0
    369            {
    370              return ERROR;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   0CE0               B        ??CAN_ReleaseMessage_1
    371            }
    372          
    373            CAN->sMsgObj[msg_if].CMR = CAN_CMR_CLRINTPND | CAN_CMR_TXRQSTNEWDAT;
   \                     ??CAN_ReleaseMessage_0:
   \   00000016   6020               MOVS     R0,#+96
   \   00000018   6843               MULS     R0,R5,R0
   \   0000001A   0749               LDR      R1,??CAN_ReleaseMessage_2  ;; 0xffffc420
   \   0000001C   0818               ADDS     R0,R1,R0
   \   0000001E   0C21               MOVS     R1,#+12
   \   00000020   8180               STRH     R1,[R0, #+4]
    374            CAN->sMsgObj[msg_if].CRR = 1 + msgobj;
   \   00000022   6020               MOVS     R0,#+96
   \   00000024   6843               MULS     R0,R5,R0
   \   00000026   0449               LDR      R1,??CAN_ReleaseMessage_2  ;; 0xffffc420
   \   00000028   2200               MOVS     R2,R4
   \   0000002A   521C               ADDS     R2,R2,#+1
   \   0000002C   0A52               STRH     R2,[R1, R0]
    375            
    376            return SUCCESS;
   \   0000002E   0120               MOVS     R0,#+1
   \                     ??CAN_ReleaseMessage_1:
   \   00000030   38BC               POP      {R3-R5}
   \   00000032   02BC               POP      {R1}
   \   00000034   0847               BX       R1               ;; return
   \   00000036   C046               Nop      
   \                     ??CAN_ReleaseMessage_2:
   \   00000038   20C4FFFF           DC32     0xffffc420
    377          }
    378          
    379          /*******************************************************************************
    380          * Function Name  : CAN_SendMessage                                           
    381          * Description    : Start transmission of a message                           
    382          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                    
    383          *                : - pCanMsg: pointer to the message structure containing data     
    384          *                    to transmit.
    385          * Output         : None                                                      
    386          * Return         : An ErrorStatus enumuration value:
    387          *                         - SUCCESS: Transmission OK
    388          *                         - ERROR: No transmission
    389          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    390          ErrorStatus CAN_SendMessage(u32 msgobj, canmsg* pCanMsg)
    391          {
   \                     CAN_SendMessage:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0200               MOVS     R2,R0
    392            if (CAN->sMsgObj[0].CRR & CAN_CRR_BUSY)
   \   00000004   3448               LDR      R0,??CAN_SendMessage_0  ;; 0xffffc420
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   0004               LSLS     R0,R0,#+16
   \   0000000A   01D5               BPL      ??CAN_SendMessage_1
    393            {
    394              return ERROR;                    
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   60E0               B        ??CAN_SendMessage_2
    395            }
    396          
    397            CAN->SR &= ~CAN_SR_TXOK;
   \                     ??CAN_SendMessage_1:
   \   00000010   3248               LDR      R0,??CAN_SendMessage_0+0x4  ;; 0xffffc404
   \   00000012   0088               LDRH     R0,[R0, #+0]
   \   00000014   324B               LDR      R3,??CAN_SendMessage_0+0x8  ;; 0xfff7
   \   00000016   0340               ANDS     R3,R3,R0
   \   00000018   3048               LDR      R0,??CAN_SendMessage_0+0x4  ;; 0xffffc404
   \   0000001A   0380               STRH     R3,[R0, #+0]
    398          
    399            /* read the Arbitration and Message Control*/
    400            CAN->sMsgObj[0].CMR = CAN_CMR_ARB | CAN_CMR_CONTROL;
   \   0000001C   3148               LDR      R0,??CAN_SendMessage_0+0xC  ;; 0xffffc424
   \   0000001E   3023               MOVS     R3,#+48
   \   00000020   0380               STRH     R3,[R0, #+0]
    401          
    402            CAN->sMsgObj[0].CRR = 1 + msgobj;
   \   00000022   1000               MOVS     R0,R2
   \   00000024   401C               ADDS     R0,R0,#+1
   \   00000026   2C4B               LDR      R3,??CAN_SendMessage_0  ;; 0xffffc420
   \   00000028   1880               STRH     R0,[R3, #+0]
    403          
    404            if (CAN->sMsgObj[0].CRR & CAN_CRR_BUSY)
   \   0000002A   2B48               LDR      R0,??CAN_SendMessage_0  ;; 0xffffc420
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   0004               LSLS     R0,R0,#+16
   \   00000030   01D5               BPL      ??CAN_SendMessage_3
    405            {
    406              return ERROR;                    
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   4DE0               B        ??CAN_SendMessage_2
    407            }
    408          
    409            /* update the contents needed for transmission*/
    410            CAN->sMsgObj[0].CMR = CAN_CMR_WRRD
    411                                | CAN_CMR_ARB
    412                                | CAN_CMR_CONTROL
    413                                | CAN_CMR_DATAA
    414                                | CAN_CMR_DATAB;
   \                     ??CAN_SendMessage_3:
   \   00000036   2B48               LDR      R0,??CAN_SendMessage_0+0xC  ;; 0xffffc424
   \   00000038   B323               MOVS     R3,#+179
   \   0000003A   0380               STRH     R3,[R0, #+0]
    415          
    416            if ((CAN->sMsgObj[0].A2R & CAN_A2R_XTD) == 0)
   \   0000003C   2A48               LDR      R0,??CAN_SendMessage_0+0x10  ;; 0xffffc434
   \   0000003E   0088               LDRH     R0,[R0, #+0]
   \   00000040   4004               LSLS     R0,R0,#+17
   \   00000042   0FD4               BMI      ??CAN_SendMessage_4
    417            {
    418              /* standard ID*/
    419              CAN->sMsgObj[0].A1R = 0;
   \   00000044   2948               LDR      R0,??CAN_SendMessage_0+0x14  ;; 0xffffc430
   \   00000046   0023               MOVS     R3,#+0
   \   00000048   0380               STRH     R3,[R0, #+0]
    420              CAN->sMsgObj[0].A2R = (CAN->sMsgObj[0].A2R & 0xE000) | STD_FIXED_ID_ARB(pCanMsg->Id);
   \   0000004A   2748               LDR      R0,??CAN_SendMessage_0+0x10  ;; 0xffffc434
   \   0000004C   0088               LDRH     R0,[R0, #+0]
   \   0000004E   E023               MOVS     R3,#+224
   \   00000050   1B02               LSLS     R3,R3,#+8        ;; #+57344
   \   00000052   0340               ANDS     R3,R3,R0
   \   00000054   4868               LDR      R0,[R1, #+4]
   \   00000056   4C68               LDR      R4,[R1, #+4]
   \   00000058   0440               ANDS     R4,R4,R0
   \   0000005A   A000               LSLS     R0,R4,#+2
   \   0000005C   1843               ORRS     R0,R0,R3
   \   0000005E   224B               LDR      R3,??CAN_SendMessage_0+0x10  ;; 0xffffc434
   \   00000060   1880               STRH     R0,[R3, #+0]
   \   00000062   0EE0               B        ??CAN_SendMessage_5
    421            }
    422            else
    423            {
    424              /* extended ID AKHE*/
    425              //CAN->sMsgObj[0].A1R = EXT_FIXED_ID_ARB_L(pCanMsg->Id);
    426              //CAN->sMsgObj[0].A2R = (CAN->sMsgObj[0].A2R & 0xE000) | EXT_FIXED_ID_ARB_H(pCanMsg->Id);
    427              CAN->sMsgObj[0].A1R = pCanMsg->Id & 0xffff;
   \                     ??CAN_SendMessage_4:
   \   00000064   4868               LDR      R0,[R1, #+4]
   \   00000066   214B               LDR      R3,??CAN_SendMessage_0+0x14  ;; 0xffffc430
   \   00000068   1880               STRH     R0,[R3, #+0]
    428              CAN->sMsgObj[0].A2R = (CAN->sMsgObj[0].A2R & 0xE000) | ( ( pCanMsg->Id >> 16 ) & 0xffff);
   \   0000006A   1F48               LDR      R0,??CAN_SendMessage_0+0x10  ;; 0xffffc434
   \   0000006C   0088               LDRH     R0,[R0, #+0]
   \   0000006E   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000070   000C               LSRS     R0,R0,#+16
   \   00000072   E023               MOVS     R3,#+224
   \   00000074   1B02               LSLS     R3,R3,#+8        ;; #+57344
   \   00000076   0340               ANDS     R3,R3,R0
   \   00000078   4868               LDR      R0,[R1, #+4]
   \   0000007A   000C               LSRS     R0,R0,#+16
   \   0000007C   1843               ORRS     R0,R0,R3
   \   0000007E   1A4B               LDR      R3,??CAN_SendMessage_0+0x10  ;; 0xffffc434
   \   00000080   1880               STRH     R0,[R3, #+0]
    429            }
    430          
    431            CAN->sMsgObj[0].MCR = (CAN->sMsgObj[0].MCR & 0xFEF0) | CAN_MCR_NEWDAT | CAN_MCR_TXRQST | pCanMsg->Dlc;
   \                     ??CAN_SendMessage_5:
   \   00000082   1B48               LDR      R0,??CAN_SendMessage_0+0x18  ;; 0xffffc438
   \   00000084   0088               LDRH     R0,[R0, #+0]
   \   00000086   1B4B               LDR      R3,??CAN_SendMessage_0+0x1C  ;; 0xfef0
   \   00000088   0340               ANDS     R3,R3,R0
   \   0000008A   087A               LDRB     R0,[R1, #+8]
   \   0000008C   1843               ORRS     R0,R0,R3
   \   0000008E   8123               MOVS     R3,#+129
   \   00000090   1B02               LSLS     R3,R3,#+8        ;; #+33024
   \   00000092   0343               ORRS     R3,R3,R0
   \   00000094   1648               LDR      R0,??CAN_SendMessage_0+0x18  ;; 0xffffc438
   \   00000096   0380               STRH     R3,[R0, #+0]
    432          
    433            CAN->sMsgObj[0].DA1R = ((u16)pCanMsg->Data[1]<<8) | pCanMsg->Data[0];
   \   00000098   887A               LDRB     R0,[R1, #+10]
   \   0000009A   0002               LSLS     R0,R0,#+8
   \   0000009C   4B7A               LDRB     R3,[R1, #+9]
   \   0000009E   0343               ORRS     R3,R3,R0
   \   000000A0   1548               LDR      R0,??CAN_SendMessage_0+0x20  ;; 0xffffc43c
   \   000000A2   0380               STRH     R3,[R0, #+0]
    434            CAN->sMsgObj[0].DA2R = ((u16)pCanMsg->Data[3]<<8) | pCanMsg->Data[2];
   \   000000A4   087B               LDRB     R0,[R1, #+12]
   \   000000A6   0002               LSLS     R0,R0,#+8
   \   000000A8   CB7A               LDRB     R3,[R1, #+11]
   \   000000AA   0343               ORRS     R3,R3,R0
   \   000000AC   1348               LDR      R0,??CAN_SendMessage_0+0x24  ;; 0xffffc440
   \   000000AE   0380               STRH     R3,[R0, #+0]
    435            CAN->sMsgObj[0].DB1R = ((u16)pCanMsg->Data[5]<<8) | pCanMsg->Data[4];
   \   000000B0   887B               LDRB     R0,[R1, #+14]
   \   000000B2   0002               LSLS     R0,R0,#+8
   \   000000B4   4B7B               LDRB     R3,[R1, #+13]
   \   000000B6   0343               ORRS     R3,R3,R0
   \   000000B8   1148               LDR      R0,??CAN_SendMessage_0+0x28  ;; 0xffffc444
   \   000000BA   0380               STRH     R3,[R0, #+0]
    436            CAN->sMsgObj[0].DB2R = ((u16)pCanMsg->Data[7]<<8) | pCanMsg->Data[6];
   \   000000BC   087C               LDRB     R0,[R1, #+16]
   \   000000BE   0002               LSLS     R0,R0,#+8
   \   000000C0   CB7B               LDRB     R3,[R1, #+15]
   \   000000C2   0343               ORRS     R3,R3,R0
   \   000000C4   0F48               LDR      R0,??CAN_SendMessage_0+0x2C  ;; 0xffffc448
   \   000000C6   0380               STRH     R3,[R0, #+0]
    437          
    438            CAN->sMsgObj[0].CRR = 1 + msgobj;
   \   000000C8   1000               MOVS     R0,R2
   \   000000CA   401C               ADDS     R0,R0,#+1
   \   000000CC   024B               LDR      R3,??CAN_SendMessage_0  ;; 0xffffc420
   \   000000CE   1880               STRH     R0,[R3, #+0]
    439          
    440            return SUCCESS;
   \   000000D0   0120               MOVS     R0,#+1
   \                     ??CAN_SendMessage_2:
   \   000000D2   10BC               POP      {R4}
   \   000000D4   02BC               POP      {R1}
   \   000000D6   0847               BX       R1               ;; return
   \                     ??CAN_SendMessage_0:
   \   000000D8   20C4FFFF           DC32     0xffffc420
   \   000000DC   04C4FFFF           DC32     0xffffc404
   \   000000E0   F7FF0000           DC32     0xfff7
   \   000000E4   24C4FFFF           DC32     0xffffc424
   \   000000E8   34C4FFFF           DC32     0xffffc434
   \   000000EC   30C4FFFF           DC32     0xffffc430
   \   000000F0   38C4FFFF           DC32     0xffffc438
   \   000000F4   F0FE0000           DC32     0xfef0
   \   000000F8   3CC4FFFF           DC32     0xffffc43c
   \   000000FC   40C4FFFF           DC32     0xffffc440
   \   00000100   44C4FFFF           DC32     0xffffc444
   \   00000104   48C4FFFF           DC32     0xffffc448
    441          }
    442          
    443          /*******************************************************************************
    444          * Function Name  : CAN_ReceiveMessage                                        
    445          * Description    : Gets the message, if received.
    446          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                     
    447          *                  - release: specifies the message release indicator.
    448          *                    This parameter can be one of the following values:
    449          *                          - TRUE: the message object is released when getting  
    450          *                            the data.
    451          *                          - FALSE: the message object is not released.
    452          *                  - pCanMsg: pointer to the message structure where received   
    453          *                    data is copied.
    454          * Output         : None                                                      
    455          * Return         : An ErrorStatus enumuration value:
    456          *                         - SUCCESS: Reception OK
    457          *                         - ERROR: No message pending
    458          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    459          ErrorStatus CAN_ReceiveMessage(u32 msgobj, bool release, canmsg* pCanMsg)
    460          {
   \                     CAN_ReceiveMessage:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    461            if (!CAN_IsMessageWaiting(msgobj))
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       CAN_IsMessageWaiting
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   01D1               BNE      ??CAN_ReceiveMessage_0
    462            {
    463              return ERROR;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   5CE0               B        ??CAN_ReceiveMessage_1
    464            }
    465          
    466            CAN->SR &= ~CAN_SR_RXOK;
   \                     ??CAN_ReceiveMessage_0:
   \   00000016   3048               LDR      R0,??CAN_ReceiveMessage_2  ;; 0xffffc404
   \   00000018   0088               LDRH     R0,[R0, #+0]
   \   0000001A   3049               LDR      R1,??CAN_ReceiveMessage_2+0x4  ;; 0xffef
   \   0000001C   0140               ANDS     R1,R1,R0
   \   0000001E   2E48               LDR      R0,??CAN_ReceiveMessage_2  ;; 0xffffc404
   \   00000020   0180               STRH     R1,[R0, #+0]
    467          
    468            /* read the message contents*/
    469            CAN->sMsgObj[1].CMR = CAN_CMR_MASK
    470                                | CAN_CMR_ARB
    471                                | CAN_CMR_CONTROL
    472                                | CAN_CMR_CLRINTPND
    473                                | (release ? CAN_CMR_TXRQSTNEWDAT : 0)
    474                                | CAN_CMR_DATAA
    475                                | CAN_CMR_DATAB;
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   002D               CMP      R5,#+0
   \   00000028   01D0               BEQ      ??CAN_ReceiveMessage_3
   \   0000002A   0420               MOVS     R0,#+4
   \   0000002C   00E0               B        ??CAN_ReceiveMessage_4
   \                     ??CAN_ReceiveMessage_3:
   \   0000002E   0020               MOVS     R0,#+0
   \                     ??CAN_ReceiveMessage_4:
   \   00000030   7B21               MOVS     R1,#+123
   \   00000032   0143               ORRS     R1,R1,R0
   \   00000034   2A48               LDR      R0,??CAN_ReceiveMessage_2+0x8  ;; 0xffffc484
   \   00000036   0180               STRH     R1,[R0, #+0]
    476          
    477            CAN->sMsgObj[1].CRR = 1 + msgobj;
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   401C               ADDS     R0,R0,#+1
   \   0000003C   2949               LDR      R1,??CAN_ReceiveMessage_2+0xC  ;; 0xffffc480
   \   0000003E   0880               STRH     R0,[R1, #+0]
    478          
    479            if (CAN->sMsgObj[1].CRR & CAN_CRR_BUSY)
   \   00000040   2848               LDR      R0,??CAN_ReceiveMessage_2+0xC  ;; 0xffffc480
   \   00000042   0088               LDRH     R0,[R0, #+0]
   \   00000044   0004               LSLS     R0,R0,#+16
   \   00000046   01D5               BPL      ??CAN_ReceiveMessage_5
    480            {
    481              return ERROR;                    
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   41E0               B        ??CAN_ReceiveMessage_1
    482            }
    483            
    484            if ((CAN->sMsgObj[1].A2R & CAN_A2R_XTD) == 0)
   \                     ??CAN_ReceiveMessage_5:
   \   0000004C   2648               LDR      R0,??CAN_ReceiveMessage_2+0x10  ;; 0xffffc494
   \   0000004E   0088               LDRH     R0,[R0, #+0]
   \   00000050   4004               LSLS     R0,R0,#+17
   \   00000052   0AD4               BMI      ??CAN_ReceiveMessage_6
    485            {
    486              /* standard ID*/
    487              pCanMsg->IdType = CAN_STD_ID;
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   3060               STR      R0,[R6, #+0]
    488              pCanMsg->Id = (CAN->sMsgObj[1].A2R >> 2) & 0x07FF;
   \   00000058   2348               LDR      R0,??CAN_ReceiveMessage_2+0x10  ;; 0xffffc494
   \   0000005A   0088               LDRH     R0,[R0, #+0]
   \   0000005C   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000005E   000C               LSRS     R0,R0,#+16
   \   00000060   8010               ASRS     R0,R0,#+2
   \   00000062   4005               LSLS     R0,R0,#+21       ;; ZeroExtS R0,R0,#+21,#+21
   \   00000064   400D               LSRS     R0,R0,#+21
   \   00000066   7060               STR      R0,[R6, #+4]
   \   00000068   08E0               B        ??CAN_ReceiveMessage_7
    489            }
    490            else
    491            {
    492              /* extended ID AKHE*/
    493              pCanMsg->IdType = CAN_EXT_ID;
   \                     ??CAN_ReceiveMessage_6:
   \   0000006A   0120               MOVS     R0,#+1
   \   0000006C   3060               STR      R0,[R6, #+0]
    494              //pCanMsg->Id  = ((CAN->sMsgObj[1].A2R >> 2) & 0x07FF); 
    495              //pCanMsg->Id |= ((u32)CAN->sMsgObj[1].A1R << 11);
    496              //pCanMsg->Id |= (((u32)CAN->sMsgObj[1].A2R & 0x0003) << 27);
    497              pCanMsg->Id = CAN->sMsgObj[1].A1R + ( ( CAN->sMsgObj[1].A2R & 0x1fff ) >> 16 );
                                                                                                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   0000006E   1F48               LDR      R0,??CAN_ReceiveMessage_2+0x14  ;; 0xffffc490
   \   00000070   0088               LDRH     R0,[R0, #+0]
   \   00000072   1D49               LDR      R1,??CAN_ReceiveMessage_2+0x10  ;; 0xffffc494
   \   00000074   0988               LDRH     R1,[R1, #+0]
   \   00000076   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000078   000C               LSRS     R0,R0,#+16
   \   0000007A   7060               STR      R0,[R6, #+4]
    498            }
    499          
    500            pCanMsg->Dlc = CAN->sMsgObj[1].MCR & 0x0F;
   \                     ??CAN_ReceiveMessage_7:
   \   0000007C   1C48               LDR      R0,??CAN_ReceiveMessage_2+0x18  ;; 0xffffc498
   \   0000007E   0088               LDRH     R0,[R0, #+0]
   \   00000080   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000082   000F               LSRS     R0,R0,#+28
   \   00000084   3072               STRB     R0,[R6, #+8]
    501          
    502            pCanMsg->Data[0] = (u8) CAN->sMsgObj[1].DA1R;
   \   00000086   1B48               LDR      R0,??CAN_ReceiveMessage_2+0x1C  ;; 0xffffc49c
   \   00000088   0088               LDRH     R0,[R0, #+0]
   \   0000008A   7072               STRB     R0,[R6, #+9]
    503            pCanMsg->Data[1] = (u8)(CAN->sMsgObj[1].DA1R >> 8);
   \   0000008C   1948               LDR      R0,??CAN_ReceiveMessage_2+0x1C  ;; 0xffffc49c
   \   0000008E   0088               LDRH     R0,[R0, #+0]
   \   00000090   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000092   000C               LSRS     R0,R0,#+16
   \   00000094   000A               LSRS     R0,R0,#+8
   \   00000096   B072               STRB     R0,[R6, #+10]
    504            pCanMsg->Data[2] = (u8) CAN->sMsgObj[1].DA2R;
   \   00000098   1748               LDR      R0,??CAN_ReceiveMessage_2+0x20  ;; 0xffffc4a0
   \   0000009A   0088               LDRH     R0,[R0, #+0]
   \   0000009C   F072               STRB     R0,[R6, #+11]
    505            pCanMsg->Data[3] = (u8)(CAN->sMsgObj[1].DA2R >> 8);
   \   0000009E   1648               LDR      R0,??CAN_ReceiveMessage_2+0x20  ;; 0xffffc4a0
   \   000000A0   0088               LDRH     R0,[R0, #+0]
   \   000000A2   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   000000A4   000C               LSRS     R0,R0,#+16
   \   000000A6   000A               LSRS     R0,R0,#+8
   \   000000A8   3073               STRB     R0,[R6, #+12]
    506            pCanMsg->Data[4] = (u8) CAN->sMsgObj[1].DB1R;
   \   000000AA   1448               LDR      R0,??CAN_ReceiveMessage_2+0x24  ;; 0xffffc4a4
   \   000000AC   0088               LDRH     R0,[R0, #+0]
   \   000000AE   7073               STRB     R0,[R6, #+13]
    507            pCanMsg->Data[5] = (u8)(CAN->sMsgObj[1].DB1R >> 8);
   \   000000B0   1248               LDR      R0,??CAN_ReceiveMessage_2+0x24  ;; 0xffffc4a4
   \   000000B2   0088               LDRH     R0,[R0, #+0]
   \   000000B4   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   000000B6   000C               LSRS     R0,R0,#+16
   \   000000B8   000A               LSRS     R0,R0,#+8
   \   000000BA   B073               STRB     R0,[R6, #+14]
    508            pCanMsg->Data[6] = (u8) CAN->sMsgObj[1].DB2R;
   \   000000BC   1048               LDR      R0,??CAN_ReceiveMessage_2+0x28  ;; 0xffffc4a8
   \   000000BE   0088               LDRH     R0,[R0, #+0]
   \   000000C0   F073               STRB     R0,[R6, #+15]
    509            pCanMsg->Data[7] = (u8)(CAN->sMsgObj[1].DB2R >> 8);
   \   000000C2   0F48               LDR      R0,??CAN_ReceiveMessage_2+0x28  ;; 0xffffc4a8
   \   000000C4   0088               LDRH     R0,[R0, #+0]
   \   000000C6   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   000000C8   000C               LSRS     R0,R0,#+16
   \   000000CA   000A               LSRS     R0,R0,#+8
   \   000000CC   3074               STRB     R0,[R6, #+16]
    510          
    511            return SUCCESS;
   \   000000CE   0120               MOVS     R0,#+1
   \                     ??CAN_ReceiveMessage_1:
   \   000000D0   70BC               POP      {R4-R6}
   \   000000D2   02BC               POP      {R1}
   \   000000D4   0847               BX       R1               ;; return
   \   000000D6   C046               Nop      
   \                     ??CAN_ReceiveMessage_2:
   \   000000D8   04C4FFFF           DC32     0xffffc404
   \   000000DC   EFFF0000           DC32     0xffef
   \   000000E0   84C4FFFF           DC32     0xffffc484
   \   000000E4   80C4FFFF           DC32     0xffffc480
   \   000000E8   94C4FFFF           DC32     0xffffc494
   \   000000EC   90C4FFFF           DC32     0xffffc490
   \   000000F0   98C4FFFF           DC32     0xffffc498
   \   000000F4   9CC4FFFF           DC32     0xffffc49c
   \   000000F8   A0C4FFFF           DC32     0xffffc4a0
   \   000000FC   A4C4FFFF           DC32     0xffffc4a4
   \   00000100   A8C4FFFF           DC32     0xffffc4a8
    512          }
    513          
    514          /*******************************************************************************
    515          * Function Name  : CAN_WaitEndOfTx                                           
    516          * Description    : Waits until current transmission is finished.               
    517          * Input          : None                                                      
    518          * Output         : None                                                      
    519          * Return         : An ErrorStatus enumuration value:
    520          *                         - SUCCESS: Transmission ended
    521          *                         - ERROR: Transmission did not occur yet
    522          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    523          ErrorStatus CAN_WaitEndOfTx(void)
    524          {
   \                     CAN_WaitEndOfTx:
   \   00000000   01B5               PUSH     {R0,LR}
    525            // Changed by AKHE
    526            while ( 0 == ( CAN->SR & CAN_SR_TXOK ) );
   \                     ??CAN_WaitEndOfTx_0:
   \   00000002   0748               LDR      R0,??CAN_WaitEndOfTx_1  ;; 0xffffc404
   \   00000004   0088               LDRH     R0,[R0, #+0]
   \   00000006   0007               LSLS     R0,R0,#+28
   \   00000008   FBD5               BPL      ??CAN_WaitEndOfTx_0
    527            CAN->SR &= ~CAN_SR_TXOK;
   \   0000000A   0548               LDR      R0,??CAN_WaitEndOfTx_1  ;; 0xffffc404
   \   0000000C   0088               LDRH     R0,[R0, #+0]
   \   0000000E   0549               LDR      R1,??CAN_WaitEndOfTx_1+0x4  ;; 0xfff7
   \   00000010   0140               ANDS     R1,R1,R0
   \   00000012   0348               LDR      R0,??CAN_WaitEndOfTx_1  ;; 0xffffc404
   \   00000014   0180               STRH     R1,[R0, #+0]
    528          /*        
    529            if ((CAN->SR & CAN_SR_TXOK) == 0)
    530            {
    531              return ERROR;
    532            }
    533            CAN->SR &= ~CAN_SR_TXOK;
    534          */  
    535            return SUCCESS;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   08BC               POP      {R3}
   \   0000001A   02BC               POP      {R1}
   \   0000001C   0847               BX       R1               ;; return
   \   0000001E   C046               Nop      
   \                     ??CAN_WaitEndOfTx_1:
   \   00000020   04C4FFFF           DC32     0xffffc404
   \   00000024   F7FF0000           DC32     0xfff7
    536          }
    537          
    538          /*******************************************************************************
    539          * Function Name  : CAN_BasicSendMessage                                      
    540          * Description    : Starts transmission of a message in BASIC mode. This mode 
    541          *                  does not use the message RAM.             
    542          * Input          : pCanMsg: Pointer to the message structure containing data to       
    543          *                  transmit.                                                  
    544          * Output         : None                                                      
    545          * Return         : An ErrorStatus enumuration value:
    546          *                         - SUCCESS: Transmission OK
    547          *                         - ERROR: No transmission
    548          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    549          ErrorStatus CAN_BasicSendMessage(canmsg* pCanMsg)
    550          {
   \                     CAN_BasicSendMessage:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    551            /* clear NewDat bit in IF2 to detect next reception*/
    552            CAN->sMsgObj[1].MCR &= ~CAN_MCR_NEWDAT;
   \   00000004   2F48               LDR      R0,??CAN_BasicSendMessage_0  ;; 0xffffc498
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   4004               LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   0000000A   400C               LSRS     R0,R0,#+17
   \   0000000C   2D4A               LDR      R2,??CAN_BasicSendMessage_0  ;; 0xffffc498
   \   0000000E   1080               STRH     R0,[R2, #+0]
    553          
    554            CAN->SR &= ~CAN_SR_TXOK;
   \   00000010   2D48               LDR      R0,??CAN_BasicSendMessage_0+0x4  ;; 0xffffc404
   \   00000012   0088               LDRH     R0,[R0, #+0]
   \   00000014   2D4A               LDR      R2,??CAN_BasicSendMessage_0+0x8  ;; 0xfff7
   \   00000016   0240               ANDS     R2,R2,R0
   \   00000018   2B48               LDR      R0,??CAN_BasicSendMessage_0+0x4  ;; 0xffffc404
   \   0000001A   0280               STRH     R2,[R0, #+0]
    555            CAN->sMsgObj[0].CMR = CAN_CMR_WRRD
    556                                | CAN_CMR_ARB
    557                                | CAN_CMR_CONTROL
    558                                | CAN_CMR_DATAA
    559                                | CAN_CMR_DATAB;
   \   0000001C   2C48               LDR      R0,??CAN_BasicSendMessage_0+0xC  ;; 0xffffc424
   \   0000001E   B322               MOVS     R2,#+179
   \   00000020   0280               STRH     R2,[R0, #+0]
    560          
    561            if (pCanMsg->IdType == CAN_STD_ID)
   \   00000022   0868               LDR      R0,[R1, #+0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0FD1               BNE      ??CAN_BasicSendMessage_1
    562            {
    563              /* standard ID*/
    564              CAN->sMsgObj[0].A1R = 0;
   \   00000028   2A48               LDR      R0,??CAN_BasicSendMessage_0+0x10  ;; 0xffffc430
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   0280               STRH     R2,[R0, #+0]
    565              CAN->sMsgObj[0].A2R = (CAN->sMsgObj[0].A2R & 0xE000) | STD_FIXED_ID_ARB(pCanMsg->Id);
   \   0000002E   2A48               LDR      R0,??CAN_BasicSendMessage_0+0x14  ;; 0xffffc434
   \   00000030   0088               LDRH     R0,[R0, #+0]
   \   00000032   E022               MOVS     R2,#+224
   \   00000034   1202               LSLS     R2,R2,#+8        ;; #+57344
   \   00000036   0240               ANDS     R2,R2,R0
   \   00000038   4868               LDR      R0,[R1, #+4]
   \   0000003A   4B68               LDR      R3,[R1, #+4]
   \   0000003C   0340               ANDS     R3,R3,R0
   \   0000003E   9800               LSLS     R0,R3,#+2
   \   00000040   1043               ORRS     R0,R0,R2
   \   00000042   254A               LDR      R2,??CAN_BasicSendMessage_0+0x14  ;; 0xffffc434
   \   00000044   1080               STRH     R0,[R2, #+0]
   \   00000046   0EE0               B        ??CAN_BasicSendMessage_2
    566            }
    567            else
    568            {
    569              /* extended ID AKHE*/
    570              //CAN->sMsgObj[0].A1R = EXT_FIXED_ID_ARB_L(pCanMsg->Id);
    571              //CAN->sMsgObj[0].A2R = ((CAN->sMsgObj[0].A2R) & 0xE000) | EXT_FIXED_ID_ARB_H(pCanMsg->Id);
    572              CAN->sMsgObj[0].A1R = pCanMsg->Id & 0xffff;
   \                     ??CAN_BasicSendMessage_1:
   \   00000048   4868               LDR      R0,[R1, #+4]
   \   0000004A   224A               LDR      R2,??CAN_BasicSendMessage_0+0x10  ;; 0xffffc430
   \   0000004C   1080               STRH     R0,[R2, #+0]
    573              CAN->sMsgObj[0].A2R = (CAN->sMsgObj[0].A2R & 0xE000) | ( ( pCanMsg->Id >> 16 ) & 0xffff);
   \   0000004E   2248               LDR      R0,??CAN_BasicSendMessage_0+0x14  ;; 0xffffc434
   \   00000050   0088               LDRH     R0,[R0, #+0]
   \   00000052   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000054   000C               LSRS     R0,R0,#+16
   \   00000056   E022               MOVS     R2,#+224
   \   00000058   1202               LSLS     R2,R2,#+8        ;; #+57344
   \   0000005A   0240               ANDS     R2,R2,R0
   \   0000005C   4868               LDR      R0,[R1, #+4]
   \   0000005E   000C               LSRS     R0,R0,#+16
   \   00000060   1043               ORRS     R0,R0,R2
   \   00000062   1D4A               LDR      R2,??CAN_BasicSendMessage_0+0x14  ;; 0xffffc434
   \   00000064   1080               STRH     R0,[R2, #+0]
    574            }
    575          
    576            CAN->sMsgObj[0].MCR = (CAN->sMsgObj[0].MCR & 0xFCF0) | pCanMsg->Dlc;
   \                     ??CAN_BasicSendMessage_2:
   \   00000066   1D48               LDR      R0,??CAN_BasicSendMessage_0+0x18  ;; 0xffffc438
   \   00000068   0088               LDRH     R0,[R0, #+0]
   \   0000006A   1D4A               LDR      R2,??CAN_BasicSendMessage_0+0x1C  ;; 0xfcf0
   \   0000006C   0240               ANDS     R2,R2,R0
   \   0000006E   087A               LDRB     R0,[R1, #+8]
   \   00000070   1043               ORRS     R0,R0,R2
   \   00000072   1A4A               LDR      R2,??CAN_BasicSendMessage_0+0x18  ;; 0xffffc438
   \   00000074   1080               STRH     R0,[R2, #+0]
    577          
    578            CAN->sMsgObj[0].DA1R = ((u16)pCanMsg->Data[1]<<8) | pCanMsg->Data[0];
   \   00000076   887A               LDRB     R0,[R1, #+10]
   \   00000078   0002               LSLS     R0,R0,#+8
   \   0000007A   4A7A               LDRB     R2,[R1, #+9]
   \   0000007C   0243               ORRS     R2,R2,R0
   \   0000007E   1948               LDR      R0,??CAN_BasicSendMessage_0+0x20  ;; 0xffffc43c
   \   00000080   0280               STRH     R2,[R0, #+0]
    579            CAN->sMsgObj[0].DA2R = ((u16)pCanMsg->Data[3]<<8) | pCanMsg->Data[2];
   \   00000082   087B               LDRB     R0,[R1, #+12]
   \   00000084   0002               LSLS     R0,R0,#+8
   \   00000086   CA7A               LDRB     R2,[R1, #+11]
   \   00000088   0243               ORRS     R2,R2,R0
   \   0000008A   1748               LDR      R0,??CAN_BasicSendMessage_0+0x24  ;; 0xffffc440
   \   0000008C   0280               STRH     R2,[R0, #+0]
    580            CAN->sMsgObj[0].DB1R = ((u16)pCanMsg->Data[5]<<8) | pCanMsg->Data[4];
   \   0000008E   887B               LDRB     R0,[R1, #+14]
   \   00000090   0002               LSLS     R0,R0,#+8
   \   00000092   4A7B               LDRB     R2,[R1, #+13]
   \   00000094   0243               ORRS     R2,R2,R0
   \   00000096   1548               LDR      R0,??CAN_BasicSendMessage_0+0x28  ;; 0xffffc444
   \   00000098   0280               STRH     R2,[R0, #+0]
    581            CAN->sMsgObj[0].DB2R = ((u16)pCanMsg->Data[7]<<8) | pCanMsg->Data[6];
   \   0000009A   087C               LDRB     R0,[R1, #+16]
   \   0000009C   0002               LSLS     R0,R0,#+8
   \   0000009E   CA7B               LDRB     R2,[R1, #+15]
   \   000000A0   0243               ORRS     R2,R2,R0
   \   000000A2   1348               LDR      R0,??CAN_BasicSendMessage_0+0x2C  ;; 0xffffc448
   \   000000A4   0280               STRH     R2,[R0, #+0]
    582          
    583            /* request transmission*/
    584            if (CAN->sMsgObj[0].CRR == CAN_CRR_BUSY )
   \   000000A6   1348               LDR      R0,??CAN_BasicSendMessage_0+0x30  ;; 0xffffc420
   \   000000A8   0088               LDRH     R0,[R0, #+0]
   \   000000AA   8022               MOVS     R2,#+128
   \   000000AC   1202               LSLS     R2,R2,#+8        ;; #+32768
   \   000000AE   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   000000B0   000C               LSRS     R0,R0,#+16
   \   000000B2   9042               CMP      R0,R2
   \   000000B4   01D1               BNE      ??CAN_BasicSendMessage_3
    585            {
    586              return ERROR;
   \   000000B6   0020               MOVS     R0,#+0
   \   000000B8   00E0               B        ??CAN_BasicSendMessage_4
    587            }
    588          
    589            return SUCCESS;
   \                     ??CAN_BasicSendMessage_3:
   \   000000BA   0120               MOVS     R0,#+1
   \                     ??CAN_BasicSendMessage_4:
   \   000000BC   08BC               POP      {R3}
   \   000000BE   02BC               POP      {R1}
   \   000000C0   0847               BX       R1               ;; return
   \   000000C2   C046               Nop      
   \                     ??CAN_BasicSendMessage_0:
   \   000000C4   98C4FFFF           DC32     0xffffc498
   \   000000C8   04C4FFFF           DC32     0xffffc404
   \   000000CC   F7FF0000           DC32     0xfff7
   \   000000D0   24C4FFFF           DC32     0xffffc424
   \   000000D4   30C4FFFF           DC32     0xffffc430
   \   000000D8   34C4FFFF           DC32     0xffffc434
   \   000000DC   38C4FFFF           DC32     0xffffc438
   \   000000E0   F0FC0000           DC32     0xfcf0
   \   000000E4   3CC4FFFF           DC32     0xffffc43c
   \   000000E8   40C4FFFF           DC32     0xffffc440
   \   000000EC   44C4FFFF           DC32     0xffffc444
   \   000000F0   48C4FFFF           DC32     0xffffc448
   \   000000F4   20C4FFFF           DC32     0xffffc420
    590          }
    591          
    592          /*******************************************************************************
    593          * Function Name  : CAN_BasicReceiveMessage                                   
    594          * Description    : Gets the message in BASIC mode, if received. This mode does
    595          *                  not use the message RAM.                
    596          * Input          : pCanMsg: pointer to the message structure where message is copied.    
    597          * Output         : None                                                      
    598          * Return         : An ErrorStatus enumuration value:
    599          *                         - SUCCESS: Reception OK
    600          *                         - ERROR: No message pending
    601          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    602          ErrorStatus CAN_BasicReceiveMessage(canmsg* pCanMsg)
    603          {
   \                     CAN_BasicReceiveMessage:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
    604            if ((CAN->sMsgObj[1].MCR & CAN_MCR_NEWDAT) == 0)
   \   00000004   2948               LDR      R0,??CAN_BasicReceiveMessage_0  ;; 0xffffc498
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   0004               LSLS     R0,R0,#+16
   \   0000000A   01D4               BMI      ??CAN_BasicReceiveMessage_1
    605            {
    606              return ERROR;
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   4AE0               B        ??CAN_BasicReceiveMessage_2
    607            }
    608          
    609            CAN->SR &= ~CAN_SR_RXOK;
   \                     ??CAN_BasicReceiveMessage_1:
   \   00000010   2748               LDR      R0,??CAN_BasicReceiveMessage_0+0x4  ;; 0xffffc404
   \   00000012   0088               LDRH     R0,[R0, #+0]
   \   00000014   274A               LDR      R2,??CAN_BasicReceiveMessage_0+0x8  ;; 0xffef
   \   00000016   0240               ANDS     R2,R2,R0
   \   00000018   2548               LDR      R0,??CAN_BasicReceiveMessage_0+0x4  ;; 0xffffc404
   \   0000001A   0280               STRH     R2,[R0, #+0]
    610          
    611            CAN->sMsgObj[1].CMR = CAN_CMR_ARB
    612                                | CAN_CMR_CONTROL
    613                                | CAN_CMR_DATAA
    614                                | CAN_CMR_DATAB;
   \   0000001C   2648               LDR      R0,??CAN_BasicReceiveMessage_0+0xC  ;; 0xffffc484
   \   0000001E   3322               MOVS     R2,#+51
   \   00000020   0280               STRH     R2,[R0, #+0]
    615          
    616            if ((CAN->sMsgObj[1].A2R & CAN_A2R_XTD) == 0)
   \   00000022   2648               LDR      R0,??CAN_BasicReceiveMessage_0+0x10  ;; 0xffffc494
   \   00000024   0088               LDRH     R0,[R0, #+0]
   \   00000026   4004               LSLS     R0,R0,#+17
   \   00000028   0AD4               BMI      ??CAN_BasicReceiveMessage_3
    617            {
    618              /* standard ID*/
    619              pCanMsg->IdType = CAN_STD_ID;
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   0860               STR      R0,[R1, #+0]
    620              pCanMsg->Id = (CAN->sMsgObj[1].A2R >> 2) & 0x07FF;
   \   0000002E   2348               LDR      R0,??CAN_BasicReceiveMessage_0+0x10  ;; 0xffffc494
   \   00000030   0088               LDRH     R0,[R0, #+0]
   \   00000032   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000034   000C               LSRS     R0,R0,#+16
   \   00000036   8010               ASRS     R0,R0,#+2
   \   00000038   4005               LSLS     R0,R0,#+21       ;; ZeroExtS R0,R0,#+21,#+21
   \   0000003A   400D               LSRS     R0,R0,#+21
   \   0000003C   4860               STR      R0,[R1, #+4]
   \   0000003E   08E0               B        ??CAN_BasicReceiveMessage_4
    621            }
    622            else
    623            {
    624              /* extended ID*/
    625              pCanMsg->IdType = CAN_EXT_ID;
   \                     ??CAN_BasicReceiveMessage_3:
   \   00000040   0120               MOVS     R0,#+1
   \   00000042   0860               STR      R0,[R1, #+0]
    626              //pCanMsg->Id  = ((CAN->sMsgObj[1].A2R >> 2) & 0x07FF);
    627              //pCanMsg->Id |= ((u32)CAN->sMsgObj[1].A1R << 11);
    628              //pCanMsg->Id |= (((u32)CAN->sMsgObj[1].A2R & 0x0003) << 27);
    629              pCanMsg->Id = CAN->sMsgObj[1].A1R + ( ( CAN->sMsgObj[1].A2R & 0x1fff ) >> 16 );
                                                                                                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000044   1E48               LDR      R0,??CAN_BasicReceiveMessage_0+0x14  ;; 0xffffc490
   \   00000046   0088               LDRH     R0,[R0, #+0]
   \   00000048   1C4A               LDR      R2,??CAN_BasicReceiveMessage_0+0x10  ;; 0xffffc494
   \   0000004A   1288               LDRH     R2,[R2, #+0]
   \   0000004C   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000004E   000C               LSRS     R0,R0,#+16
   \   00000050   4860               STR      R0,[R1, #+4]
    630            }
    631          
    632            pCanMsg->Dlc = CAN->sMsgObj[1].MCR & 0x0F;
   \                     ??CAN_BasicReceiveMessage_4:
   \   00000052   1648               LDR      R0,??CAN_BasicReceiveMessage_0  ;; 0xffffc498
   \   00000054   0088               LDRH     R0,[R0, #+0]
   \   00000056   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000058   000F               LSRS     R0,R0,#+28
   \   0000005A   0872               STRB     R0,[R1, #+8]
    633          
    634            pCanMsg->Data[0] = (u8) CAN->sMsgObj[1].DA1R;
   \   0000005C   1948               LDR      R0,??CAN_BasicReceiveMessage_0+0x18  ;; 0xffffc49c
   \   0000005E   0088               LDRH     R0,[R0, #+0]
   \   00000060   4872               STRB     R0,[R1, #+9]
    635            pCanMsg->Data[1] = (u8)(CAN->sMsgObj[1].DA1R >> 8);
   \   00000062   1848               LDR      R0,??CAN_BasicReceiveMessage_0+0x18  ;; 0xffffc49c
   \   00000064   0088               LDRH     R0,[R0, #+0]
   \   00000066   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000068   000C               LSRS     R0,R0,#+16
   \   0000006A   000A               LSRS     R0,R0,#+8
   \   0000006C   8872               STRB     R0,[R1, #+10]
    636            pCanMsg->Data[2] = (u8) CAN->sMsgObj[1].DA2R;
   \   0000006E   1648               LDR      R0,??CAN_BasicReceiveMessage_0+0x1C  ;; 0xffffc4a0
   \   00000070   0088               LDRH     R0,[R0, #+0]
   \   00000072   C872               STRB     R0,[R1, #+11]
    637            pCanMsg->Data[3] = (u8)(CAN->sMsgObj[1].DA2R >> 8);
   \   00000074   1448               LDR      R0,??CAN_BasicReceiveMessage_0+0x1C  ;; 0xffffc4a0
   \   00000076   0088               LDRH     R0,[R0, #+0]
   \   00000078   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000007A   000C               LSRS     R0,R0,#+16
   \   0000007C   000A               LSRS     R0,R0,#+8
   \   0000007E   0873               STRB     R0,[R1, #+12]
    638            pCanMsg->Data[4] = (u8) CAN->sMsgObj[1].DB1R;
   \   00000080   1248               LDR      R0,??CAN_BasicReceiveMessage_0+0x20  ;; 0xffffc4a4
   \   00000082   0088               LDRH     R0,[R0, #+0]
   \   00000084   4873               STRB     R0,[R1, #+13]
    639            pCanMsg->Data[5] = (u8)(CAN->sMsgObj[1].DB1R >> 8);
   \   00000086   1148               LDR      R0,??CAN_BasicReceiveMessage_0+0x20  ;; 0xffffc4a4
   \   00000088   0088               LDRH     R0,[R0, #+0]
   \   0000008A   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000008C   000C               LSRS     R0,R0,#+16
   \   0000008E   000A               LSRS     R0,R0,#+8
   \   00000090   8873               STRB     R0,[R1, #+14]
    640            pCanMsg->Data[6] = (u8) CAN->sMsgObj[1].DB2R;
   \   00000092   0F48               LDR      R0,??CAN_BasicReceiveMessage_0+0x24  ;; 0xffffc4a8
   \   00000094   0088               LDRH     R0,[R0, #+0]
   \   00000096   C873               STRB     R0,[R1, #+15]
    641            pCanMsg->Data[7] = (u8)(CAN->sMsgObj[1].DB2R >> 8);
   \   00000098   0D48               LDR      R0,??CAN_BasicReceiveMessage_0+0x24  ;; 0xffffc4a8
   \   0000009A   0088               LDRH     R0,[R0, #+0]
   \   0000009C   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000009E   000C               LSRS     R0,R0,#+16
   \   000000A0   000A               LSRS     R0,R0,#+8
   \   000000A2   0874               STRB     R0,[R1, #+16]
    642          
    643            return SUCCESS;
   \   000000A4   0120               MOVS     R0,#+1
   \                     ??CAN_BasicReceiveMessage_2:
   \   000000A6   08BC               POP      {R3}
   \   000000A8   02BC               POP      {R1}
   \   000000AA   0847               BX       R1               ;; return
   \                     ??CAN_BasicReceiveMessage_0:
   \   000000AC   98C4FFFF           DC32     0xffffc498
   \   000000B0   04C4FFFF           DC32     0xffffc404
   \   000000B4   EFFF0000           DC32     0xffef
   \   000000B8   84C4FFFF           DC32     0xffffc484
   \   000000BC   94C4FFFF           DC32     0xffffc494
   \   000000C0   90C4FFFF           DC32     0xffffc490
   \   000000C4   9CC4FFFF           DC32     0xffffc49c
   \   000000C8   A0C4FFFF           DC32     0xffffc4a0
   \   000000CC   A4C4FFFF           DC32     0xffffc4a4
   \   000000D0   A8C4FFFF           DC32     0xffffc4a8
    644          }
    645          
    646          /*******************************************************************************
    647          * Function Name  : CAN_EnterInitMode                                         
    648          * Description    : Switchs the CAN into initialization mode. This function must
    649          *                  be used in conjunction with CAN_LeaveInitMode().                 
    650          * Input          : InitMask: specifies the CAN configuration in normal mode.      
    651          * Output         : None                                                      
    652          * Return         : None                                                          
    653          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    654          void CAN_EnterInitMode(u8 InitMask)
    655          {
    656            CAN->CR = InitMask | CAN_CR_INIT;
   \                     CAN_EnterInitMode:
   \   00000000   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000002   000E               LSRS     R0,R0,#+24
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0143               ORRS     R1,R1,R0
   \   00000008   024A               LDR      R2,??CAN_EnterInitMode_0  ;; 0xffffc400
   \   0000000A   1180               STRH     R1,[R2, #+0]
    657            CAN->SR = 0;					/* reset the status*/
   \   0000000C   0249               LDR      R1,??CAN_EnterInitMode_0+0x4  ;; 0xffffc404
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   0A80               STRH     R2,[R1, #+0]
    658          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??CAN_EnterInitMode_0:
   \   00000014   00C4FFFF           DC32     0xffffc400
   \   00000018   04C4FFFF           DC32     0xffffc404
    659          
    660          /*******************************************************************************
    661          * Function Name  : CAN_LeaveInitMode                                         
    662          * Description    : Leaves the initialization mode (switch into normal mode).
    663          *                  This function must be used in conjunction with CAN_EnterInitMode().  
    664          * Input          : None                                                      
    665          * Output         : None                                                      
    666          * Return         : None                                                      
    667          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    668          void CAN_LeaveInitMode(void)
    669          {
    670            CAN->CR &= ~(CAN_CR_INIT | CAN_CR_CCE);
   \                     CAN_LeaveInitMode:
   \   00000000   0348               LDR      R0,??CAN_LeaveInitMode_0  ;; 0xffffc400
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   0349               LDR      R1,??CAN_LeaveInitMode_0+0x4  ;; 0xffbe
   \   00000006   0140               ANDS     R1,R1,R0
   \   00000008   0148               LDR      R0,??CAN_LeaveInitMode_0  ;; 0xffffc400
   \   0000000A   0180               STRH     R1,[R0, #+0]
    671          }
   \   0000000C   7047               BX       LR               ;; return
   \   0000000E   C046               Nop      
   \                     ??CAN_LeaveInitMode_0:
   \   00000010   00C4FFFF           DC32     0xffffc400
   \   00000014   BEFF0000           DC32     0xffbe
    672          
    673          /*******************************************************************************
    674          * Function Name  : CAN_EnterTestMode                                         
    675          * Description    : Switchs the CAN into test mode. This function must be used in
    676          *                  conjunction with CAN_LeaveTestMode().                            
    677          * Input          : TestMask: specifies the configuration in test modes.     
    678          * Output         : None                                                      
    679          * Return         : None                                                            
    680          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    681          void CAN_EnterTestMode(u8 TestMask)
    682          {
    683            CAN->CR |= CAN_CR_TEST;
   \                     CAN_EnterTestMode:
   \   00000000   0649               LDR      R1,??CAN_EnterTestMode_0  ;; 0xffffc400
   \   00000002   0988               LDRH     R1,[R1, #+0]
   \   00000004   8022               MOVS     R2,#+128
   \   00000006   0A43               ORRS     R2,R2,R1
   \   00000008   0449               LDR      R1,??CAN_EnterTestMode_0  ;; 0xffffc400
   \   0000000A   0A80               STRH     R2,[R1, #+0]
    684            CAN->TESTR |= TestMask;
   \   0000000C   0449               LDR      R1,??CAN_EnterTestMode_0+0x4  ;; 0xffffc414
   \   0000000E   0988               LDRH     R1,[R1, #+0]
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   0143               ORRS     R1,R1,R0
   \   00000016   024A               LDR      R2,??CAN_EnterTestMode_0+0x4  ;; 0xffffc414
   \   00000018   1180               STRH     R1,[R2, #+0]
    685          }
   \   0000001A   7047               BX       LR               ;; return
   \                     ??CAN_EnterTestMode_0:
   \   0000001C   00C4FFFF           DC32     0xffffc400
   \   00000020   14C4FFFF           DC32     0xffffc414
    686          
    687          /*******************************************************************************
    688          * Function Name  : CAN_LeaveTestMode                                         
    689          * Description    : Leaves the current test mode (switch into normal mode).
    690          *                  This function must be used in conjunction with CAN_EnterTestMode().    
    691          * Input          : None                                                      
    692          * Output         : None                                                      
    693          * Return         : None                                                      
    694          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    695          void CAN_LeaveTestMode(void)
    696          {
    697            CAN->CR |= CAN_CR_TEST;
   \                     CAN_LeaveTestMode:
   \   00000000   0948               LDR      R0,??CAN_LeaveTestMode_0  ;; 0xffffc400
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   8021               MOVS     R1,#+128
   \   00000006   0143               ORRS     R1,R1,R0
   \   00000008   0748               LDR      R0,??CAN_LeaveTestMode_0  ;; 0xffffc400
   \   0000000A   0180               STRH     R1,[R0, #+0]
    698            CAN->TESTR &= ~(CAN_TESTR_LBACK | CAN_TESTR_SILENT | CAN_TESTR_BASIC);
   \   0000000C   0748               LDR      R0,??CAN_LeaveTestMode_0+0x4  ;; 0xffffc414
   \   0000000E   0088               LDRH     R0,[R0, #+0]
   \   00000010   0749               LDR      R1,??CAN_LeaveTestMode_0+0x8  ;; 0xffe3
   \   00000012   0140               ANDS     R1,R1,R0
   \   00000014   0548               LDR      R0,??CAN_LeaveTestMode_0+0x4  ;; 0xffffc414
   \   00000016   0180               STRH     R1,[R0, #+0]
    699            CAN->CR &= ~CAN_CR_TEST;
   \   00000018   0348               LDR      R0,??CAN_LeaveTestMode_0  ;; 0xffffc400
   \   0000001A   0088               LDRH     R0,[R0, #+0]
   \   0000001C   0549               LDR      R1,??CAN_LeaveTestMode_0+0xC  ;; 0xff7f
   \   0000001E   0140               ANDS     R1,R1,R0
   \   00000020   0148               LDR      R0,??CAN_LeaveTestMode_0  ;; 0xffffc400
   \   00000022   0180               STRH     R1,[R0, #+0]
    700          }
   \   00000024   7047               BX       LR               ;; return
   \   00000026   C046               Nop      
   \                     ??CAN_LeaveTestMode_0:
   \   00000028   00C4FFFF           DC32     0xffffc400
   \   0000002C   14C4FFFF           DC32     0xffffc414
   \   00000030   E3FF0000           DC32     0xffe3
   \   00000034   7FFF0000           DC32     0xff7f
    701          
    702          /*******************************************************************************
    703          * Function Name  : CAN_ReleaseTxMessage                                      
    704          * Description    : Releases the transmit message object.
    705          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                     
    706          * Output         : None                                                      
    707          * Return         : None                                                                        
    708          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    709          void CAN_ReleaseTxMessage(u32 msgobj)
    710          {
    711            CAN->sMsgObj[0].CMR = CAN_CMR_CLRINTPND | CAN_CMR_TXRQSTNEWDAT;
   \                     CAN_ReleaseTxMessage:
   \   00000000   0349               LDR      R1,??CAN_ReleaseTxMessage_0  ;; 0xffffc424
   \   00000002   0C22               MOVS     R2,#+12
   \   00000004   0A80               STRH     R2,[R1, #+0]
    712            CAN->sMsgObj[0].CRR = 1 + msgobj;
   \   00000006   0100               MOVS     R1,R0
   \   00000008   491C               ADDS     R1,R1,#+1
   \   0000000A   024A               LDR      R2,??CAN_ReleaseTxMessage_0+0x4  ;; 0xffffc420
   \   0000000C   1180               STRH     R1,[R2, #+0]
    713          }
   \   0000000E   7047               BX       LR               ;; return
   \                     ??CAN_ReleaseTxMessage_0:
   \   00000010   24C4FFFF           DC32     0xffffc424
   \   00000014   20C4FFFF           DC32     0xffffc420
    714          
    715          /*******************************************************************************
    716          * Function Name  : CAN_ReleaseRxMessage                                      
    717          * Description    : Releases the receive message object.                        
    718          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                      
    719          * Output         : None                                                      
    720          * Return         : None                                                                      
    721          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    722          void CAN_ReleaseRxMessage(u32 msgobj)
    723          {
    724            CAN->sMsgObj[1].CMR = CAN_CMR_CLRINTPND | CAN_CMR_TXRQSTNEWDAT;
   \                     CAN_ReleaseRxMessage:
   \   00000000   0349               LDR      R1,??CAN_ReleaseRxMessage_0  ;; 0xffffc484
   \   00000002   0C22               MOVS     R2,#+12
   \   00000004   0A80               STRH     R2,[R1, #+0]
    725            CAN->sMsgObj[1].CRR = 1 + msgobj;
   \   00000006   0100               MOVS     R1,R0
   \   00000008   491C               ADDS     R1,R1,#+1
   \   0000000A   024A               LDR      R2,??CAN_ReleaseRxMessage_0+0x4  ;; 0xffffc480
   \   0000000C   1180               STRH     R1,[R2, #+0]
    726          }
   \   0000000E   7047               BX       LR               ;; return
   \                     ??CAN_ReleaseRxMessage_0:
   \   00000010   84C4FFFF           DC32     0xffffc484
   \   00000014   80C4FFFF           DC32     0xffffc480
    727          
    728          /*******************************************************************************
    729          * Function Name  : CAN_IsMessageWaiting                                      
    730          * Description    : Tests the waiting status of a received message.             
    731          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                       
    732          * Output         : None                                                      
    733          * Return         : A non-zero value if the corresponding message object has  
    734          *                  received a message waiting to be copied, else 0.           
    735          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    736          u32 CAN_IsMessageWaiting(u32 msgobj)
    737          {
   \                     CAN_IsMessageWaiting:
   \   00000000   01B5               PUSH     {R0,LR}
    738            return (msgobj < 16 ? CAN->ND1R & (1 << msgobj) : CAN->ND2R & (1 << (msgobj-16)));
   \   00000002   1028               CMP      R0,#+16
   \   00000004   07D2               BCS      ??CAN_IsMessageWaiting_0
   \   00000006   0A49               LDR      R1,??CAN_IsMessageWaiting_1  ;; 0xffffc520
   \   00000008   0A88               LDRH     R2,[R1, #+0]
   \   0000000A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000000C   120C               LSRS     R2,R2,#+16
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   8140               LSLS     R1,R1,R0
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   07E0               B        ??CAN_IsMessageWaiting_2
   \                     ??CAN_IsMessageWaiting_0:
   \   00000016   0749               LDR      R1,??CAN_IsMessageWaiting_1+0x4  ;; 0xffffc524
   \   00000018   0A88               LDRH     R2,[R1, #+0]
   \   0000001A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000001C   120C               LSRS     R2,R2,#+16
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   1038               SUBS     R0,R0,#+16
   \   00000022   8140               LSLS     R1,R1,R0
   \   00000024   1140               ANDS     R1,R1,R2
   \                     ??CAN_IsMessageWaiting_2:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   08BC               POP      {R3}
   \   0000002A   02BC               POP      {R1}
   \   0000002C   0847               BX       R1               ;; return
   \   0000002E   C046               Nop      
   \                     ??CAN_IsMessageWaiting_1:
   \   00000030   20C5FFFF           DC32     0xffffc520
   \   00000034   24C5FFFF           DC32     0xffffc524
    739          }
    740          
    741          /*******************************************************************************
    742          * Function Name  : CAN_IsTransmitRequested                                   
    743          * Description    : Tests the request status of a transmitted message.          
    744          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                      
    745          * Output         : None                                                      
    746          * Return         : A non-zero value if the corresponding message is requested
    747          *                  to transmit, else 0.                                       
    748          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    749          u32 CAN_IsTransmitRequested(u32 msgobj)
    750          {
   \                     CAN_IsTransmitRequested:
   \   00000000   01B5               PUSH     {R0,LR}
    751            return (msgobj < 16 ? CAN->TXR1R & (1 << msgobj) : CAN->TXR2R & (1 << (msgobj-16)));
   \   00000002   1028               CMP      R0,#+16
   \   00000004   07D2               BCS      ??CAN_IsTransmitRequested_0
   \   00000006   0A49               LDR      R1,??CAN_IsTransmitRequested_1  ;; 0xffffc500
   \   00000008   0A88               LDRH     R2,[R1, #+0]
   \   0000000A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000000C   120C               LSRS     R2,R2,#+16
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   8140               LSLS     R1,R1,R0
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   07E0               B        ??CAN_IsTransmitRequested_2
   \                     ??CAN_IsTransmitRequested_0:
   \   00000016   0749               LDR      R1,??CAN_IsTransmitRequested_1+0x4  ;; 0xffffc504
   \   00000018   0A88               LDRH     R2,[R1, #+0]
   \   0000001A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000001C   120C               LSRS     R2,R2,#+16
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   1038               SUBS     R0,R0,#+16
   \   00000022   8140               LSLS     R1,R1,R0
   \   00000024   1140               ANDS     R1,R1,R2
   \                     ??CAN_IsTransmitRequested_2:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   08BC               POP      {R3}
   \   0000002A   02BC               POP      {R1}
   \   0000002C   0847               BX       R1               ;; return
   \   0000002E   C046               Nop      
   \                     ??CAN_IsTransmitRequested_1:
   \   00000030   00C5FFFF           DC32     0xffffc500
   \   00000034   04C5FFFF           DC32     0xffffc504
    752          }
    753          
    754          /*******************************************************************************
    755          * Function Name  : CAN_IsInterruptPending                                    
    756          * Description    : Tests the interrupt status of a message object.             
    757          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                      
    758          * Output         : None                                                      
    759          * Return         : A non-zero value if the corresponding message has an      
    760          *                  interrupt pending, else 0.                                 
    761          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    762          u32 CAN_IsInterruptPending(u32 msgobj)
    763          {
   \                     CAN_IsInterruptPending:
   \   00000000   01B5               PUSH     {R0,LR}
    764            return (msgobj < 16 ? CAN->IP1R & (1 << msgobj) : CAN->IP2R & (1 << (msgobj-16)));
   \   00000002   1028               CMP      R0,#+16
   \   00000004   07D2               BCS      ??CAN_IsInterruptPending_0
   \   00000006   0A49               LDR      R1,??CAN_IsInterruptPending_1  ;; 0xffffc540
   \   00000008   0A88               LDRH     R2,[R1, #+0]
   \   0000000A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000000C   120C               LSRS     R2,R2,#+16
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   8140               LSLS     R1,R1,R0
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   07E0               B        ??CAN_IsInterruptPending_2
   \                     ??CAN_IsInterruptPending_0:
   \   00000016   0749               LDR      R1,??CAN_IsInterruptPending_1+0x4  ;; 0xffffc544
   \   00000018   0A88               LDRH     R2,[R1, #+0]
   \   0000001A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000001C   120C               LSRS     R2,R2,#+16
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   1038               SUBS     R0,R0,#+16
   \   00000022   8140               LSLS     R1,R1,R0
   \   00000024   1140               ANDS     R1,R1,R2
   \                     ??CAN_IsInterruptPending_2:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   08BC               POP      {R3}
   \   0000002A   02BC               POP      {R1}
   \   0000002C   0847               BX       R1               ;; return
   \   0000002E   C046               Nop      
   \                     ??CAN_IsInterruptPending_1:
   \   00000030   40C5FFFF           DC32     0xffffc540
   \   00000034   44C5FFFF           DC32     0xffffc544
    765          }
    766          
    767          /*******************************************************************************
    768          * Function Name  : CAN_IsObjectValid                                         
    769          * Description    : Tests the validity of a message object (ready to use).      
    770          * Input          : - msgobj: specifies the Message object number, from 0 to 31.                      
    771          * Output         : None                                                      
    772          * Return         : A non-zero value if the corresponding message object is   
    773          *                  valid, else 0.                                             
    774          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    775          u32 CAN_IsObjectValid(u32 msgobj)
    776          {
   \                     CAN_IsObjectValid:
   \   00000000   01B5               PUSH     {R0,LR}
    777            return (msgobj < 16 ? CAN->MV1R & (1 << msgobj) : CAN->MV2R & (1 << (msgobj-16)));
   \   00000002   1028               CMP      R0,#+16
   \   00000004   07D2               BCS      ??CAN_IsObjectValid_0
   \   00000006   0A49               LDR      R1,??CAN_IsObjectValid_1  ;; 0xffffc560
   \   00000008   0A88               LDRH     R2,[R1, #+0]
   \   0000000A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000000C   120C               LSRS     R2,R2,#+16
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   8140               LSLS     R1,R1,R0
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   07E0               B        ??CAN_IsObjectValid_2
   \                     ??CAN_IsObjectValid_0:
   \   00000016   0749               LDR      R1,??CAN_IsObjectValid_1+0x4  ;; 0xffffc564
   \   00000018   0A88               LDRH     R2,[R1, #+0]
   \   0000001A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000001C   120C               LSRS     R2,R2,#+16
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   1038               SUBS     R0,R0,#+16
   \   00000022   8140               LSLS     R1,R1,R0
   \   00000024   1140               ANDS     R1,R1,R2
   \                     ??CAN_IsObjectValid_2:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   08BC               POP      {R3}
   \   0000002A   02BC               POP      {R1}
   \   0000002C   0847               BX       R1               ;; return
   \   0000002E   C046               Nop      
   \                     ??CAN_IsObjectValid_1:
   \   00000030   60C5FFFF           DC32     0xffffc560
   \   00000034   64C5FFFF           DC32     0xffffc564
    778          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0CC4FFFF           DC32     0xffffc40c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   18C4FFFF           DC32     0xffffc418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   80C4FFFF           DC32     0xffffc480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   20C4FFFF           DC32     0xffffc420
    779          /******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     CAN_BasicReceiveMessage      8
     CAN_BasicSendMessage         8
     CAN_DeInit                   8
     CAN_EnterInitMode            0
     CAN_EnterTestMode            0
     CAN_Init                     8
     CAN_InvalidateAllMsgObj      8
     CAN_IsInterruptPending       8
     CAN_IsMessageWaiting         8
     CAN_IsObjectValid            8
     CAN_IsTransmitRequested      8
     CAN_LeaveInitMode            0
     CAN_LeaveTestMode            0
     CAN_ReceiveMessage          16
     CAN_ReleaseMessage          16
     CAN_ReleaseRxMessage         0
     CAN_ReleaseTxMessage         0
     CAN_SendMessage              8
     CAN_SetBitrate               0
     CAN_SetRxMsgObj             32
     CAN_SetTiming                8
     CAN_SetTxMsgObj             16
     CAN_SetUnusedMsgObj         16
     CAN_StructInit               0
     CAN_WaitEndOfTx              8
     GetFreeIF                    8


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     CanTimings                20
     CAN_DeInit                28
     CAN_Init                  38
     CAN_StructInit            16
     CAN_SetBitrate            24
     CAN_SetTiming             66
     GetFreeIF                 34
     CAN_SetUnusedMsgObj      162
     CAN_SetTxMsgObj          204
     CAN_SetRxMsgObj          340
     CAN_InvalidateAllMsgObj   30
     CAN_ReleaseMessage        60
     CAN_SendMessage          264
     CAN_ReceiveMessage       260
     CAN_WaitEndOfTx           40
     CAN_BasicSendMessage     248
     CAN_BasicReceiveMessage  212
     CAN_EnterInitMode         28
     CAN_LeaveInitMode         24
     CAN_EnterTestMode         36
     CAN_LeaveTestMode         56
     CAN_ReleaseTxMessage      24
     CAN_ReleaseRxMessage      24
     CAN_IsMessageWaiting      56
     CAN_IsTransmitRequested   56
     CAN_IsInterruptPending    56
     CAN_IsObjectValid         56
     ??DataTable2               4
     ??DataTable3               4
     ??DataTable5               4
     ??DataTable29              4

 
    20 bytes in section .data
 2 458 bytes in section .text
 
 2 458 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: 2
