
ledswitch.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001ec  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  40000000  000001ec  00010000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  40000000  000001ec  00010000  2**0
                  ALLOC
  3 .stack        00000400  40000000  40000000  00010000  2**0
                  ALLOC
  4 .comment      00000012  00000000  00000000  00010000  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000040  00000000  00000000  00010018  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  00010058  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000113  00000000  00000000  00010073  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000009c  00000000  00000000  00010186  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000000c6  00000000  00000000  00010222  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000040  00000000  00000000  000102e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000006e  00000000  00000000  00010328  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000020  00000000  00000000  00010396  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xbfffec30>
        ldr   pc,_fiq                   // FIQ - _fiq
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <F_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
  50:	e59f0098 	ldr	r0, [pc, #152]	; f0 <.text+0xf0>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
  54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
  58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
  5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
  60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
  64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
  68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
  6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
  70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
  74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
  78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
  7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
  80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
  84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
  88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
  8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
  90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
  94:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
  98:	e59f1054 	ldr	r1, [pc, #84]	; f4 <.text+0xf4>
        ldr   r2,=_data                 // -> data start
  9c:	e59f2054 	ldr	r2, [pc, #84]	; f8 <.text+0xf8>
        ldr   r3,=_edata                // -> end of data
  a0:	e59f3054 	ldr	r3, [pc, #84]	; fc <.text+0xfc>
1:      cmp   r2,r3                     // check if data to move
  a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
  a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
  ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
  b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
  b4:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
  b8:	e59f1040 	ldr	r1, [pc, #64]	; 100 <.text+0x100>
        ldr   r2,=__bss_end__           // -> bss end
  bc:	e59f2040 	ldr	r2, [pc, #64]	; 104 <.text+0x104>
2:      cmp   r1,r2                     // check if data to clear
  c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
  c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
  c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  cc:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
  d0:	e1a01000 	mov	r1, r0
        mov   r2,r0
  d4:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
  d8:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
  dc:	e1a07000 	mov	r7, r0
        ldr   r10,=main
  e0:	e59fa020 	ldr	sl, [pc, #32]	; 108 <.text+0x108>
        mov   lr,pc
  e4:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
  e8:	e12fff1a 	bx	sl

000000ec <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:
#if 0
// Disable interrupts, then force a hardware reset by driving P23 low
// -------------------------------------------------------------------
        mrs   r0,cpsr                   // get PSR
        orr   r0,r0,#I_BIT|F_BIT        // disable IRQ and FIQ
        msr   cpsr,r0                   // set up status register

        ldr   r1,=(PS_BASE)             // PS Base Address
        ldr   r0,=(PS_PIO)              // PIO Module
        str   r0,[r1,#PS_PCER_OFF]      // enable its clock
        ldr   r1,=(PIO_BASE)            // PIO Base Address
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
  ec:	eafffffe 	b	ec <_reset>
  f0:	40000400 	andmi	r0, r0, r0, lsl #8
  f4:	000001ec 	andeq	r0, r0, ip, ror #3
  f8:	40000000 	andmi	r0, r0, r0
  fc:	40000000 	andmi	r0, r0, r0
 100:	40000000 	andmi	r0, r0, r0
 104:	40000000 	andmi	r0, r0, r0
 108:	00000158 	andeq	r0, r0, r8, asr r1

0000010c <delay>:
	IOCLR1 = (1<<LEDPIN);		// clr Bit = LED off (active high)
}

static void delay(void)
{
 10c:	e24dd008 	sub	sp, sp, #8	; 0x8
	volatile int i,j;

	for (i=0;i<100;i++) {
 110:	e3a03000 	mov	r3, #0	; 0x0
 114:	ea000009 	b	140 <delay+0x34>
		for (j=0;j<1000;j++);
 118:	e3a03000 	mov	r3, #0	; 0x0
 11c:	ea000001 	b	128 <delay+0x1c>
 120:	e59d3000 	ldr	r3, [sp]
 124:	e2833001 	add	r3, r3, #1	; 0x1
 128:	e58d3000 	str	r3, [sp]
 12c:	e59d3000 	ldr	r3, [sp]
 130:	e3530ffa 	cmp	r3, #1000	; 0x3e8
 134:	bafffff9 	blt	120 <delay+0x14>
 138:	e59d3004 	ldr	r3, [sp, #4]
 13c:	e2833001 	add	r3, r3, #1	; 0x1
 140:	e58d3004 	str	r3, [sp, #4]
 144:	e59d3004 	ldr	r3, [sp, #4]
 148:	e3530063 	cmp	r3, #99	; 0x63
 14c:	dafffff1 	ble	118 <delay+0xc>
	}
}
 150:	e28dd008 	add	sp, sp, #8	; 0x8
 154:	e12fff1e 	bx	lr

00000158 <main>:
 
int main(void)
{
 158:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int i;
	
	MAMCR = 2;		// MAM functions fully enabled (?)
 15c:	e59f3074 	ldr	r3, [pc, #116]	; 1d8 <.text+0x1d8>
 160:	e3a01002 	mov	r1, #2	; 0x2
 164:	e5c31000 	strb	r1, [r3]
 168:	e59f206c 	ldr	r2, [pc, #108]	; 1dc <.text+0x1dc>
 16c:	e5923000 	ldr	r3, [r2]
 170:	e38338ff 	orr	r3, r3, #16711680	; 0xff0000
 174:	e4023010 	str	r3, [r2], #-16
 178:	e5923000 	ldr	r3, [r2]
 17c:	e3c33901 	bic	r3, r3, #16384	; 0x4000
 180:	e5823000 	str	r3, [r2]
 184:	e59f3054 	ldr	r3, [pc, #84]	; 1e0 <.text+0x1e0>
 188:	e5831000 	str	r1, [r3]
 18c:	e3a0500a 	mov	r5, #10	; 0xa
	
	ledInit();
	
	i=0;
	
	while ( i < 10 ) {
		IOCLR1 = ( 1 << LEDPIN );			//  LED off
 190:	e59f3048 	ldr	r3, [pc, #72]	; 1e0 <.text+0x1e0>
 194:	e3a04002 	mov	r4, #2	; 0x2
 198:	e5834000 	str	r4, [r3]
		delay();
 19c:	ebffffda 	bl	10c <delay>
		IOSET1 = ( 1 << LEDPIN );			//  LED on
 1a0:	e59f303c 	ldr	r3, [pc, #60]	; 1e4 <.text+0x1e4>
 1a4:	e5834000 	str	r4, [r3]
		delay();
 1a8:	ebffffd7 	bl	10c <delay>
 1ac:	e2555001 	subs	r5, r5, #1	; 0x1
 1b0:	1afffff6 	bne	190 <main+0x38>
		i++;
	}
	
	while ( 1 ) {
	
		if ( IOPIN0 & (1 << SWPIN ) ) {	// true if button released (active low)
 1b4:	e59f302c 	ldr	r3, [pc, #44]	; 1e8 <.text+0x1e8>
 1b8:	e5933000 	ldr	r3, [r3]
 1bc:	e3130901 	tst	r3, #16384	; 0x4000
			IOCLR1 = ( 1 << LEDPIN );		// LED off
 1c0:	159f3018 	ldrne	r3, [pc, #24]	; 1e0 <.text+0x1e0>
		}
		else {
			IOSET1 = ( 1 << LEDPIN );		// LED on
 1c4:	059f3018 	ldreq	r3, [pc, #24]	; 1e4 <.text+0x1e4>
 1c8:	13a02002 	movne	r2, #2	; 0x2
 1cc:	03a02002 	moveq	r2, #2	; 0x2
 1d0:	e5832000 	str	r2, [r3]
 1d4:	eafffff6 	b	1b4 <main+0x5c>
 1d8:	e01fc000 	ands	ip, pc, r0
 1dc:	e0028018 	and	r8, r2, r8, lsl r0
 1e0:	e002801c 	and	r8, r2, ip, lsl r0
 1e4:	e0028014 	and	r8, r2, r4, lsl r0
 1e8:	e0028000 	and	r8, r2, r0
