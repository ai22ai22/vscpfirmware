
Blinky.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000554  40000000  40000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  40000554  40000554  00008554  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  40000554  40000554  00008554  2**2
                  ALLOC
  3 .stack        00000400  40000600  40000600  00008554  2**0
                  ALLOC
  4 .stab         00000a14  00000000  00000000  00008554  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000003a7  00000000  00000000  00008f68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000051  00000000  00000000  0000930f  2**0
                  CONTENTS, READONLY
Disassembly of section .text:

40000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
40000000:	ea000012 	b	40000050 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
40000004:	e59ff014 	ldr	pc, [pc, #20]	; 40000020 <_undf>
        ldr   pc,_swi                   // SWI - _swi
40000008:	e59ff014 	ldr	pc, [pc, #20]	; 40000024 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
4000000c:	e59ff014 	ldr	pc, [pc, #20]	; 40000028 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
40000010:	e59ff014 	ldr	pc, [pc, #20]	; 4000002c <_dabt>
        nop                             // reserved
40000014:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
40000018:	e51ffff0 	ldr	pc, [pc, #-4080]	; 3ffff030 <STACK_SIZE+0x3fffec30>
        ldr   pc,_fiq                   // FIQ - _fiq
4000001c:	e59ff010 	ldr	pc, [pc, #16]	; 40000034 <_fiq>

40000020 <_undf>:
40000020:	40000038 	andmi	r0, r0, r8, lsr r0

40000024 <_swi>:
40000024:	4000003c 	andmi	r0, r0, ip, lsr r0

40000028 <_pabt>:
40000028:	40000040 	andmi	r0, r0, r0, asr #32

4000002c <_dabt>:
4000002c:	40000044 	andmi	r0, r0, r4, asr #32

40000030 <_irq>:
40000030:	40000048 	andmi	r0, r0, r8, asr #32

40000034 <_fiq>:
40000034:	4000004c 	andmi	r0, r0, ip, asr #32

40000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
40000038:	eafffffe 	b	40000038 <__undf>

4000003c <__swi>:
__swi:  b     .                         // SWI
4000003c:	eafffffe 	b	4000003c <__swi>

40000040 <__pabt>:
__pabt: b     .                         // program abort
40000040:	eafffffe 	b	40000040 <__pabt>

40000044 <__dabt>:
__dabt: b     .                         // data abort
40000044:	eafffffe 	b	40000044 <__dabt>

40000048 <__irq>:
__irq:  b     .                         // IRQ
40000048:	eafffffe 	b	40000048 <__irq>

4000004c <__fiq>:
__fiq:  b     .                         // FIQ
4000004c:	eafffffe 	b	4000004c <__fiq>

40000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
40000050:	e59f007c 	ldr	r0, [pc, #124]	; 400000d4 <.text+0xd4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
40000054:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
40000058:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
4000005c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
40000060:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
40000064:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
40000068:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
4000006c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
40000070:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
40000074:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
40000078:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
4000007c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
40000080:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
40000084:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
40000088:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
4000008c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
40000090:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
40000094:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
        ldr   r2,=_data                 // -> data start
        ldr   r3,=_edata                // -> end of data
1:      cmp   r2,r3                     // check if data to move
        ldrlo r0,[r1],#4                // copy it
        strlo r0,[r2],#4
        blo   1b                        // loop until done
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
40000098:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
4000009c:	e59f1034 	ldr	r1, [pc, #52]	; 400000d8 <.text+0xd8>
        ldr   r2,=__bss_end__           // -> bss end
400000a0:	e59f2034 	ldr	r2, [pc, #52]	; 400000dc <.text+0xdc>
2:      cmp   r1,r2                     // check if data to clear
400000a4:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
400000a8:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
400000ac:	3afffffc 	bcc	400000a4 <_mainCRTStartup+0x54>

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
400000b0:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
400000b4:	e1a01000 	mov	r1, r0
        mov   r2,r0
400000b8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
400000bc:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
400000c0:	e1a07000 	mov	r7, r0
        ldr   r10,=main
400000c4:	e59fa014 	ldr	sl, [pc, #20]	; 400000e0 <.text+0xe0>
        mov   lr,pc
400000c8:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
400000cc:	e12fff1a 	bx	sl

400000d0 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:
#if 0
// Disable interrupts, then force a hardware reset by driving P23 low
// -------------------------------------------------------------------
        mrs   r0,cpsr                   // get PSR
        orr   r0,r0,#I_BIT|F_BIT        // disable IRQ and FIQ
        msr   cpsr,r0                   // set up status register

        ldr   r1,=(PS_BASE)             // PS Base Address
        ldr   r0,=(PS_PIO)              // PIO Module
        str   r0,[r1,#PS_PCER_OFF]      // enable its clock
        ldr   r1,=(PIO_BASE)            // PIO Base Address
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
400000d0:	eafffffe 	b	400000d0 <_reset>
400000d4:	40000a00 	andmi	r0, r0, r0, lsl #20
400000d8:	40000554 	andmi	r0, r0, r4, asr r5
400000dc:	40000558 	andmi	r0, r0, r8, asr r5
400000e0:	40000488 	andmi	r0, r0, r8, lsl #9

400000e4 <tc0_cmp>:
void __attribute__ ((interrupt("IRQ"))) tc0_cmp(void) ;

/* Timer0 Compare-Match Interrupt Handler (ISR) */
void tc0_cmp(void) 
{
400000e4:	e52dc004 	str	ip, [sp, #-4]!
400000e8:	e1a0c00d 	mov	ip, sp
400000ec:	e92dd80c 	stmdb	sp!, {r2, r3, fp, ip, lr, pc}
400000f0:	e24cb004 	sub	fp, ip, #4	; 0x4
	timeval++;
400000f4:	e59f303c 	ldr	r3, [pc, #60]	; 40000138 <.text+0x138>
400000f8:	e5933000 	ldr	r3, [r3]
400000fc:	e2832001 	add	r2, r3, #1	; 0x1
40000100:	e59f3030 	ldr	r3, [pc, #48]	; 40000138 <.text+0x138>
40000104:	e5832000 	str	r2, [r3]
	T0IR = TxIR_MR0_FLAG; 	// Clear interrupt flag by writing 1 to Bit 0
40000108:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000010c:	e2833901 	add	r3, r3, #16384	; 0x4000
40000110:	e3a02001 	mov	r2, #1	; 0x1
40000114:	e5832000 	str	r2, [r3]
	VICVectAddr = 0;       	// Acknowledge Interrupt (rough?)
40000118:	e3e03d3f 	mvn	r3, #4032	; 0xfc0
4000011c:	e243300f 	sub	r3, r3, #15	; 0xf
40000120:	e3a02000 	mov	r2, #0	; 0x0
40000124:	e5832000 	str	r2, [r3]
}
40000128:	e24bd014 	sub	sp, fp, #20	; 0x14
4000012c:	e89d680c 	ldmia	sp, {r2, r3, fp, sp, lr}
40000130:	e8bd1000 	ldmia	sp!, {ip}
40000134:	e25ef004 	subs	pc, lr, #4	; 0x4
40000138:	40000554 	andmi	r0, r0, r4, asr r5

4000013c <init_timer>:

/* Setup Timer0 Compare-Match Interrupt         */
/* no prescaler timer runs at cclk = FOSC*PLL_M */
void init_timer (void) {
4000013c:	e1a0c00d 	mov	ip, sp
40000140:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000144:	e24cb004 	sub	fp, ip, #4	; 0x4
	
	T0MR0 = ((FOSC*PLL_M)/(1000/10))-1;     		// Compare-hit at 10mSec (-1 reset "tick")
40000148:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
4000014c:	e2822901 	add	r2, r2, #16384	; 0x4000
40000150:	e2822018 	add	r2, r2, #24	; 0x18
40000154:	e3a03a75 	mov	r3, #479232	; 0x75000
40000158:	e2833fbf 	add	r3, r3, #764	; 0x2fc
4000015c:	e2833003 	add	r3, r3, #3	; 0x3
40000160:	e5823000 	str	r3, [r2]
	T0MCR = TxMCR_INT_ON_MR0 | TxMCR_RESET_ON_MR0; 	// Interrupt and Reset on MR0
40000164:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000168:	e2833901 	add	r3, r3, #16384	; 0x4000
4000016c:	e2833014 	add	r3, r3, #20	; 0x14
40000170:	e3a02003 	mov	r2, #3	; 0x3
40000174:	e5832000 	str	r2, [r3]
	T0TCR = TxTCR_COUNTER_ENABLE;            		// Timer0 Enable
40000178:	e3a03901 	mov	r3, #16384	; 0x4000
4000017c:	e283324e 	add	r3, r3, #-536870908	; 0xe0000004
40000180:	e3a02001 	mov	r2, #1	; 0x1
40000184:	e5832000 	str	r2, [r3]

	VICVectAddr0 = (unsigned long)tc0_cmp;   // set interrupt vector in 0
40000188:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
4000018c:	e1a039c3 	mov	r3, r3, asr #19
40000190:	e59f2024 	ldr	r2, [pc, #36]	; 400001bc <.text+0x1bc>
40000194:	e5832000 	str	r2, [r3]
	VICVectCntl0 = VICVectCntl0_ENABLE | VIC_Channel_Timer0; // use it for Timer 0 Interrupt:
40000198:	e3a03209 	mov	r3, #-1879048192	; 0x90000000
4000019c:	e1a039c3 	mov	r3, r3, asr #19
400001a0:	e3a02024 	mov	r2, #36	; 0x24
400001a4:	e5832000 	str	r2, [r3]
	VICIntEnable = (1<<VIC_Channel_Timer0);    // Enable Timer0 Interrupt
400001a8:	e3e03efe 	mvn	r3, #4064	; 0xfe0
400001ac:	e243300f 	sub	r3, r3, #15	; 0xf
400001b0:	e3a02010 	mov	r2, #16	; 0x10
400001b4:	e5832000 	str	r2, [r3]
}
400001b8:	e89da800 	ldmia	sp, {fp, sp, pc}
400001bc:	400000e4 	andmi	r0, r0, r4, ror #1

400001c0 <enableIRQ>:
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
}

unsigned enableIRQ(void)
{
400001c0:	e1a0c00d 	mov	ip, sp
400001c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
400001c8:	e24cb004 	sub	fp, ip, #4	; 0x4
400001cc:	e24dd004 	sub	sp, sp, #4	; 0x4
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
400001d0:	eb000010 	bl	40000218 <asm_get_cpsr>
400001d4:	e1a03000 	mov	r3, r0
400001d8:	e50b3010 	str	r3, [fp, #-16]
  asm_set_cpsr(_cpsr & ~IRQ_MASK);
400001dc:	e51b3010 	ldr	r3, [fp, #-16]
400001e0:	e3c33080 	bic	r3, r3, #128	; 0x80
400001e4:	e1a00003 	mov	r0, r3
400001e8:	eb000002 	bl	400001f8 <asm_set_cpsr>
  return _cpsr;
400001ec:	e51b3010 	ldr	r3, [fp, #-16]
}
400001f0:	e1a00003 	mov	r0, r3
400001f4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

400001f8 <asm_set_cpsr>:
400001f8:	e1a0c00d 	mov	ip, sp
400001fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000200:	e24cb004 	sub	fp, ip, #4	; 0x4
40000204:	e24dd004 	sub	sp, sp, #4	; 0x4
40000208:	e50b0010 	str	r0, [fp, #-16]
4000020c:	e51b3010 	ldr	r3, [fp, #-16]
40000210:	e129f003 	msr	CPSR_fc, r3
40000214:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

40000218 <asm_get_cpsr>:
40000218:	e1a0c00d 	mov	ip, sp
4000021c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000220:	e24cb004 	sub	fp, ip, #4	; 0x4
40000224:	e24dd004 	sub	sp, sp, #4	; 0x4
40000228:	e10f3000 	mrs	r3, CPSR
4000022c:	e50b3010 	str	r3, [fp, #-16]
40000230:	e51b3010 	ldr	r3, [fp, #-16]
40000234:	e1a00003 	mov	r0, r3
40000238:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

4000023c <disableIRQ>:

unsigned disableIRQ(void)
{
4000023c:	e1a0c00d 	mov	ip, sp
40000240:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000244:	e24cb004 	sub	fp, ip, #4	; 0x4
40000248:	e24dd004 	sub	sp, sp, #4	; 0x4
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
4000024c:	ebfffff1 	bl	40000218 <asm_get_cpsr>
40000250:	e1a03000 	mov	r3, r0
40000254:	e50b3010 	str	r3, [fp, #-16]
  asm_set_cpsr(_cpsr | IRQ_MASK);
40000258:	e51b3010 	ldr	r3, [fp, #-16]
4000025c:	e3833080 	orr	r3, r3, #128	; 0x80
40000260:	e1a00003 	mov	r0, r3
40000264:	ebffffe3 	bl	400001f8 <asm_set_cpsr>
  return _cpsr;
40000268:	e51b3010 	ldr	r3, [fp, #-16]
}
4000026c:	e1a00003 	mov	r0, r3
40000270:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

40000274 <restoreIRQ>:

unsigned restoreIRQ(unsigned oldCPSR)
{
40000274:	e1a0c00d 	mov	ip, sp
40000278:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
4000027c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000280:	e24dd008 	sub	sp, sp, #8	; 0x8
40000284:	e50b0014 	str	r0, [fp, #-20]
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
40000288:	ebffffe2 	bl	40000218 <asm_get_cpsr>
4000028c:	e1a03000 	mov	r3, r0
40000290:	e50b3010 	str	r3, [fp, #-16]
  asm_set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
40000294:	e51b3010 	ldr	r3, [fp, #-16]
40000298:	e3c32080 	bic	r2, r3, #128	; 0x80
4000029c:	e51b3014 	ldr	r3, [fp, #-20]
400002a0:	e2033080 	and	r3, r3, #128	; 0x80
400002a4:	e1823003 	orr	r3, r2, r3
400002a8:	e1a00003 	mov	r0, r3
400002ac:	ebffffd1 	bl	400001f8 <asm_set_cpsr>
  return _cpsr;
400002b0:	e51b3010 	ldr	r3, [fp, #-16]
}
400002b4:	e1a00003 	mov	r0, r3
400002b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
400002bc:	e89da800 	ldmia	sp, {fp, sp, pc}

400002c0 <systemInit>:
#define WAIT100MS  10
#define WAIT1S     100

static void systemInit(void)
{
400002c0:	e1a0c00d 	mov	ip, sp
400002c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
400002c8:	e24cb004 	sub	fp, ip, #4	; 0x4
	// --- enable and connect the PLL (Phase Locked Loop) ---
	// a. set multiplier and divider
	PLLCFG = MSEL | (1<<PSEL1) | (0<<PSEL0);
400002cc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400002d0:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400002d4:	e2833084 	add	r3, r3, #132	; 0x84
400002d8:	e3a02043 	mov	r2, #67	; 0x43
400002dc:	e5c32000 	strb	r2, [r3]
	// b. enable PLL
	PLLCON = (1<<PLLE);
400002e0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400002e4:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400002e8:	e2833080 	add	r3, r3, #128	; 0x80
400002ec:	e3a02001 	mov	r2, #1	; 0x1
400002f0:	e5c32000 	strb	r2, [r3]
	// c. feed sequence
	PLLFEED = PLL_FEED1;
400002f4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400002f8:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400002fc:	e283308c 	add	r3, r3, #140	; 0x8c
40000300:	e3e02055 	mvn	r2, #85	; 0x55
40000304:	e5c32000 	strb	r2, [r3]
	PLLFEED = PLL_FEED2;
40000308:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000030c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000310:	e283308c 	add	r3, r3, #140	; 0x8c
40000314:	e3a02055 	mov	r2, #85	; 0x55
40000318:	e5c32000 	strb	r2, [r3]
	
	// d. wait for PLL lock (PLOCK bit is set if locked)
	while ( !( PLLSTAT & ( 1 << PLOCK ) ) );
4000031c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000320:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000324:	e2833088 	add	r3, r3, #136	; 0x88
40000328:	e1d330b0 	ldrh	r3, [r3]
4000032c:	e1a03803 	mov	r3, r3, lsl #16
40000330:	e1a03823 	mov	r3, r3, lsr #16
40000334:	e1a03523 	mov	r3, r3, lsr #10
40000338:	e2033001 	and	r3, r3, #1	; 0x1
4000033c:	e3530000 	cmp	r3, #0	; 0x0
40000340:	0afffff5 	beq	4000031c <systemInit+0x5c>
	
	// e. connect (and enable) PLL
	PLLCON = (1<<PLLE) | (1<<PLLC);
40000344:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000348:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
4000034c:	e2833080 	add	r3, r3, #128	; 0x80
40000350:	e3a02003 	mov	r2, #3	; 0x3
40000354:	e5c32000 	strb	r2, [r3]
	
	// f. feed sequence
	PLLFEED = PLL_FEED1;
40000358:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000035c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000360:	e283308c 	add	r3, r3, #140	; 0x8c
40000364:	e3e02055 	mvn	r2, #85	; 0x55
40000368:	e5c32000 	strb	r2, [r3]
	PLLFEED = PLL_FEED2;
4000036c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000370:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000374:	e283308c 	add	r3, r3, #140	; 0x8c
40000378:	e3a02055 	mov	r2, #85	; 0x55
4000037c:	e5c32000 	strb	r2, [r3]
	
	// --- setup and enable the MAM (Memory Accelerator Module) ---
	// a. start change by turning of the MAM (redundant)
	MAMCR = 0;	
40000380:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000384:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000388:	e3a02000 	mov	r2, #0	; 0x0
4000038c:	e5c32000 	strb	r2, [r3]
	// b. set MAM-Fetch cycle to 3 cclk as recommended for >40MHz
	MAMTIM = MAM_FETCH;
40000390:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
40000394:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000398:	e3a02003 	mov	r2, #3	; 0x3
4000039c:	e5c32000 	strb	r2, [r3]
	// c. enable MAM 
	MAMCR = MAM_MODE;
400003a0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003a4:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400003a8:	e3a02002 	mov	r2, #2	; 0x2
400003ac:	e5c32000 	strb	r2, [r3]

	// --- set VPB speed ---
	VPBDIV = VPBDIV_VAL;
400003b0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003b4:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400003b8:	e2833c01 	add	r3, r3, #256	; 0x100
400003bc:	e3a02001 	mov	r2, #1	; 0x1
400003c0:	e5c32000 	strb	r2, [r3]

    // --- map INT-vector ---
	#if defined(RAM_RUN)
	  MEMMAP = MEMMAP_USER_RAM_MODE;
400003c4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003c8:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400003cc:	e2833040 	add	r3, r3, #64	; 0x40
400003d0:	e3a02002 	mov	r2, #2	; 0x2
400003d4:	e5c32000 	strb	r2, [r3]
	#elif defined(ROM_RUN)
	  MEMMAP = MEMMAP_USER_FLASH_MODE;
	#else
	#error RUN_MODE not defined!
	#endif
}
400003d8:	e89da800 	ldmia	sp, {fp, sp, pc}

400003dc <gpioInit>:

static void gpioInit(void)
{
400003dc:	e1a0c00d 	mov	ip, sp
400003e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
400003e4:	e24cb004 	sub	fp, ip, #4	; 0x4
	IODIR1 |= 0xff0000;			// define LED-Pins as output
400003e8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
400003ec:	e282290a 	add	r2, r2, #163840	; 0x28000
400003f0:	e2822018 	add	r2, r2, #24	; 0x18
400003f4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003f8:	e283390a 	add	r3, r3, #163840	; 0x28000
400003fc:	e2833018 	add	r3, r3, #24	; 0x18
40000400:	e5933000 	ldr	r3, [r3]
40000404:	e38338ff 	orr	r3, r3, #16711680	; 0xff0000
40000408:	e5823000 	str	r3, [r2]
	IODIR0 &= ~(1<<SWPIN);		// define Switch-Pin as input	
4000040c:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
40000410:	e282290a 	add	r2, r2, #163840	; 0x28000
40000414:	e3a0328e 	mov	r3, #-536870904	; 0xe0000008
40000418:	e283390a 	add	r3, r3, #163840	; 0x28000
4000041c:	e5933000 	ldr	r3, [r3]
40000420:	e3c33901 	bic	r3, r3, #16384	; 0x4000
40000424:	e5823000 	str	r3, [r2]
	IOCLR1 = (1<<LEDPIN);		// clr Bit = LED off (active high)
40000428:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000042c:	e283390a 	add	r3, r3, #163840	; 0x28000
40000430:	e283301c 	add	r3, r3, #28	; 0x1c
40000434:	e3a02802 	mov	r2, #131072	; 0x20000
40000438:	e5832000 	str	r2, [r3]
}
4000043c:	e89da800 	ldmia	sp, {fp, sp, pc}

40000440 <wait>:

static void wait (unsigned long delay) 
{
40000440:	e1a0c00d 	mov	ip, sp
40000444:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000448:	e24cb004 	sub	fp, ip, #4	; 0x4
4000044c:	e24dd008 	sub	sp, sp, #8	; 0x8
40000450:	e50b0014 	str	r0, [fp, #-20]
	unsigned long i;

	i = timeval + delay;
40000454:	e59f3028 	ldr	r3, [pc, #40]	; 40000484 <.text+0x484>
40000458:	e5932000 	ldr	r2, [r3]
4000045c:	e51b3014 	ldr	r3, [fp, #-20]
40000460:	e0823003 	add	r3, r2, r3
40000464:	e50b3010 	str	r3, [fp, #-16]
	while ( i != timeval);           
40000468:	e59f3014 	ldr	r3, [pc, #20]	; 40000484 <.text+0x484>
4000046c:	e5932000 	ldr	r2, [r3]
40000470:	e51b3010 	ldr	r3, [fp, #-16]
40000474:	e1530002 	cmp	r3, r2
40000478:	1afffffa 	bne	40000468 <wait+0x28>
}
4000047c:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000480:	e89da800 	ldmia	sp, {fp, sp, pc}
40000484:	40000554 	andmi	r0, r0, r4, asr r5

40000488 <main>:

int main(void) 
{
40000488:	e1a0c00d 	mov	ip, sp
4000048c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
40000490:	e24cb004 	sub	fp, ip, #4	; 0x4
	gpioInit();  
40000494:	ebffffd0 	bl	400003dc <gpioInit>
	
	IOSET1 = LEDMASK; 		// enable LED - "life sign"
40000498:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000049c:	e283390a 	add	r3, r3, #163840	; 0x28000
400004a0:	e2833014 	add	r3, r3, #20	; 0x14
400004a4:	e3a02802 	mov	r2, #131072	; 0x20000
400004a8:	e5832000 	str	r2, [r3]

	systemInit();			// PLL, MAM etc.
400004ac:	ebffff83 	bl	400002c0 <systemInit>
	
	init_timer();
400004b0:	ebffff21 	bl	4000013c <init_timer>
	
	enableIRQ(); 
400004b4:	ebffff41 	bl	400001c0 <enableIRQ>
	
	wait(WAIT1S);
400004b8:	e3a00064 	mov	r0, #100	; 0x64
400004bc:	ebffffdf 	bl	40000440 <wait>
	IOCLR1 = LEDMASK; 		// disable LED
400004c0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400004c4:	e283390a 	add	r3, r3, #163840	; 0x28000
400004c8:	e283301c 	add	r3, r3, #28	; 0x1c
400004cc:	e3a02802 	mov	r2, #131072	; 0x20000
400004d0:	e5832000 	str	r2, [r3]
	wait(WAIT1S);
400004d4:	e3a00064 	mov	r0, #100	; 0x64
400004d8:	ebffffd8 	bl	40000440 <wait>
400004dc:	eaffffff 	b	400004e0 <main+0x58>

	while(1) {
		if ( IOPIN0 & (1<<SWPIN ) ) {	// true if button released (active low)
400004e0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400004e4:	e283390a 	add	r3, r3, #163840	; 0x28000
400004e8:	e5933000 	ldr	r3, [r3]
400004ec:	e1a03723 	mov	r3, r3, lsr #14
400004f0:	e2033001 	and	r3, r3, #1	; 0x1
400004f4:	e20330ff 	and	r3, r3, #255	; 0xff
400004f8:	e3530000 	cmp	r3, #0	; 0x0
400004fc:	0a000005 	beq	40000518 <main+0x90>
			IOSET1 = LEDMASK; 			// enable LED
40000500:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000504:	e283390a 	add	r3, r3, #163840	; 0x28000
40000508:	e2833014 	add	r3, r3, #20	; 0x14
4000050c:	e3a02802 	mov	r2, #131072	; 0x20000
40000510:	e5832000 	str	r2, [r3]
40000514:	eafffff1 	b	400004e0 <main+0x58>
		} 
		else {
		  IOCLR1 = LEDMASK; 	// disable LED
40000518:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000051c:	e283390a 	add	r3, r3, #163840	; 0x28000
40000520:	e283301c 	add	r3, r3, #28	; 0x1c
40000524:	e3a02802 	mov	r2, #131072	; 0x20000
40000528:	e5832000 	str	r2, [r3]
		  wait(WAIT100MS);
4000052c:	e3a0000a 	mov	r0, #10	; 0xa
40000530:	ebffffc2 	bl	40000440 <wait>
		  IOSET1 = LEDMASK; 	// enable LED
40000534:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000538:	e283390a 	add	r3, r3, #163840	; 0x28000
4000053c:	e2833014 	add	r3, r3, #20	; 0x14
40000540:	e3a02802 	mov	r2, #131072	; 0x20000
40000544:	e5832000 	str	r2, [r3]
		  wait(WAIT100MS);
40000548:	e3a0000a 	mov	r0, #10	; 0xa
4000054c:	ebffffbb 	bl	40000440 <wait>
40000550:	eaffffe2 	b	400004e0 <main+0x58>
