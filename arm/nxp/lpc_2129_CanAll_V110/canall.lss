
canall.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000844  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000032c  40000000  40000000  00008844  2**2
                  ALLOC
  2 .stack        00000400  40000400  40000400  00008844  2**0
                  ALLOC
  3 .comment      00000051  00000000  00000000  00008844  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000080  00000000  00000000  00008898  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000014c  00000000  00000000  00008918  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000619  00000000  00000000  00008a64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000385  00000000  00000000  0000907d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000293  00000000  00000000  00009402  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000164  00000000  00000000  00009698  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000024c  00000000  00000000  000097fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000018d  00000000  00000000  00009a48  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_stack+0xbfffe830>
        ldr   pc,_fiq                   // FIQ - _fiq
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
  50:	e59f00c0 	ldr	r0, [pc, #192]	; 118 <.text+0x118>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
  54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
  58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
  5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
  60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
  64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
  68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
  6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
  70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
  74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
  78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
  7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
  80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
  84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
  88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
  8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
  90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
  94:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
  98:	e59f107c 	ldr	r1, [pc, #124]	; 11c <.text+0x11c>
        ldr   r2,=_data                 // -> data start
  9c:	e59f207c 	ldr	r2, [pc, #124]	; 120 <.text+0x120>
        ldr   r3,=_edata                // -> end of data
  a0:	e59f307c 	ldr	r3, [pc, #124]	; 124 <.text+0x124>
1:      cmp   r2,r3                     // check if data to move
  a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
  a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
  ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
  b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
  b4:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
  b8:	e59f1068 	ldr	r1, [pc, #104]	; 128 <.text+0x128>
        ldr   r2,=__bss_end__           // -> bss end
  bc:	e59f2068 	ldr	r2, [pc, #104]	; 12c <.text+0x12c>
2:      cmp   r1,r2                     // check if data to clear
  c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
  c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
  c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>
		
/*
   Call C++ constructors (for objects in "global scope")
   ctor loop added by Martin Thomas 4/2005 
   based on a Anglia Design example-application for ST ARM
*/

		LDR 	r0, =__ctors_start__
  cc:	e59f005c 	ldr	r0, [pc, #92]	; 130 <.text+0x130>
		LDR 	r1, =__ctors_end__
  d0:	e59f105c 	ldr	r1, [pc, #92]	; 134 <.text+0x134>

000000d4 <ctor_loop>:
ctor_loop:
		CMP 	r0, r1
  d4:	e1500001 	cmp	r0, r1
		BEQ 	ctor_end
  d8:	0a000005 	beq	f4 <ctor_end>
		LDR 	r2, [r0], #4
  dc:	e4902004 	ldr	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
  e0:	e92d0003 	stmdb	sp!, {r0, r1}
		MOV 	lr, pc
  e4:	e1a0e00f 	mov	lr, pc
		MOV 	pc, r2
  e8:	e1a0f002 	mov	pc, r2
		LDMFD 	sp!, {r0-r1}
  ec:	e8bd0003 	ldmia	sp!, {r0, r1}
		B 		ctor_loop
  f0:	eafffff7 	b	d4 <ctor_loop>

000000f4 <ctor_end>:
ctor_end:

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  f4:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
  f8:	e1a01000 	mov	r1, r0
        mov   r2,r0
  fc:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
 100:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
 104:	e1a07000 	mov	r7, r0
        ldr   r10,=main
 108:	e59fa028 	ldr	sl, [pc, #40]	; 138 <.text+0x138>
        mov   lr,pc
 10c:	e1a0e00f 	mov	lr, pc

/* Enter the C code, use BX instruction so as to never return */
/* use BLX (?) main if you want to use c++ destructors below */

        bx    r10                       // enter main()
 110:	e12fff1a 	bx	sl

00000114 <_reset>:

/* "global object"-dtors are never called and it should not be 
   needed since there is no OS to exit to. */
/* Call destructors */
#		LDR		r0, =__dtors_start__
#		LDR		r1, =__dtors_end__
dtor_loop:
#		CMP		r0, r1
#		BEQ		dtor_end
#		LDR		r2, [r0], #4
#		STMFD	sp!, {r0-r1}
#		MOV		lr, pc
#		MOV		pc, r2
#		LDMFD	sp!, {r0-r1}
#		B		dtor_loop
dtor_end:
   
        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:
#if 0
// Disable interrupts, then force a hardware reset by driving P23 low
// -------------------------------------------------------------------
        mrs   r0,cpsr                   // get PSR
        orr   r0,r0,#I_BIT|F_BIT        // disable IRQ and FIQ
        msr   cpsr,r0                   // set up status register

        ldr   r1,=(PS_BASE)             // PS Base Address
        ldr   r0,=(PS_PIO)              // PIO Module
        str   r0,[r1,#PS_PCER_OFF]      // enable its clock
        ldr   r1,=(PIO_BASE)            // PIO Base Address
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
 114:	eafffffe 	b	114 <_reset>
 118:	40000800 	andmi	r0, r0, r0, lsl #16
 11c:	00000844 	andeq	r0, r0, r4, asr #16
 120:	40000000 	andmi	r0, r0, r0
 124:	00000844 	andeq	r0, r0, r4, asr #16
 128:	40000000 	andmi	r0, r0, r0
 12c:	4000032c 	andmi	r0, r0, ip, lsr #6
 130:	00000844 	andeq	r0, r0, r4, asr #16
 134:	00000844 	andeq	r0, r0, r4, asr #16
 138:	000001d0 	ldreqd	r0, [r0], -r0

0000013c <DefaultISR>:
***************************************************************************/ 
void DefaultISR (
  void
  ) 
{
 13c:	eafffffe 	b	13c <DefaultISR>

00000140 <Timer0ISR>:
  while (1)
  { // We should never get here, if we do it is an error
  }
}


/**************************************************************************
DOES:    Timer 0 Interrupt Service Routine
GLOBALS: Increment timer tick
RETURNS: never
***************************************************************************/ 
void Timer0ISR (
  void
  ) 
{
 140:	e92d000c 	stmdb	sp!, {r2, r3}
  gTimerTick++;
 144:	e59f2028 	ldr	r2, [pc, #40]	; 174 <.text+0x174>
 148:	e5923000 	ldr	r3, [r2]
 14c:	e2833001 	add	r3, r3, #1	; 0x1
 150:	e5823000 	str	r3, [r2]
  T0IR = 1; // Clear interrupt flag
 154:	e59f301c 	ldr	r3, [pc, #28]	; 178 <.text+0x178>
 158:	e3a02001 	mov	r2, #1	; 0x1
 15c:	e5832000 	str	r2, [r3]
  VICVectAddr = 0xFFFFFFFF; // Acknowledge Interrupt
 160:	e59f3014 	ldr	r3, [pc, #20]	; 17c <.text+0x17c>
 164:	e3e02000 	mvn	r2, #0	; 0x0
 168:	e5832000 	str	r2, [r3]
}
 16c:	e8bd000c 	ldmia	sp!, {r2, r3}
 170:	e25ef004 	subs	pc, lr, #4	; 0x4
 174:	40000000 	andmi	r0, r0, r0
 178:	e0004000 	and	r4, r0, r0
 17c:	fffff030 	undefined instruction 0xfffff030

00000180 <SlowDown>:


/**************************************************************************
DOES:    Checks if a timestamp expired
GLOBALS: none
RETURNS: one if it expired, else zero
***************************************************************************/ 
static short IsTimeExpired (
  unsigned int timestamp
  )
{
unsigned int time_now;

  time_now = gTimerTick;
  if (time_now > timestamp)
  {
    if ((time_now - timestamp) < 0x80000000L)
      return 1;
    else
      return 0;
  }
  else
  {
    if ((timestamp - time_now) > 0x80000000L)
      return 1;
    else
      return 0;
  }
}


/**************************************************************************
DOES:    Waits until a timeout expires. Actual time waited is in the range
         from [0 to 100us*(delay-1)] to [0 to 100us*delay]
GLOBALS: none
RETURNS: nothing
***************************************************************************/ 
static void SlowDown (
  unsigned int delay // Number of 100us timeouts used for waiting
  )
{
  delay += gTimerTick;
 180:	e59f3044 	ldr	r3, [pc, #68]	; 1cc <.text+0x1cc>
 184:	e5933000 	ldr	r3, [r3]
 188:	e0800003 	add	r0, r0, r3
 18c:	e59f3038 	ldr	r3, [pc, #56]	; 1cc <.text+0x1cc>
 190:	e5933000 	ldr	r3, [r3]
 194:	e1530000 	cmp	r3, r0
 198:	e0601003 	rsb	r1, r0, r3
 19c:	e0632000 	rsb	r2, r3, r0
 1a0:	e3a03001 	mov	r3, #1	; 0x1
 1a4:	9a000002 	bls	1b4 <SlowDown+0x34>
 1a8:	e3510000 	cmp	r1, #0	; 0x0
 1ac:	aa000003 	bge	1c0 <SlowDown+0x40>
 1b0:	ea000001 	b	1bc <SlowDown+0x3c>
 1b4:	e3520102 	cmp	r2, #-2147483648	; 0x80000000
 1b8:	8a000000 	bhi	1c0 <SlowDown+0x40>
 1bc:	e3a03000 	mov	r3, #0	; 0x0
  while (!IsTimeExpired(delay))
 1c0:	e3530000 	cmp	r3, #0	; 0x0
 1c4:	0afffff0 	beq	18c <SlowDown+0xc>
  {
  }
}
 1c8:	e12fff1e 	bx	lr
 1cc:	40000000 	andmi	r0, r0, r0

000001d0 <main>:


/**************************************************************************
DOES:    Main routine of demo program:
         1.) Initialization
         2.) Send a single CAN message
         3.) Wait for CAN message,
             send response to received messages
GLOBALS: none
RETURNS: never
***************************************************************************/ 
int main 
  (
  void
  ) 
{
 1d0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
  CANALL_MSG MsgBuf; // Buffers one CAN message
  // unsigned int LEDvalue = 0x10000000L; // Used for LED output

  // No divider: peripheral clock = processor clock
  VPBDIV = 1; 
 1d4:	e59f31ac 	ldr	r3, [pc, #428]	; 388 <.text+0x388>
 1d8:	e3a04001 	mov	r4, #1	; 0x1
 1dc:	e5c34000 	strb	r4, [r3]
    
  // Init LED ports
  // IODIR1 = 0x00FF0000; // P1.16..23 defined as Outputs
  IODIR0 |= ( LED1BIT | LED2BIT ); // define LED-Pins as outputs
 1e0:	e59fc1a4 	ldr	ip, [pc, #420]	; 38c <.text+0x38c>
 1e4:	e59c3000 	ldr	r3, [ip]
 1e8:	e3833a03 	orr	r3, r3, #12288	; 0x3000
 1ec:	e58c3000 	str	r3, [ip]
  IOCLR0  = ( LED1BIT | LED2BIT ); // clear Bits = LEDs on (active low)
 1f0:	e59f3198 	ldr	r3, [pc, #408]	; 390 <.text+0x390>
 1f4:	e3a0ca03 	mov	ip, #12288	; 0x3000
 1f8:	e583c000 	str	ip, [r3]

  // Init Vector Interrupt Controller
  VICIntEnClr = 0xFFFFFFFFL; // Disable all Ints
 1fc:	e59f3190 	ldr	r3, [pc, #400]	; 394 <.text+0x394>
 200:	e3e0c000 	mvn	ip, #0	; 0x0
 204:	e583c000 	str	ip, [r3]
  VICIntSelect = 0x00000000L;
 208:	e3a05000 	mov	r5, #0	; 0x0

  // Install Default IRQVec
  VICDefVectAddr = (unsigned long) DefaultISR; // set interrupt vector
 20c:	e59fc184 	ldr	ip, [pc, #388]	; 398 <.text+0x398>
 210:	e2433008 	sub	r3, r3, #8	; 0x8
 214:	e4835028 	str	r5, [r3], #40
 218:	e24dd010 	sub	sp, sp, #16	; 0x10
 21c:	e583c000 	str	ip, [r3]

  // Initialisation of CAN interfaces
  // CAN interface 1, use IRQVec0, at 125kbit
  CANAll_Init(1,0,CANBitrate125k_12MHz); 
 220:	e1a01005 	mov	r1, r5
 224:	e59f2170 	ldr	r2, [pc, #368]	; 39c <.text+0x39c>
 228:	e1a00004 	mov	r0, r4
 22c:	eb000064 	bl	3c4 <CANAll_Init>
  
  // CAN interface 2, use IRQVec1, at 125kbit
  CANAll_Init(2,1,CANBitrate125k_12MHz); 
 230:	e1a01004 	mov	r1, r4
 234:	e59f2160 	ldr	r2, [pc, #352]	; 39c <.text+0x39c>
 238:	e3a00002 	mov	r0, #2	; 0x2
 23c:	eb000060 	bl	3c4 <CANAll_Init>

  // Set CAN Err ISR to IRQVec2
  CANAll_SetErrIRQ(2);
 240:	e3a00002 	mov	r0, #2	; 0x2
 244:	eb0000b5 	bl	520 <CANAll_SetErrIRQ>
  
  // Initialize Timer Interrupt
  T0MR0 = 5999; // 100 microseconds = 6.000-1 counts
 248:	e59f2150 	ldr	r2, [pc, #336]	; 3a0 <.text+0x3a0>
 24c:	e59f3150 	ldr	r3, [pc, #336]	; 3a4 <.text+0x3a4>
 250:	e5832000 	str	r2, [r3]
  T0MCR = 3; // Interrupt and Reset on MR0
 254:	e3a02003 	mov	r2, #3	; 0x3
 258:	e2433004 	sub	r3, r3, #4	; 0x4
 25c:	e4032010 	str	r2, [r3], #-16
  T0TCR = 1;  // Timer0 Enable
 260:	e5834000 	str	r4, [r3]

  // Set Timer0 ISR to IRQVec3
  VICVectAddr3 = (unsigned long) Timer0ISR; // set interrupt vector
 264:	e59f213c 	ldr	r2, [pc, #316]	; 3a8 <.text+0x3a8>
 268:	e59f313c 	ldr	r3, [pc, #316]	; 3ac <.text+0x3ac>
 26c:	e5832000 	str	r2, [r3]
  VICVectCntl3 = 0x20 | 4;  // use it for Timer 0 Interrupt
 270:	e3a02024 	mov	r2, #36	; 0x24
 274:	e2833c01 	add	r3, r3, #256	; 0x100
 278:	e40321fc 	str	r2, [r3], #-508
  VICIntEnable = 0x00000010;  // enable Timer0 Interrupt
 27c:	e3a02010 	mov	r2, #16	; 0x10
 280:	e5832000 	str	r2, [r3]

  enableIRQ();
 284:	eb000166 	bl	824 <enableIRQ>

  // DEBUG HELP:
  // Wait for 10 milliseconds, to allow debug hardware to catch up
  SlowDown(100);
 288:	e3a00064 	mov	r0, #100	; 0x64
 28c:	ebffffbb 	bl	180 <SlowDown>

  // Initialize MsgBuf
  MsgBuf.Frame = 0x80080000L; // 29-bit, no RTR, DLC is 8 bytes
 290:	e59f3118 	ldr	r3, [pc, #280]	; 3b0 <.text+0x3b0>
 294:	e58d3000 	str	r3, [sp]
  MsgBuf.MsgID = 0x00012345L; // CAN ID
 298:	e59f3114 	ldr	r3, [pc, #276]	; 3b4 <.text+0x3b4>
  MsgBuf.DatA = 0x00000000L; // all zeros
  MsgBuf.DatB = 0x00000000L; // all zeros
  // Transmit initial message on CAN 2
  CANAll_PushMessage(2,&MsgBuf);
 29c:	e3a00002 	mov	r0, #2	; 0x2
 2a0:	e1a0100d 	mov	r1, sp
 2a4:	e58d3004 	str	r3, [sp, #4]
 2a8:	e58d500c 	str	r5, [sp, #12]
 2ac:	e58d5008 	str	r5, [sp, #8]
 2b0:	eb0000ab 	bl	564 <CANAll_PushMessage>

  while (1)  
  {// Loop forever 

    // Handle LEDs
    /*LEDvalue <<= 1;
    if (LEDvalue > 0x00800000L)
    {
      LEDvalue = 0x00010000L;
    }
    IOSET1 = LEDvalue;
	*/

    // Check if message received on CAN 1
    if (CANAll_PullMessage(1,&MsgBuf))
 2b4:	e3a00001 	mov	r0, #1	; 0x1
 2b8:	e1a0100d 	mov	r1, sp
 2bc:	eb0000cf 	bl	600 <CANAll_PullMessage>
 2c0:	e1b00800 	movs	r0, r0, lsl #16
 2c4:	0a000013 	beq	318 <main+0x148>
    { // Message was received
      if (MsgBuf.MsgID == 0x00012345L)
 2c8:	e59d2004 	ldr	r2, [sp, #4]
 2cc:	e59f30e0 	ldr	r3, [pc, #224]	; 3b4 <.text+0x3b4>
 2d0:	e1520003 	cmp	r2, r3
 2d4:	1a00000f 	bne	318 <main+0x148>
      { // 12345h received, transmit 54321h
        MsgBuf.MsgID = 0x00054321L; 
        MsgBuf.DatA++;;
 2d8:	e59d2008 	ldr	r2, [sp, #8]
 2dc:	e59f30d4 	ldr	r3, [pc, #212]	; 3b8 <.text+0x3b8>
 2e0:	e2822001 	add	r2, r2, #1	; 0x1
        CANAll_PushMessage(1,&MsgBuf);
 2e4:	e1a0100d 	mov	r1, sp
 2e8:	e3a00001 	mov	r0, #1	; 0x1
 2ec:	e58d2008 	str	r2, [sp, #8]
 2f0:	e58d3004 	str	r3, [sp, #4]
 2f4:	eb00009a 	bl	564 <CANAll_PushMessage>
		/* toogle LED1 */
		if (IOPIN0 & LED1BIT) {
 2f8:	e59f30bc 	ldr	r3, [pc, #188]	; 3bc <.text+0x3bc>
 2fc:	e5933000 	ldr	r3, [r3]
 300:	e3130a01 	tst	r3, #4096	; 0x1000
			IOCLR0 = LED1BIT;
 304:	159f3084 	ldrne	r3, [pc, #132]	; 390 <.text+0x390>
		}
		else {
			IOSET0 = LED1BIT;  
 308:	059f30b0 	ldreq	r3, [pc, #176]	; 3c0 <.text+0x3c0>
 30c:	13a02a01 	movne	r2, #4096	; 0x1000
 310:	03a02a01 	moveq	r2, #4096	; 0x1000
 314:	e5832000 	str	r2, [r3]
		}
      }
    } // Message on CAN 1 received

    // Check if message received on CAN 2
    if (CANAll_PullMessage(2,&MsgBuf))
 318:	e3a00002 	mov	r0, #2	; 0x2
 31c:	e1a0100d 	mov	r1, sp
 320:	eb0000b6 	bl	600 <CANAll_PullMessage>
 324:	e1b00800 	movs	r0, r0, lsl #16
 328:	0a000013 	beq	37c <main+0x1ac>
    { // Message was received
      if (MsgBuf.MsgID == 0x00054321L)
 32c:	e59d2004 	ldr	r2, [sp, #4]
 330:	e59f3080 	ldr	r3, [pc, #128]	; 3b8 <.text+0x3b8>
 334:	e1520003 	cmp	r2, r3
 338:	1a00000f 	bne	37c <main+0x1ac>
      { // 54321h received, transmit 102h
        MsgBuf.MsgID = 0x00012345L;
        MsgBuf.DatB++;
 33c:	e59d200c 	ldr	r2, [sp, #12]
 340:	e59f306c 	ldr	r3, [pc, #108]	; 3b4 <.text+0x3b4>
 344:	e2822001 	add	r2, r2, #1	; 0x1
        CANAll_PushMessage(2,&MsgBuf);
 348:	e1a0100d 	mov	r1, sp
 34c:	e3a00002 	mov	r0, #2	; 0x2
 350:	e58d200c 	str	r2, [sp, #12]
 354:	e58d3004 	str	r3, [sp, #4]
 358:	eb000081 	bl	564 <CANAll_PushMessage>
		/* toogle LED2 */
		if (IOPIN0 & LED2BIT) {
 35c:	e59f3058 	ldr	r3, [pc, #88]	; 3bc <.text+0x3bc>
 360:	e5933000 	ldr	r3, [r3]
 364:	e3130a02 	tst	r3, #8192	; 0x2000
			IOCLR0 = LED2BIT;
 368:	159f3020 	ldrne	r3, [pc, #32]	; 390 <.text+0x390>
		}
		else {
			IOSET0 = LED2BIT;  
 36c:	059f304c 	ldreq	r3, [pc, #76]	; 3c0 <.text+0x3c0>
 370:	13a02a02 	movne	r2, #8192	; 0x2000
 374:	03a02a02 	moveq	r2, #8192	; 0x2000
 378:	e5832000 	str	r2, [r3]
		}
      }
    } // Message on CAN 2 received

#if (SLOWDOWN > 0)
    SlowDown(SLOWDOWN);
 37c:	e3a000c8 	mov	r0, #200	; 0xc8
 380:	ebffff7e 	bl	180 <SlowDown>
 384:	eaffffca 	b	2b4 <main+0xe4>
 388:	e01fc100 	ands	ip, pc, r0, lsl #2
 38c:	e0028008 	and	r8, r2, r8
 390:	e002800c 	and	r8, r2, ip
 394:	fffff014 	undefined instruction 0xfffff014
 398:	0000013c 	andeq	r0, r0, ip, lsr r1
 39c:	001c001d 	andeqs	r0, ip, sp, lsl r0
 3a0:	0000176f 	andeq	r1, r0, pc, ror #14
 3a4:	e0004018 	and	r4, r0, r8, lsl r0
 3a8:	00000140 	andeq	r0, r0, r0, asr #2
 3ac:	fffff10c 	undefined instruction 0xfffff10c
 3b0:	80080000 	andhi	r0, r8, r0
 3b4:	00012345 	andeq	r2, r1, r5, asr #6
 3b8:	00054321 	andeq	r4, r5, r1, lsr #6
 3bc:	e0028000 	and	r8, r2, r0
 3c0:	e0028004 	and	r8, r2, r4

000003c4 <CANAll_Init>:
  unsigned short can_port,    // CAN interface to use
  unsigned short can_isrvect, // interrupt vector number to use for Rx ISR (0-15)
  unsigned long can_btr        // CAN BTR value used to set CAN baud rate
  )
{
 3c4:	e1a01801 	mov	r1, r1, lsl #16
 3c8:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
 3cc:	e1a06821 	mov	r6, r1, lsr #16
 3d0:	e1a00800 	mov	r0, r0, lsl #16
volatile unsigned long *pSFR; // pointer into SFR space
volatile unsigned long *pSFR2; // pointer into SFR space
unsigned long offset; // offset added to pSFR

  // Double check can_isrvect value
  if (can_isrvect > 15)
 3d4:	e356000f 	cmp	r6, #15	; 0xf
 3d8:	e1a07002 	mov	r7, r2
 3dc:	e1a0e820 	mov	lr, r0, lsr #16
 3e0:	8a000044 	bhi	4f8 <STACK_SIZE+0xf8>
  { // Illegal value for can_isrvect
    return 0;
  }

  // Double check can_port value
  if ((can_port < 1) || (can_port > MAX_CANPORTS))
 3e4:	e24e2001 	sub	r2, lr, #1	; 0x1
 3e8:	e1a03802 	mov	r3, r2, lsl #16
 3ec:	e3530801 	cmp	r3, #65536	; 0x10000
 3f0:	8a000040 	bhi	4f8 <STACK_SIZE+0xf8>
  { // Illegal value for can_port
    return 0;
  }

  // Reset IN and OUT pointer
  mRxIN[can_port-1] = 0;
 3f4:	e1a03082 	mov	r3, r2, lsl #1
  mRxOUT[can_port-1] = 0;
 3f8:	e59f2100 	ldr	r2, [pc, #256]	; 500 <.text+0x500>
 3fc:	e3a01000 	mov	r1, #0	; 0x0
 400:	e18310b2 	strh	r1, [r3, r2]
 404:	e59f20f8 	ldr	r2, [pc, #248]	; 504 <.text+0x504>
  
  // Enable pins for selected CAN interface
  switch (can_port)
 408:	e35e0001 	cmp	lr, #1	; 0x1
 40c:	e18310b2 	strh	r1, [r3, r2]
 410:	0a000002 	beq	420 <STACK_SIZE+0x20>
 414:	e35e0002 	cmp	lr, #2	; 0x2
 418:	1a000036 	bne	4f8 <STACK_SIZE+0xf8>
 41c:	ea000005 	b	438 <STACK_SIZE+0x38>
  {
  case 1:
    PINSEL1 |= 0x00040000L; // Set bit 18
 420:	e59f20e0 	ldr	r2, [pc, #224]	; 508 <.text+0x508>
 424:	e5923000 	ldr	r3, [r2]
 428:	e3a0c000 	mov	ip, #0	; 0x0
 42c:	e3833701 	orr	r3, r3, #262144	; 0x40000
 430:	e5823000 	str	r3, [r2]
 434:	ea000004 	b	44c <STACK_SIZE+0x4c>
    offset = 0x00000000L; // Use 1st set of CAN registers
    break;
#if (MAX_CANPORTS > 1)
  case 2:
    PINSEL1 |= 0x00014000L; // Set bits 14 and 16
 438:	e59f20c8 	ldr	r2, [pc, #200]	; 508 <.text+0x508>
 43c:	e5923000 	ldr	r3, [r2]
 440:	e3833905 	orr	r3, r3, #81920	; 0x14000
 444:	e5823000 	str	r3, [r2]
 448:	e3a0ca01 	mov	ip, #4096	; 0x1000
    offset = 0x00001000L; // Use 2nd set of CAN registers
    break;
#endif
#if (MAX_CANPORTS > 2)
  case 3:
    PINSEL1 |= 0x00001800L; // Set bits 11 and 12
    offset = 0x00002000L; // Use 3rd set of CAN registers
    break;
#endif
#if (MAX_CANPORTS > 3)
  case 4:
    PINSEL0 |= 0x0F000000L; // Set bits 24 to 27
    offset = 0x00003000L; // Use 4th set of CAN registers
    break;
#endif
  default:
    return 0; // illegal value used
  }

  // Acceptance Filter Mode Register = filter off, receive all
  AFMR = 0x00000002L;
 44c:	e59f30b8 	ldr	r3, [pc, #184]	; 50c <.text+0x50c>
 450:	e3a02002 	mov	r2, #2	; 0x2
 454:	e5832000 	str	r2, [r3]

  pSFR = (volatile unsigned long *) &C1MOD + offset; // Select Mode register
  *pSFR = 1; // Go into Reset mode
 458:	e2833902 	add	r3, r3, #32768	; 0x8000
 45c:	e3a02001 	mov	r2, #1	; 0x1
 460:	e783210c 	str	r2, [r3, ip, lsl #2]

  pSFR = (volatile unsigned long *) &C1IER + offset; // Select Interrupt Enable Register
  *pSFR = 0;// Disable All Interrupts
 464:	e3a00000 	mov	r0, #0	; 0x0
 468:	e2833010 	add	r3, r3, #16	; 0x10
 46c:	e1a0110c 	mov	r1, ip, lsl #2
 470:	e783010c 	str	r0, [r3, ip, lsl #2]
 474:	e59f5094 	ldr	r5, [pc, #148]	; 510 <.text+0x510>

  pSFR = (volatile unsigned long *) &C1GSR + offset; // Select Status Register
  *pSFR = 0; // Clear Status register
 478:	e2433008 	sub	r3, r3, #8	; 0x8
 47c:	e281420e 	add	r4, r1, #-536870912	; 0xe0000000
 480:	e783010c 	str	r0, [r3, ip, lsl #2]

  pSFR = (volatile unsigned long *) &C1BTR + offset; // Select BTR Register
  *pSFR = can_btr; // Set bit timing

  // Set and enable receive interrupt
  pSFR = (volatile unsigned long *) &VICVectAddr0;
  pSFR += can_isrvect; // Set to desired interrupt vector
  
  pSFR2 = (volatile unsigned long *) &VICVectCntl0;
  pSFR2 += can_isrvect; // Set to desired interrupt control

  switch (can_port)
 484:	e35e0001 	cmp	lr, #1	; 0x1
 488:	e283300c 	add	r3, r3, #12	; 0xc
 48c:	e0815005 	add	r5, r1, r5
 490:	e783710c 	str	r7, [r3, ip, lsl #2]
 494:	e2844911 	add	r4, r4, #278528	; 0x44000
 498:	e1a01106 	mov	r1, r6, lsl #2
 49c:	0a000002 	beq	4ac <STACK_SIZE+0xac>
 4a0:	e35e0002 	cmp	lr, #2	; 0x2
 4a4:	1a000013 	bne	4f8 <STACK_SIZE+0xf8>
 4a8:	ea000005 	b	4c4 <STACK_SIZE+0xc4>
  {
  case 1:
    // Set interrupt vector
    *pSFR = (unsigned long) CANAll_CANISR_Rx1; 
 4ac:	e59f3060 	ldr	r3, [pc, #96]	; 514 <.text+0x514>
    // Use this Interrupt for CAN Rx1 Interrupt
    *pSFR2 = 0x20 | 26;
    // Enable CAN Rx1 Interrupt
    VICIntEnable = 0x04000000L;  
 4b0:	e3a02301 	mov	r2, #67108864	; 0x4000000
 4b4:	e5013f00 	str	r3, [r1, #-3840]
 4b8:	e3a0303a 	mov	r3, #58	; 0x3a
 4bc:	e5013e00 	str	r3, [r1, #-3584]
 4c0:	ea000004 	b	4d8 <STACK_SIZE+0xd8>
    break;
#if (MAX_CANPORTS > 1)
  case 2:
    // Set interrupt vector
    *pSFR = (unsigned long) CANAll_CANISR_Rx2; 
 4c4:	e59f304c 	ldr	r3, [pc, #76]	; 518 <.text+0x518>
 4c8:	e5013f00 	str	r3, [r1, #-3840]
    // Use this Interrupt for CAN Rx2 Interrupt
    *pSFR2 = 0x20 | 27;
 4cc:	e3a0303b 	mov	r3, #59	; 0x3b
 4d0:	e5013e00 	str	r3, [r1, #-3584]
    // Enable CAN Rx2 Interrupt
    VICIntEnable = 0x08000000L;  
 4d4:	e3a02302 	mov	r2, #134217728	; 0x8000000
 4d8:	e59f303c 	ldr	r3, [pc, #60]	; 51c <.text+0x51c>
 4dc:	e5832000 	str	r2, [r3]
    break;
#endif
#if (MAX_CANPORTS > 2)
  case 3:
    // Set interrupt vector
    *pSFR = (unsigned long) CANAll_CANISR_Rx3; 
    // Use this Interrupt for CAN Rx3 Interrupt
    *pSFR2 = 0x20 | 28;
    // Enable CAN Rx3 Interrupt
    VICIntEnable = 0x10000000L;  
    break;
#endif
#if (MAX_CANPORTS > 3)
  case 4:
    // Set interrupt vector
    *pSFR = (unsigned long) CANAll_CANISR_Rx4; 
    // Use this Interrupt for CAN Rx4 Interrupt
    *pSFR2 = 0x20 | 29;
    // Enable CAN Rx4 Interrupt
    VICIntEnable = 0x20000000L;  
    break;
#endif
  default:
    return 0; // illegal value used
  }

  pSFR = (volatile unsigned long *) &C1IER + offset; // Select Interrupt register
  *pSFR = 1; // Enable Receive Interrupt
 4e0:	e3a03001 	mov	r3, #1	; 0x1
 4e4:	e5853000 	str	r3, [r5]

  // Enter Normal Operating Mode
  pSFR = (volatile unsigned long *) &C1MOD + offset; // Select Mode register
  *pSFR = 0; // Operating Mode 
 4e8:	e1a00003 	mov	r0, r3
 4ec:	e3a03000 	mov	r3, #0	; 0x0
 4f0:	e5843000 	str	r3, [r4]
 4f4:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}

  return 1;
 4f8:	e3a00000 	mov	r0, #0	; 0x0
}
 4fc:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
 500:	40000328 	andmi	r0, r0, r8, lsr #6
 504:	40000324 	andmi	r0, r0, r4, lsr #6
 508:	e002c004 	and	ip, r2, r4
 50c:	e003c000 	and	ip, r3, r0
 510:	e0044010 	and	r4, r4, r0, lsl r0
 514:	000006b0 	streqh	r0, [r0], -r0
 518:	0000075c 	andeq	r0, r0, ip, asr r7
 51c:	fffff010 	undefined instruction 0xfffff010

00000520 <CANAll_SetErrIRQ>:


/**************************************************************************
Installing the CAN Err ISR
as described in LPC_CANAll.h
***************************************************************************/ 
short CANAll_SetErrIRQ (
  unsigned short can_isrvect // interrupt vector number to use for Err ISR (0-15)
  )
{
 520:	e1a00800 	mov	r0, r0, lsl #16
 524:	e1a00820 	mov	r0, r0, lsr #16
volatile unsigned long *pSFR; // pointer into SFR space

  // Double check can_isrvect value
  if (can_isrvect > 15)
 528:	e350000f 	cmp	r0, #15	; 0xf
  { // Illegal value for can_isrvect
    return 0;
  }

  // Set and enable err interrupt
  pSFR = (volatile unsigned long *) &VICVectAddr0;
  pSFR += can_isrvect; // Set to desired interrupt vector
 52c:	e1a02100 	mov	r2, r0, lsl #2
 530:	e3a00000 	mov	r0, #0	; 0x0
 534:	812fff1e 	bxhi	lr
  // Set interrupt vector
  *pSFR = (unsigned long) CANAll_CANISR_Err; 
 538:	e59f301c 	ldr	r3, [pc, #28]	; 55c <.text+0x55c>
 53c:	e5023f00 	str	r3, [r2, #-3840]
  
  pSFR = (volatile unsigned long *) &VICVectCntl0;
  pSFR += can_isrvect; // Set to desired interrupt control
  *pSFR = 0x20 | 19;
 540:	e3a03033 	mov	r3, #51	; 0x33
 544:	e5023e00 	str	r3, [r2, #-3584]

  // Enable Interrupt source
  VICIntEnable = 0x00080000L;  
 548:	e59f3010 	ldr	r3, [pc, #16]	; 560 <.text+0x560>
 54c:	e3a02702 	mov	r2, #524288	; 0x80000
 550:	e3a00001 	mov	r0, #1	; 0x1
 554:	e5832000 	str	r2, [r3]

  return 1;
}
 558:	e12fff1e 	bx	lr
 55c:	000006ac 	andeq	r0, r0, ip, lsr #13
 560:	fffff010 	undefined instruction 0xfffff010

00000564 <CANAll_PushMessage>:


/**************************************************************************
Transmitting a CAN message on a selected CAN interface
as described in LPC_CANAll.h
***************************************************************************/ 
short CANAll_PushMessage (
  unsigned short can_port,
  CANALL_MSG *pTransmitBuf
  )
{
 564:	e1a00800 	mov	r0, r0, lsl #16
volatile unsigned long *pAddr;  
unsigned long *pCandata;
unsigned long offset;
  
  // Double check can_port value
  if ((can_port < 1) || (can_port > MAX_CANPORTS))
 568:	e2403801 	sub	r3, r0, #65536	; 0x10000
 56c:	e3530801 	cmp	r3, #65536	; 0x10000
 570:	e1a00820 	mov	r0, r0, lsr #16
 574:	8a00001c 	bhi	5ec <CANAll_PushMessage+0x88>
  { // Illegal value for can_port
    return 0;
  }

  switch (can_port)
 578:	e3500001 	cmp	r0, #1	; 0x1
 57c:	e3a0c000 	mov	ip, #0	; 0x0
 580:	0a000002 	beq	590 <CANAll_PushMessage+0x2c>
 584:	e3500002 	cmp	r0, #2	; 0x2
 588:	1a000017 	bne	5ec <CANAll_PushMessage+0x88>
 58c:	e3a0ca01 	mov	ip, #4096	; 0x1000
  {
  case 1:
    offset = 0x00000000L; // Use 1st set of CAN registers
    break;
#if (MAX_CANPORTS > 1)
  case 2:
    offset = 0x00001000L; // Use 2nd set of CAN registers
    break;
#endif
#if (MAX_CANPORTS > 2)
  case 3:
    offset = 0x00002000L; // Use 3rd set of CAN registers
    break;
#endif
#if (MAX_CANPORTS > 3)
  case 4:
    offset = 0x00003000L; // Use 4th set of CAN registers
    break;
#endif
  default:
    return 0; // illegal value used
  }

  pAddr = (volatile unsigned long *) &C1SR + offset; // CANSR
  if (!(*pAddr & 0x00000004L))
 590:	e59f305c 	ldr	r3, [pc, #92]	; 5f4 <.text+0x5f4>
 594:	e793310c 	ldr	r3, [r3, ip, lsl #2]
 598:	e3130004 	tst	r3, #4	; 0x4
  { // Transmit Channel is not available
    return 0; // No channel available
  }

  // Write DLC, RTR and FF
  pAddr = (volatile unsigned long *) &C1TFI1 + offset;
  *pAddr = pTransmitBuf->Frame & 0xC00F0000L;  
 59c:	e59f2054 	ldr	r2, [pc, #84]	; 5f8 <.text+0x5f8>
  
  // Write CAN ID
  pAddr++;
  *pAddr = pTransmitBuf->MsgID;
 
  // Write first 4 data bytes 
  pCandata = (unsigned long *) &(pTransmitBuf->DatA);
  pAddr++;
  *pAddr = *pCandata;

  // Write second 4 data bytes 
  pCandata++;
  pAddr++;
  *pAddr = *pCandata;
  
  // Write self transmission request
  pAddr = (volatile unsigned long *) &C1CMR + offset;
  *pAddr = 0x30; // Self Transmission Request Buf 1
 5a0:	e3a00001 	mov	r0, #1	; 0x1
 5a4:	0a000010 	beq	5ec <CANAll_PushMessage+0x88>
 5a8:	e5913000 	ldr	r3, [r1]
 5ac:	e0032002 	and	r2, r3, r2
 5b0:	e59f3044 	ldr	r3, [pc, #68]	; 5fc <.text+0x5fc>
 5b4:	e783210c 	str	r2, [r3, ip, lsl #2]
 5b8:	e5912004 	ldr	r2, [r1, #4]
 5bc:	e2833004 	add	r3, r3, #4	; 0x4
 5c0:	e783210c 	str	r2, [r3, ip, lsl #2]
 5c4:	e5912008 	ldr	r2, [r1, #8]
 5c8:	e2833004 	add	r3, r3, #4	; 0x4
 5cc:	e783210c 	str	r2, [r3, ip, lsl #2]
 5d0:	e591200c 	ldr	r2, [r1, #12]
 5d4:	e2833004 	add	r3, r3, #4	; 0x4
 5d8:	e783210c 	str	r2, [r3, ip, lsl #2]
 5dc:	e3a02030 	mov	r2, #48	; 0x30
 5e0:	e2433038 	sub	r3, r3, #56	; 0x38
 5e4:	e783210c 	str	r2, [r3, ip, lsl #2]
 5e8:	e12fff1e 	bx	lr

  return 1;
 5ec:	e3a00000 	mov	r0, #0	; 0x0
}
 5f0:	e12fff1e 	bx	lr
 5f4:	e004401c 	and	r4, r4, ip, lsl r0
 5f8:	c00f0000 	andgt	r0, pc, r0
 5fc:	e0044030 	and	r4, r4, r0, lsr r0

00000600 <CANAll_PullMessage>:


/**************************************************************************
Receiving a CAN message
as described in LPC_CANAll.h
***************************************************************************/ 
short CANAll_PullMessage (
  unsigned short can_port,
  CANALL_MSG *pReceiveBuf
  )
{
 600:	e1a00800 	mov	r0, r0, lsl #16
unsigned long *pSrc; // Source pointer
unsigned long *pDst; // Destination pointer

  // Double check can_port value
  if ((can_port < 1) || (can_port > MAX_CANPORTS))
 604:	e2400801 	sub	r0, r0, #65536	; 0x10000
 608:	e1a00820 	mov	r0, r0, lsr #16
 60c:	e3500001 	cmp	r0, #1	; 0x1
 610:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
  { // Illegal value for can_port
    return 0;
  }
  can_port--; // Adjust to 0 - MAX_CANPORTS-1

  // Check if something is in RxQueue
  if ((mRxIN[can_port]) == (mRxOUT[can_port]))
 614:	e1a0c080 	mov	ip, r0, lsl #1
 618:	e59f5080 	ldr	r5, [pc, #128]	; 6a0 <.text+0x6a0>
 61c:	8a00001d 	bhi	698 <CANAll_PullMessage+0x98>
 620:	e59f307c 	ldr	r3, [pc, #124]	; 6a4 <.text+0x6a4>
 624:	e19c20f5 	ldrsh	r2, [ip, r5]
 628:	e19c30f3 	ldrsh	r3, [ip, r3]
 62c:	e1530002 	cmp	r3, r2
 630:	e19c30b5 	ldrh	r3, [ip, r5]
  { // Queue is empty
    return 0;
  }
  // Pointers are different, so something is in queue

  // Initialize pointers
  pSrc = (unsigned long *) &(mRxCAN[can_port][mRxOUT[can_port]]);
  pDst = (unsigned long *) &(pReceiveBuf->Frame);
  *pDst = *pSrc; // Copy Frame

  pSrc++;
  pDst++;
  *pDst = *pSrc; // Copy MsgID

  pSrc++;
  pDst++;
  *pDst = *pSrc; // Copy DatA

  pSrc++;
  pDst++;
  *pDst = *pSrc; // Copy DatB

  // Adjust OUT pointer
  mRxOUT[can_port]++;
 634:	e2833001 	add	r3, r3, #1	; 0x1
 638:	e1a03803 	mov	r3, r3, lsl #16
 63c:	e1a0e823 	mov	lr, r3, lsr #16
 640:	e59f6060 	ldr	r6, [pc, #96]	; 6a8 <.text+0x6a8>
  if (mRxOUT[can_port] >= MAX_QUEUE)
 644:	e1a0480e 	mov	r4, lr, lsl #16
 648:	0a000012 	beq	698 <CANAll_PullMessage+0x98>
 64c:	e3a03019 	mov	r3, #25	; 0x19
 650:	e0232390 	mla	r3, r0, r3, r2
 654:	e1a03203 	mov	r3, r3, lsl #4
 658:	e7932006 	ldr	r2, [r3, r6]
 65c:	e5812000 	str	r2, [r1]
 660:	e0833006 	add	r3, r3, r6
 664:	e5932004 	ldr	r2, [r3, #4]
 668:	e5812004 	str	r2, [r1, #4]
 66c:	e5932008 	ldr	r2, [r3, #8]
 670:	e5812008 	str	r2, [r1, #8]
 674:	e593300c 	ldr	r3, [r3, #12]
 678:	e3540706 	cmp	r4, #1572864	; 0x180000
 67c:	e3a00001 	mov	r0, #1	; 0x1
 680:	e581300c 	str	r3, [r1, #12]
  {
    mRxOUT[can_port] = 0;
 684:	c3a00001 	movgt	r0, #1	; 0x1
 688:	c3a03000 	movgt	r3, #0	; 0x0
 68c:	e18ce0b5 	strh	lr, [ip, r5]
 690:	c18c30b5 	strgth	r3, [ip, r5]
 694:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 698:	e3a00000 	mov	r0, #0	; 0x0
  }

  return 1;
}
 69c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 6a0:	40000328 	andmi	r0, r0, r8, lsr #6
 6a4:	40000324 	andmi	r0, r0, r4, lsr #6
 6a8:	40000004 	andmi	r0, r0, r4

000006ac <CANAll_CANISR_Err>:


/**************************************************************************
PRIVATE FUNCTIONS
***************************************************************************/ 

/**************************************************************************
DOES:    Interrupt Service Routine for CAN Errors
GLOBALS: none
RETURNS: nothing
***************************************************************************/ 
void CANAll_CANISR_Err (
  void
  ) 
{
 6ac:	eafffffe 	b	6ac <CANAll_CANISR_Err>

000006b0 <CANAll_CANISR_Rx1>:
  // DEBUG VERSION: do not return from Errors
  // Replace this with application specific error handling
  while (1)
  { 
  }
  VICVectAddr = 0xFFFFFFFFL; // acknowledge Interrupt
}


/**************************************************************************
DOES:    Interrupt Service Routine for CAN receive on CAN interface 1
GLOBALS: Copies the received message into the gRxCAN[0][] array
RETURNS: nothing
***************************************************************************/ 
void CANAll_CANISR_Rx1 (
  void
  ) 
{
 6b0:	e92d100f 	stmdb	sp!, {r0, r1, r2, r3, ip}
unsigned long *pDest;

  // initialize destination pointer
  pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
 6b4:	e59fc080 	ldr	ip, [pc, #128]	; 73c <.text+0x73c>
  *pDest = C1RFS;  // Frame
 6b8:	e59f3080 	ldr	r3, [pc, #128]	; 740 <.text+0x740>
 6bc:	e1dc10f0 	ldrsh	r1, [ip]
 6c0:	e5933000 	ldr	r3, [r3]
 6c4:	e59f2078 	ldr	r2, [pc, #120]	; 744 <.text+0x744>
 6c8:	e1a01201 	mov	r1, r1, lsl #4
 6cc:	e7813002 	str	r3, [r1, r2]

  pDest++;
  *pDest = C1RID; // ID
 6d0:	e59f3070 	ldr	r3, [pc, #112]	; 748 <.text+0x748>
 6d4:	e5933000 	ldr	r3, [r3]
 6d8:	e0811002 	add	r1, r1, r2
 6dc:	e5813004 	str	r3, [r1, #4]

  pDest++;
  *pDest = C1RDA; // Data A
 6e0:	e59f2064 	ldr	r2, [pc, #100]	; 74c <.text+0x74c>
 6e4:	e1dc30b0 	ldrh	r3, [ip]
 6e8:	e5922000 	ldr	r2, [r2]

  pDest++;
  *pDest = C1RDB; // Data B

  // Adjust IN pointer
  mRxIN[0]++;
 6ec:	e2833001 	add	r3, r3, #1	; 0x1
 6f0:	e5812008 	str	r2, [r1, #8]
 6f4:	e1a03803 	mov	r3, r3, lsl #16
 6f8:	e59f2050 	ldr	r2, [pc, #80]	; 750 <.text+0x750>
 6fc:	e1a03823 	mov	r3, r3, lsr #16
 700:	e5920000 	ldr	r0, [r2]
  if (mRxIN[0] >= MAX_QUEUE)
 704:	e1a02803 	mov	r2, r3, lsl #16
 708:	e3520706 	cmp	r2, #1572864	; 0x180000
 70c:	e1cc30b0 	strh	r3, [ip]
  {
    mRxIN[0] = 0;
 710:	c3a03000 	movgt	r3, #0	; 0x0
 714:	c1cc30b0 	strgth	r3, [ip]
  }

  C1CMR = 0x04; // release receive buffer
 718:	e59f3034 	ldr	r3, [pc, #52]	; 754 <.text+0x754>
 71c:	e3a02004 	mov	r2, #4	; 0x4
 720:	e581000c 	str	r0, [r1, #12]
 724:	e5832000 	str	r2, [r3]
  VICVectAddr = 0xFFFFFFFFL; // acknowledge Interrupt
 728:	e59f3028 	ldr	r3, [pc, #40]	; 758 <.text+0x758>
 72c:	e3e02000 	mvn	r2, #0	; 0x0
 730:	e5832000 	str	r2, [r3]
}
 734:	e8bd100f 	ldmia	sp!, {r0, r1, r2, r3, ip}
 738:	e25ef004 	subs	pc, lr, #4	; 0x4
 73c:	40000324 	andmi	r0, r0, r4, lsr #6
 740:	e0044020 	and	r4, r4, r0, lsr #32
 744:	40000004 	andmi	r0, r0, r4
 748:	e0044024 	and	r4, r4, r4, lsr #32
 74c:	e0044028 	and	r4, r4, r8, lsr #32
 750:	e004402c 	and	r4, r4, ip, lsr #32
 754:	e0044004 	and	r4, r4, r4
 758:	fffff030 	undefined instruction 0xfffff030

0000075c <CANAll_CANISR_Rx2>:


#if (MAX_CANPORTS > 1)
/**************************************************************************
DOES:    Interrupt Service Routine for CAN receive on CAN interface 2
GLOBALS: Copies the received message into the gRxCAN[1][] array
RETURNS: nothing
***************************************************************************/ 
void CANAll_CANISR_Rx2 (
  void
  ) 
{
 75c:	e92d100f 	stmdb	sp!, {r0, r1, r2, r3, ip}
unsigned long *pDest;

  // initialize destination pointer
  pDest = (unsigned long *) &(mRxCAN[1][mRxIN[1]]);
 760:	e59fc080 	ldr	ip, [pc, #128]	; 7e8 <.text+0x7e8>
  *pDest = C2RFS;  // Frame
 764:	e59f3080 	ldr	r3, [pc, #128]	; 7ec <.text+0x7ec>
 768:	e1dc10f2 	ldrsh	r1, [ip, #2]
 76c:	e5933000 	ldr	r3, [r3]
 770:	e59f2078 	ldr	r2, [pc, #120]	; 7f0 <.text+0x7f0>
 774:	e1a01201 	mov	r1, r1, lsl #4
 778:	e7813002 	str	r3, [r1, r2]

  pDest++;
  *pDest = C2RID; // ID
 77c:	e59f3070 	ldr	r3, [pc, #112]	; 7f4 <.text+0x7f4>
 780:	e5933000 	ldr	r3, [r3]
 784:	e0811002 	add	r1, r1, r2
 788:	e5813004 	str	r3, [r1, #4]

  pDest++;
  *pDest = C2RDA; // Data A
 78c:	e59f2064 	ldr	r2, [pc, #100]	; 7f8 <.text+0x7f8>
 790:	e1dc30b2 	ldrh	r3, [ip, #2]
 794:	e5922000 	ldr	r2, [r2]

  pDest++;
  *pDest = C2RDB; // Data B

  // Adjust IN pointer
  mRxIN[1]++;
 798:	e2833001 	add	r3, r3, #1	; 0x1
 79c:	e5812008 	str	r2, [r1, #8]
 7a0:	e1a03803 	mov	r3, r3, lsl #16
 7a4:	e59f2050 	ldr	r2, [pc, #80]	; 7fc <.text+0x7fc>
 7a8:	e1a03823 	mov	r3, r3, lsr #16
 7ac:	e5920000 	ldr	r0, [r2]
  if (mRxIN[1] >= MAX_QUEUE)
 7b0:	e1a02803 	mov	r2, r3, lsl #16
 7b4:	e3520706 	cmp	r2, #1572864	; 0x180000
 7b8:	e1cc30b2 	strh	r3, [ip, #2]
  {
    mRxIN[1] = 0;
 7bc:	c3a03000 	movgt	r3, #0	; 0x0
 7c0:	c1cc30b2 	strgth	r3, [ip, #2]
  }

  C2CMR = 0x04; // release receive buffer
 7c4:	e59f3034 	ldr	r3, [pc, #52]	; 800 <.text+0x800>
 7c8:	e3a02004 	mov	r2, #4	; 0x4
 7cc:	e581000c 	str	r0, [r1, #12]
 7d0:	e5832000 	str	r2, [r3]
  VICVectAddr = 0xFFFFFFFFL; // acknowledge Interrupt
 7d4:	e59f3028 	ldr	r3, [pc, #40]	; 804 <.text+0x804>
 7d8:	e3e02000 	mvn	r2, #0	; 0x0
 7dc:	e5832000 	str	r2, [r3]
}
 7e0:	e8bd100f 	ldmia	sp!, {r0, r1, r2, r3, ip}
 7e4:	e25ef004 	subs	pc, lr, #4	; 0x4
 7e8:	40000324 	andmi	r0, r0, r4, lsr #6
 7ec:	e0048020 	and	r8, r4, r0, lsr #32
 7f0:	40000194 	mulmi	r0, r4, r1
 7f4:	e0048024 	and	r8, r4, r4, lsr #32
 7f8:	e0048028 	and	r8, r4, r8, lsr #32
 7fc:	e004802c 	and	r8, r4, ip, lsr #32
 800:	e0048004 	and	r8, r4, r4
 804:	fffff030 	undefined instruction 0xfffff030

00000808 <restoreIRQ>:

static inline unsigned long asm_get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 808:	e10f2000 	mrs	r2, CPSR
  return retval;
}

static inline void asm_set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 80c:	e2000080 	and	r0, r0, #128	; 0x80
 810:	e3c23080 	bic	r3, r2, #128	; 0x80
 814:	e1833000 	orr	r3, r3, r0
 818:	e129f003 	msr	CPSR_fc, r3
}

unsigned long enableIRQ(void)
{
  unsigned long _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr & ~IRQ_MASK);
  return _cpsr;
}

unsigned long disableIRQ(void)
{
  unsigned long _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr | IRQ_MASK);
  return _cpsr;
}

unsigned long restoreIRQ(unsigned oldCPSR)
{
  unsigned long _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  return _cpsr;
}
 81c:	e1a00002 	mov	r0, r2
 820:	e12fff1e 	bx	lr

00000824 <enableIRQ>:
 824:	e10f0000 	mrs	r0, CPSR
 828:	e3c03080 	bic	r3, r0, #128	; 0x80
 82c:	e129f003 	msr	CPSR_fc, r3
 830:	e12fff1e 	bx	lr

00000834 <disableIRQ>:
 834:	e10f0000 	mrs	r0, CPSR
 838:	e3803080 	orr	r3, r0, #128	; 0x80
 83c:	e129f003 	msr	CPSR_fc, r3
 840:	e12fff1e 	bx	lr
