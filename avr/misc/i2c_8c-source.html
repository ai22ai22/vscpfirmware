<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>i2c.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>i2c.c</h1><a href="i2c_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file i2c.c \brief I2C interface using AVR Two-Wire Interface (TWI) hardware. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'i2c.c'</span>
00005 <span class="comment">// Title        : I2C interface using AVR Two-Wire Interface (TWI) hardware</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002-2003</span>
00007 <span class="comment">// Created      : 2002.06.25</span>
00008 <span class="comment">// Revised      : 2003.03.02</span>
00009 <span class="comment">// Version      : 0.9</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description : I2C (pronounced "eye-squared-see") is a two-wire bidirectional</span>
00014 <span class="comment">//      network designed for easy transfer of information between a wide variety</span>
00015 <span class="comment">//      of intelligent devices.  Many of the Atmel AVR series processors have</span>
00016 <span class="comment">//      hardware support for transmitting and receiving using an I2C-type bus.</span>
00017 <span class="comment">//      In addition to the AVRs, there are thousands of other parts made by</span>
00018 <span class="comment">//      manufacturers like Philips, Maxim, National, TI, etc that use I2C as</span>
00019 <span class="comment">//      their primary means of communication and control.  Common device types</span>
00020 <span class="comment">//      are A/D &amp; D/A converters, temp sensors, intelligent battery monitors,</span>
00021 <span class="comment">//      MP3 decoder chips, EEPROM chips, multiplexing switches, etc.</span>
00022 <span class="comment">//</span>
00023 <span class="comment">//      I2C uses only two wires (SDA and SCL) to communicate bidirectionally</span>
00024 <span class="comment">//      between devices.  I2C is a multidrop network, meaning that you can have</span>
00025 <span class="comment">//      several devices on a single bus.  Because I2C uses a 7-bit number to</span>
00026 <span class="comment">//      identify which device it wants to talk to, you cannot have more than</span>
00027 <span class="comment">//      127 devices on a single bus.</span>
00028 <span class="comment">//</span>
00029 <span class="comment">//      I2C ordinarily requires two 4.7K pull-up resistors to power (one each on</span>
00030 <span class="comment">//      SDA and SCL), but for small numbers of devices (maybe 1-4), it is enough</span>
00031 <span class="comment">//      to activate the internal pull-up resistors in the AVR processor.  To do</span>
00032 <span class="comment">//      this, set the port pins, which correspond to the I2C pins SDA/SCL, high.</span>
00033 <span class="comment">//      For example, on the mega163, sbi(PORTC, 0); sbi(PORTC, 1);.</span>
00034 <span class="comment">//</span>
00035 <span class="comment">//      For complete information about I2C, see the Philips Semiconductor</span>
00036 <span class="comment">//      website.  They created I2C and have the largest family of devices that</span>
00037 <span class="comment">//      work with I2C.</span>
00038 <span class="comment">//</span>
00039 <span class="comment">// Note: Many manufacturers market I2C bus devices under a different or generic</span>
00040 <span class="comment">//      bus name like "Two-Wire Interface".  This is because Philips still holds</span>
00041 <span class="comment">//      "I2C" as a trademark.  For example, SMBus and SMBus devices are hardware</span>
00042 <span class="comment">//      compatible and closely related to I2C.  They can be directly connected</span>
00043 <span class="comment">//      to an I2C bus along with other I2C devices are are generally accessed in</span>
00044 <span class="comment">//      the same way as I2C devices.  SMBus is often found on modern motherboards</span>
00045 <span class="comment">//      for temp sensing and other low-level control tasks.</span>
00046 <span class="comment">//</span>
00047 <span class="comment">// This code is distributed under the GNU Public License</span>
00048 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//*****************************************************************************</span>
00051 
00052 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00053 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
00054 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00055 <span class="preprocessor">#include &lt;avr/twi.h&gt;</span>
00056 
00057 <span class="preprocessor">#include "<a class="code" href="i2c_8h.html">i2c.h</a>"</span>
00058 
00059 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>    <span class="comment">// include printf function library</span>
00060 <span class="preprocessor">#include "<a class="code" href="uart2_8h.html">uart2.h</a>"</span>
00061 
00062 <span class="comment">// Standard I2C bit rates are:</span>
00063 <span class="comment">// 100KHz for slow speed</span>
00064 <span class="comment">// 400KHz for high speed</span>
00065 
00066 <span class="comment">//#define I2C_DEBUG</span>
00067 
00068 <span class="comment">// I2C state and address variables</span>
00069 <span class="keyword">static</span> <span class="keyword">volatile</span> eI2cStateType I2cState;
00070 <span class="keyword">static</span> u08 I2cDeviceAddrRW;
00071 <span class="comment">// send/transmit buffer (outgoing data)</span>
00072 <span class="keyword">static</span> u08 I2cSendData[I2C_SEND_DATA_BUFFER_SIZE];
00073 <span class="keyword">static</span> u08 I2cSendDataIndex;
00074 <span class="keyword">static</span> u08 I2cSendDataLength;
00075 <span class="comment">// receive buffer (incoming data)</span>
00076 <span class="keyword">static</span> u08 I2cReceiveData[I2C_RECEIVE_DATA_BUFFER_SIZE];
00077 <span class="keyword">static</span> u08 I2cReceiveDataIndex;
00078 <span class="keyword">static</span> u08 I2cReceiveDataLength;
00079 
00080 <span class="comment">// function pointer to i2c receive routine</span><span class="comment"></span>
00081 <span class="comment">//! I2cSlaveReceive is called when this processor</span>
00082 <span class="comment"></span>// is addressed as a slave for writing
00083 <span class="keyword">static</span> void (*i2cSlaveReceive)(u08 receiveDataLength, u08* recieveData);<span class="comment"></span>
00084 <span class="comment">//! I2cSlaveTransmit is called when this processor</span>
00085 <span class="comment"></span><span class="comment">// is addressed as a slave for reading</span>
00086 <span class="keyword">static</span> u08 (*i2cSlaveTransmit)(u08 transmitDataLengthMax, u08* transmitData);
00087 
00088 <span class="comment">// functions</span>
<a name="l00089"></a><a class="code" href="i2c_8c.html#a10">00089</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a10">i2cInit</a>(<span class="keywordtype">void</span>)
00090 {
00091     <span class="comment">// set pull-up resistors on I2C bus pins</span>
00092     sbi(PORTC, 0);  <span class="comment">// i2c SCL on ATmega163,323,16,32,etc</span>
00093     sbi(PORTC, 1);  <span class="comment">// i2c SDA on ATmega163,323,16,32,etc</span>
00094     sbi(PORTD, 0);  <span class="comment">// i2c SCL on ATmega128,64</span>
00095     sbi(PORTD, 1);  <span class="comment">// i2c SDA on ATmega128,64</span>
00096 
00097     <span class="comment">// clear SlaveReceive and SlaveTransmit handler to null</span>
00098     i2cSlaveReceive = 0;
00099     i2cSlaveTransmit = 0;
00100     <span class="comment">// set i2c bit rate to 100KHz</span>
00101     <a class="code" href="i2c_8c.html#a11">i2cSetBitrate</a>(100);
00102     <span class="comment">// enable TWI (two-wire interface)</span>
00103     sbi(TWCR, TWEN);
00104     <span class="comment">// set state</span>
00105     I2cState = I2C_IDLE;
00106     <span class="comment">// enable TWI interrupt and slave address ACK</span>
00107     sbi(TWCR, TWIE);
00108     sbi(TWCR, TWEA);
00109     <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));</span>
00110     <span class="comment">// enable interrupts</span>
00111     sei();
00112 }
00113 
<a name="l00114"></a><a class="code" href="i2c_8c.html#a11">00114</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a11">i2cSetBitrate</a>(u16 bitrateKHz)
00115 {
00116     u08 bitrate_div;
00117     <span class="comment">// set i2c bitrate</span>
00118     <span class="comment">// SCL freq = F_CPU/(16+2*TWBR))</span>
00119 <span class="preprocessor">    #ifdef TWPS0</span>
00120 <span class="preprocessor"></span>        <span class="comment">// for processors with additional bitrate division (mega128)</span>
00121         <span class="comment">// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)</span>
00122         <span class="comment">// set TWPS to zero</span>
00123         cbi(TWSR, TWPS0);
00124         cbi(TWSR, TWPS1);
00125 <span class="preprocessor">    #endif</span>
00126 <span class="preprocessor"></span>    <span class="comment">// calculate bitrate division   </span>
00127     bitrate_div = ((F_CPU/1000l)/bitrateKHz);
00128     <span class="keywordflow">if</span>(bitrate_div &gt;= 16)
00129         bitrate_div = (bitrate_div-16)/2;
00130     outb(TWBR, bitrate_div);
00131     
00132     <span class="comment">// 'cause the PIC so slow, it needs maximum division</span>
00133     <span class="comment">// if using a REAL mcu, delete the following line</span>
00134     outb(TWBR, 0xFF);
00135 }
00136 
<a name="l00137"></a><a class="code" href="i2c_8c.html#a12">00137</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a12">i2cSetLocalDeviceAddr</a>(u08 deviceAddr, u08 genCallEn)
00138 {
00139     <span class="comment">// set local device address (used in slave mode only)</span>
00140     outb(TWAR, ((deviceAddr&amp;0xFE) | (genCallEn?1:0)) );
00141 }
00142 
<a name="l00143"></a><a class="code" href="i2c_8c.html#a13">00143</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a13">i2cSetSlaveReceiveHandler</a>(<span class="keywordtype">void</span> (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
00144 {
00145     i2cSlaveReceive = i2cSlaveRx_func;
00146 }
00147 
<a name="l00148"></a><a class="code" href="i2c_8c.html#a14">00148</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a14">i2cSetSlaveTransmitHandler</a>(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
00149 {
00150     i2cSlaveTransmit = i2cSlaveTx_func;
00151 }
00152 
<a name="l00153"></a><a class="code" href="i2c_8c.html#a15">00153</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a15">i2cSendStart</a>(<span class="keywordtype">void</span>)
00154 {
00155     <span class="comment">// send start condition</span>
00156     outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
00157 }
00158 
<a name="l00159"></a><a class="code" href="i2c_8c.html#a16">00159</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a16">i2cSendStop</a>(<span class="keywordtype">void</span>)
00160 {
00161     <span class="comment">// transmit stop condition</span>
00162     <span class="comment">// leave with TWEA on for slave receiving</span>
00163     outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
00164 }
00165 
<a name="l00166"></a><a class="code" href="i2c_8c.html#a17">00166</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>(<span class="keywordtype">void</span>)
00167 {
00168     <span class="comment">// wait for i2c interface to complete operation</span>
00169     <span class="keywordflow">while</span>( !(inb(TWCR) &amp; BV(TWINT)) );
00170 }
00171 
<a name="l00172"></a><a class="code" href="i2c_8c.html#a18">00172</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>(u08 data)
00173 {
00174     <span class="comment">// save data to the TWDR</span>
00175     outb(TWDR, data);
00176     <span class="comment">// begin send</span>
00177     outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));
00178 }
00179 
<a name="l00180"></a><a class="code" href="i2c_8c.html#a19">00180</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(u08 ackFlag)
00181 {
00182     <span class="comment">// begin receive over i2c</span>
00183     <span class="keywordflow">if</span>( ackFlag )
00184     {
00185         <span class="comment">// ackFlag = TRUE: ACK the recevied data</span>
00186         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
00187     }
00188     <span class="keywordflow">else</span>
00189     {
00190         <span class="comment">// ackFlag = FALSE: NACK the recevied data</span>
00191         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));
00192     }
00193 }
00194 
<a name="l00195"></a><a class="code" href="i2c_8c.html#a20">00195</a> <span class="keyword">inline</span> u08 <a class="code" href="i2c_8c.html#a20">i2cGetReceivedByte</a>(<span class="keywordtype">void</span>)
00196 {
00197     <span class="comment">// retieve received data byte from i2c TWDR</span>
00198     <span class="keywordflow">return</span>( inb(TWDR) );
00199 }
00200 
<a name="l00201"></a><a class="code" href="i2c_8c.html#a21">00201</a> <span class="keyword">inline</span> u08 <a class="code" href="i2c_8c.html#a21">i2cGetStatus</a>(<span class="keywordtype">void</span>)
00202 {
00203     <span class="comment">// retieve current i2c status from i2c TWSR</span>
00204     <span class="keywordflow">return</span>( inb(TWSR) );
00205 }
00206 
<a name="l00207"></a><a class="code" href="i2c_8c.html#a22">00207</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a22">i2cMasterSend</a>(u08 deviceAddr, u08 length, u08* data)
00208 {
00209     u08 i;
00210     <span class="comment">// wait for interface to be ready</span>
00211     <span class="keywordflow">while</span>(I2cState);
00212     <span class="comment">// set state</span>
00213     I2cState = I2C_MASTER_TX;
00214     <span class="comment">// save data</span>
00215     I2cDeviceAddrRW = (deviceAddr &amp; 0xFE);  <span class="comment">// RW cleared: write operation</span>
00216     <span class="keywordflow">for</span>(i=0; i&lt;length; i++)
00217         I2cSendData[i] = *data++;
00218     I2cSendDataIndex = 0;
00219     I2cSendDataLength = length;
00220     <span class="comment">// send start condition</span>
00221     <a class="code" href="i2c_8c.html#a15">i2cSendStart</a>();
00222 }
00223 
<a name="l00224"></a><a class="code" href="i2c_8c.html#a23">00224</a> <span class="keywordtype">void</span> <a class="code" href="i2c_8c.html#a23">i2cMasterReceive</a>(u08 deviceAddr, u08 length, u08* data)
00225 {
00226     u08 i;
00227     <span class="comment">// wait for interface to be ready</span>
00228     <span class="keywordflow">while</span>(I2cState);
00229     <span class="comment">// set state</span>
00230     I2cState = I2C_MASTER_RX;
00231     <span class="comment">// save data</span>
00232     I2cDeviceAddrRW = (deviceAddr|0x01);    <span class="comment">// RW set: read operation</span>
00233     I2cReceiveDataIndex = 0;
00234     I2cReceiveDataLength = length;
00235     <span class="comment">// send start condition</span>
00236     <a class="code" href="i2c_8c.html#a15">i2cSendStart</a>();
00237     <span class="comment">// wait for data</span>
00238     <span class="keywordflow">while</span>(I2cState);
00239     <span class="comment">// return data</span>
00240     <span class="keywordflow">for</span>(i=0; i&lt;length; i++)
00241         *data++ = I2cReceiveData[i];
00242 }
00243 
<a name="l00244"></a><a class="code" href="i2c_8c.html#a24">00244</a> u08 <a class="code" href="i2c_8c.html#a24">i2cMasterSendNI</a>(u08 deviceAddr, u08 length, u08* data)
00245 {
00246     u08 retval = I2C_OK;
00247 
00248     <span class="comment">// disable TWI interrupt</span>
00249     cbi(TWCR, TWIE);
00250 
00251     <span class="comment">// send start condition</span>
00252     <a class="code" href="i2c_8c.html#a15">i2cSendStart</a>();
00253     <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00254 
00255     <span class="comment">// send device address with write</span>
00256     <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>( deviceAddr &amp; 0xFE );
00257     <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00258 
00259     <span class="comment">// check if device is present and live</span>
00260     <span class="keywordflow">if</span>( inb(TWSR) == TW_MT_SLA_ACK)
00261     {
00262         <span class="comment">// send data</span>
00263         <span class="keywordflow">while</span>(length)
00264         {
00265             <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>( *data++ );
00266             <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00267             length--;
00268         }
00269     }
00270     <span class="keywordflow">else</span>
00271     {
00272         <span class="comment">// device did not ACK it's address,</span>
00273         <span class="comment">// data will not be transferred</span>
00274         <span class="comment">// return error</span>
00275         retval = I2C_ERROR_NODEV;
00276     }
00277 
00278     <span class="comment">// transmit stop condition</span>
00279     <span class="comment">// leave with TWEA on for slave receiving</span>
00280     <a class="code" href="i2c_8c.html#a16">i2cSendStop</a>();
00281     <span class="keywordflow">while</span>( !(inb(TWCR) &amp; BV(TWSTO)) );
00282 
00283     <span class="comment">// enable TWI interrupt</span>
00284     sbi(TWCR, TWIE);
00285 
00286     <span class="keywordflow">return</span> retval;
00287 }
00288 
<a name="l00289"></a><a class="code" href="i2c_8c.html#a25">00289</a> u08 <a class="code" href="i2c_8c.html#a25">i2cMasterReceiveNI</a>(u08 deviceAddr, u08 length, u08 *data)
00290 {
00291     u08 retval = I2C_OK;
00292 
00293     <span class="comment">// disable TWI interrupt</span>
00294     cbi(TWCR, TWIE);
00295 
00296     <span class="comment">// send start condition</span>
00297     <a class="code" href="i2c_8c.html#a15">i2cSendStart</a>();
00298     <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00299 
00300     <span class="comment">// send device address with read</span>
00301     <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>( deviceAddr | 0x01 );
00302     <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00303 
00304     <span class="comment">// check if device is present and live</span>
00305     <span class="keywordflow">if</span>( inb(TWSR) == TW_MR_SLA_ACK)
00306     {
00307         <span class="comment">// accept receive data and ack it</span>
00308         <span class="keywordflow">while</span>(length &gt; 1)
00309         {
00310             <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(TRUE);
00311             <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00312             *data++ = <a class="code" href="i2c_8c.html#a20">i2cGetReceivedByte</a>();
00313             <span class="comment">// decrement length</span>
00314             length--;
00315         }
00316 
00317         <span class="comment">// accept receive data and nack it (last-byte signal)</span>
00318         <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(FALSE);
00319         <a class="code" href="i2c_8c.html#a17">i2cWaitForComplete</a>();
00320         *data++ = <a class="code" href="i2c_8c.html#a20">i2cGetReceivedByte</a>();
00321     }
00322     <span class="keywordflow">else</span>
00323     {
00324         <span class="comment">// device did not ACK it's address,</span>
00325         <span class="comment">// data will not be transferred</span>
00326         <span class="comment">// return error</span>
00327         retval = I2C_ERROR_NODEV;
00328     }
00329 
00330     <span class="comment">// transmit stop condition</span>
00331     <span class="comment">// leave with TWEA on for slave receiving</span>
00332     <a class="code" href="i2c_8c.html#a16">i2cSendStop</a>();
00333 
00334     <span class="comment">// enable TWI interrupt</span>
00335     sbi(TWCR, TWIE);
00336 
00337     <span class="keywordflow">return</span> retval;
00338 }
00339 <span class="comment">/*</span>
00340 <span class="comment">void i2cMasterTransferNI(u08 deviceAddr, u08 sendlength, u08* senddata, u08 receivelength, u08* receivedata)</span>
00341 <span class="comment">{</span>
00342 <span class="comment">    // disable TWI interrupt</span>
00343 <span class="comment">    cbi(TWCR, TWIE);</span>
00344 <span class="comment"></span>
00345 <span class="comment">    // send start condition</span>
00346 <span class="comment">    i2cSendStart();</span>
00347 <span class="comment">    i2cWaitForComplete();</span>
00348 <span class="comment"></span>
00349 <span class="comment">    // if there's data to be sent, do it</span>
00350 <span class="comment">    if(sendlength)</span>
00351 <span class="comment">    {</span>
00352 <span class="comment">        // send device address with write</span>
00353 <span class="comment">        i2cSendByte( deviceAddr &amp; 0xFE );</span>
00354 <span class="comment">        i2cWaitForComplete();</span>
00355 <span class="comment">        </span>
00356 <span class="comment">        // send data</span>
00357 <span class="comment">        while(sendlength)</span>
00358 <span class="comment">        {</span>
00359 <span class="comment">            i2cSendByte( *senddata++ );</span>
00360 <span class="comment">            i2cWaitForComplete();</span>
00361 <span class="comment">            sendlength--;</span>
00362 <span class="comment">        }</span>
00363 <span class="comment">    }</span>
00364 <span class="comment"></span>
00365 <span class="comment">    // if there's data to be received, do it</span>
00366 <span class="comment">    if(receivelength)</span>
00367 <span class="comment">    {</span>
00368 <span class="comment">        // send repeated start condition</span>
00369 <span class="comment">        i2cSendStart();</span>
00370 <span class="comment">        i2cWaitForComplete();</span>
00371 <span class="comment"></span>
00372 <span class="comment">        // send device address with read</span>
00373 <span class="comment">        i2cSendByte( deviceAddr | 0x01 );</span>
00374 <span class="comment">        i2cWaitForComplete();</span>
00375 <span class="comment"></span>
00376 <span class="comment">        // accept receive data and ack it</span>
00377 <span class="comment">        while(receivelength &gt; 1)</span>
00378 <span class="comment">        {</span>
00379 <span class="comment">            i2cReceiveByte(TRUE);</span>
00380 <span class="comment">            i2cWaitForComplete();</span>
00381 <span class="comment">            *receivedata++ = i2cGetReceivedByte();</span>
00382 <span class="comment">            // decrement length</span>
00383 <span class="comment">            receivelength--;</span>
00384 <span class="comment">        }</span>
00385 <span class="comment"></span>
00386 <span class="comment">        // accept receive data and nack it (last-byte signal)</span>
00387 <span class="comment">        i2cReceiveByte(TRUE);</span>
00388 <span class="comment">        i2cWaitForComplete();</span>
00389 <span class="comment">        *receivedata++ = i2cGetReceivedByte();</span>
00390 <span class="comment">    }</span>
00391 <span class="comment">    </span>
00392 <span class="comment">    // transmit stop condition</span>
00393 <span class="comment">    // leave with TWEA on for slave receiving</span>
00394 <span class="comment">    i2cSendStop();</span>
00395 <span class="comment">    while( !(inb(TWCR) &amp; BV(TWSTO)) );</span>
00396 <span class="comment"></span>
00397 <span class="comment">    // enable TWI interrupt</span>
00398 <span class="comment">    sbi(TWCR, TWIE);</span>
00399 <span class="comment">}</span>
00400 <span class="comment">*/</span>
00401 <span class="comment"></span>
00402 <span class="comment">//! I2C (TWI) interrupt service routine</span>
<a name="l00403"></a><a class="code" href="i2c_8c.html#a26">00403</a> <span class="comment"></span><a class="code" href="i2c_8c.html#a26">SIGNAL</a>(SIG_2WIRE_SERIAL)
00404 {
00405     <span class="comment">// read status bits</span>
00406     u08 status = inb(TWSR) &amp; TWSR_STATUS_MASK;
00407 
00408     <span class="keywordflow">switch</span>(status)
00409     {
00410     <span class="comment">// Master General</span>
00411     <span class="keywordflow">case</span> TW_START:                      <span class="comment">// 0x08: Sent start condition</span>
00412     <span class="keywordflow">case</span> TW_REP_START:                  <span class="comment">// 0x10: Sent repeated start condition</span>
00413 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00414 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00415         rprintf(<span class="stringliteral">"I2C: M-&gt;START\r\n"</span>);
00416         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00417 <span class="preprocessor">        #endif</span>
00418 <span class="preprocessor"></span>        <span class="comment">// send device address</span>
00419         <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>(I2cDeviceAddrRW);
00420         <span class="keywordflow">break</span>;
00421     
00422     <span class="comment">// Master Transmitter &amp; Receiver status codes</span>
00423     <span class="keywordflow">case</span> TW_MT_SLA_ACK:                 <span class="comment">// 0x18: Slave address acknowledged</span>
00424     <span class="keywordflow">case</span> TW_MT_DATA_ACK:                <span class="comment">// 0x28: Data acknowledged</span>
00425 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00426 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00427         rprintf(<span class="stringliteral">"I2C: MT-&gt;SLA_ACK or DATA_ACK\r\n"</span>);
00428         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00429 <span class="preprocessor">        #endif</span>
00430 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(I2cSendDataIndex &lt; I2cSendDataLength)
00431         {
00432             <span class="comment">// send data</span>
00433             <a class="code" href="i2c_8c.html#a18">i2cSendByte</a>( I2cSendData[I2cSendDataIndex++] );
00434         }
00435         <span class="keywordflow">else</span>
00436         {
00437             <span class="comment">// transmit stop condition, enable SLA ACK</span>
00438             <a class="code" href="i2c_8c.html#a16">i2cSendStop</a>();
00439             <span class="comment">// set state</span>
00440             I2cState = I2C_IDLE;
00441         }
00442         <span class="keywordflow">break</span>;
00443     <span class="keywordflow">case</span> TW_MR_DATA_NACK:               <span class="comment">// 0x58: Data received, NACK reply issued</span>
00444 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00445 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00446         rprintf(<span class="stringliteral">"I2C: MR-&gt;DATA_NACK\r\n"</span>);
00447         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00448 <span class="preprocessor">        #endif</span>
00449 <span class="preprocessor"></span>        <span class="comment">// store final received data byte</span>
00450         I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
00451         <span class="comment">// continue to transmit STOP condition</span>
00452     <span class="keywordflow">case</span> TW_MR_SLA_NACK:                <span class="comment">// 0x48: Slave address not acknowledged</span>
00453     <span class="keywordflow">case</span> TW_MT_SLA_NACK:                <span class="comment">// 0x20: Slave address not acknowledged</span>
00454     <span class="keywordflow">case</span> TW_MT_DATA_NACK:               <span class="comment">// 0x30: Data not acknowledged</span>
00455 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00456 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00457         rprintf(<span class="stringliteral">"I2C: MTR-&gt;SLA_NACK or MT-&gt;DATA_NACK\r\n"</span>);
00458         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00459 <span class="preprocessor">        #endif</span>
00460 <span class="preprocessor"></span>        <span class="comment">// transmit stop condition, enable SLA ACK</span>
00461         <a class="code" href="i2c_8c.html#a16">i2cSendStop</a>();
00462         <span class="comment">// set state</span>
00463         I2cState = I2C_IDLE;
00464         <span class="keywordflow">break</span>;
00465     <span class="keywordflow">case</span> TW_MT_ARB_LOST:                <span class="comment">// 0x38: Bus arbitration lost</span>
00466     <span class="comment">//case TW_MR_ARB_LOST:              // 0x38: Bus arbitration lost</span>
00467 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00468 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00469         rprintf(<span class="stringliteral">"I2C: MT-&gt;ARB_LOST\r\n"</span>);
00470         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00471 <span class="preprocessor">        #endif</span>
00472 <span class="preprocessor"></span>        <span class="comment">// release bus</span>
00473         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));
00474         <span class="comment">// set state</span>
00475         I2cState = I2C_IDLE;
00476         <span class="comment">// release bus and transmit start when bus is free</span>
00477         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));</span>
00478         <span class="keywordflow">break</span>;
00479     <span class="keywordflow">case</span> TW_MR_DATA_ACK:                <span class="comment">// 0x50: Data acknowledged</span>
00480 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00481 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00482         rprintf(<span class="stringliteral">"I2C: MR-&gt;DATA_ACK\r\n"</span>);
00483         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00484 <span class="preprocessor">        #endif</span>
00485 <span class="preprocessor"></span>        <span class="comment">// store received data byte</span>
00486         I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
00487         <span class="comment">// fall-through to see if more bytes will be received</span>
00488     <span class="keywordflow">case</span> TW_MR_SLA_ACK:                 <span class="comment">// 0x40: Slave address acknowledged</span>
00489 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00490 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00491         rprintf(<span class="stringliteral">"I2C: MR-&gt;SLA_ACK\r\n"</span>);
00492         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00493 <span class="preprocessor">        #endif</span>
00494 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(I2cReceiveDataIndex &lt; (I2cReceiveDataLength-1))
00495             <span class="comment">// data byte will be received, reply with ACK (more bytes in transfer)</span>
00496             <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(TRUE);
00497         <span class="keywordflow">else</span>
00498             <span class="comment">// data byte will be received, reply with NACK (final byte in transfer)</span>
00499             <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(FALSE);
00500         <span class="keywordflow">break</span>;
00501 
00502     <span class="comment">// Slave Receiver status codes</span>
00503     <span class="keywordflow">case</span> TW_SR_SLA_ACK:                 <span class="comment">// 0x60: own SLA+W has been received, ACK has been returned</span>
00504     <span class="keywordflow">case</span> TW_SR_ARB_LOST_SLA_ACK:        <span class="comment">// 0x68: own SLA+W has been received, ACK has been returned</span>
00505     <span class="keywordflow">case</span> TW_SR_GCALL_ACK:               <span class="comment">// 0x70:     GCA+W has been received, ACK has been returned</span>
00506     <span class="keywordflow">case</span> TW_SR_ARB_LOST_GCALL_ACK:      <span class="comment">// 0x78:     GCA+W has been received, ACK has been returned</span>
00507 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00508 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00509         rprintf(<span class="stringliteral">"I2C: SR-&gt;SLA_ACK\r\n"</span>);
00510         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00511 <span class="preprocessor">        #endif</span>
00512 <span class="preprocessor"></span>        <span class="comment">// we are being addressed as slave for writing (data will be received from master)</span>
00513         <span class="comment">// set state</span>
00514         I2cState = I2C_SLAVE_RX;
00515         <span class="comment">// prepare buffer</span>
00516         I2cReceiveDataIndex = 0;
00517         <span class="comment">// receive data byte and return ACK</span>
00518         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
00519         <span class="keywordflow">break</span>;
00520     <span class="keywordflow">case</span> TW_SR_DATA_ACK:                <span class="comment">// 0x80: data byte has been received, ACK has been returned</span>
00521     <span class="keywordflow">case</span> TW_SR_GCALL_DATA_ACK:          <span class="comment">// 0x90: data byte has been received, ACK has been returned</span>
00522 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00523 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00524         rprintf(<span class="stringliteral">"I2C: SR-&gt;DATA_ACK\r\n"</span>);
00525         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00526 <span class="preprocessor">        #endif</span>
00527 <span class="preprocessor"></span>        <span class="comment">// get previously received data byte</span>
00528         I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
00529         <span class="comment">// check receive buffer status</span>
00530         <span class="keywordflow">if</span>(I2cReceiveDataIndex &lt; I2C_RECEIVE_DATA_BUFFER_SIZE)
00531         {
00532             <span class="comment">// receive data byte and return ACK</span>
00533             <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(TRUE);
00534             <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));</span>
00535         }
00536         <span class="keywordflow">else</span>
00537         {
00538             <span class="comment">// receive data byte and return NACK</span>
00539             <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(FALSE);
00540             <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));</span>
00541         }
00542         <span class="keywordflow">break</span>;
00543     <span class="keywordflow">case</span> TW_SR_DATA_NACK:               <span class="comment">// 0x88: data byte has been received, NACK has been returned</span>
00544     <span class="keywordflow">case</span> TW_SR_GCALL_DATA_NACK:         <span class="comment">// 0x98: data byte has been received, NACK has been returned</span>
00545 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00546 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00547         rprintf(<span class="stringliteral">"I2C: SR-&gt;DATA_NACK\r\n"</span>);
00548         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00549 <span class="preprocessor">        #endif</span>
00550 <span class="preprocessor"></span>        <span class="comment">// receive data byte and return NACK</span>
00551         <a class="code" href="i2c_8c.html#a19">i2cReceiveByte</a>(FALSE);
00552         <span class="comment">//outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));</span>
00553         <span class="keywordflow">break</span>;
00554     <span class="keywordflow">case</span> TW_SR_STOP:                    <span class="comment">// 0xA0: STOP or REPEATED START has been received while addressed as slave</span>
00555 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00556 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00557         rprintf(<span class="stringliteral">"I2C: SR-&gt;SR_STOP\r\n"</span>);
00558         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00559 <span class="preprocessor">        #endif</span>
00560 <span class="preprocessor"></span>        <span class="comment">// switch to SR mode with SLA ACK</span>
00561         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
00562         <span class="comment">// i2c receive is complete, call i2cSlaveReceive</span>
00563         <span class="keywordflow">if</span>(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
00564         <span class="comment">// set state</span>
00565         I2cState = I2C_IDLE;
00566         <span class="keywordflow">break</span>;
00567 
00568     <span class="comment">// Slave Transmitter</span>
00569     <span class="keywordflow">case</span> TW_ST_SLA_ACK:                 <span class="comment">// 0xA8: own SLA+R has been received, ACK has been returned</span>
00570     <span class="keywordflow">case</span> TW_ST_ARB_LOST_SLA_ACK:        <span class="comment">// 0xB0:     GCA+R has been received, ACK has been returned</span>
00571 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00572 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00573         rprintf(<span class="stringliteral">"I2C: ST-&gt;SLA_ACK\r\n"</span>);
00574         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00575 <span class="preprocessor">        #endif</span>
00576 <span class="preprocessor"></span>        <span class="comment">// we are being addressed as slave for reading (data must be transmitted back to master)</span>
00577         <span class="comment">// set state</span>
00578         I2cState = I2C_SLAVE_TX;
00579         <span class="comment">// request data from application</span>
00580         <span class="keywordflow">if</span>(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
00581         <span class="comment">// reset data index</span>
00582         I2cSendDataIndex = 0;
00583         <span class="comment">// fall-through to transmit first data byte</span>
00584     <span class="keywordflow">case</span> TW_ST_DATA_ACK:                <span class="comment">// 0xB8: data byte has been transmitted, ACK has been received</span>
00585 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00586 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00587         rprintf(<span class="stringliteral">"I2C: ST-&gt;DATA_ACK\r\n"</span>);
00588         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00589 <span class="preprocessor">        #endif</span>
00590 <span class="preprocessor"></span>        <span class="comment">// transmit data byte</span>
00591         outb(TWDR, I2cSendData[I2cSendDataIndex++]);
00592         <span class="keywordflow">if</span>(I2cSendDataIndex &lt; I2cSendDataLength)
00593             <span class="comment">// expect ACK to data byte</span>
00594             outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
00595         <span class="keywordflow">else</span>
00596             <span class="comment">// expect NACK to data byte</span>
00597             outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT));
00598         <span class="keywordflow">break</span>;
00599     <span class="keywordflow">case</span> TW_ST_DATA_NACK:               <span class="comment">// 0xC0: data byte has been transmitted, NACK has been received</span>
00600     <span class="keywordflow">case</span> TW_ST_LAST_DATA:               <span class="comment">// 0xC8:</span>
00601 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00602 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00603         rprintf(<span class="stringliteral">"I2C: ST-&gt;DATA_NACK or LAST_DATA\r\n"</span>);
00604         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00605 <span class="preprocessor">        #endif</span>
00606 <span class="preprocessor"></span>        <span class="comment">// all done</span>
00607         <span class="comment">// switch to open slave</span>
00608         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
00609         <span class="comment">// set state</span>
00610         I2cState = I2C_IDLE;
00611         <span class="keywordflow">break</span>;
00612 
00613     <span class="comment">// Misc</span>
00614     <span class="keywordflow">case</span> TW_NO_INFO:                    <span class="comment">// 0xF8: No relevant state information</span>
00615         <span class="comment">// do nothing</span>
00616 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00617 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00618         rprintf(<span class="stringliteral">"I2C: NO_INFO\r\n"</span>);
00619         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00620 <span class="preprocessor">        #endif</span>
00621 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00622     <span class="keywordflow">case</span> TW_BUS_ERROR:                  <span class="comment">// 0x00: Bus error due to illegal start or stop condition</span>
00623 <span class="preprocessor">        #ifdef I2C_DEBUG</span>
00624 <span class="preprocessor"></span>        <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1AddToTxBuffer);
00625         rprintf(<span class="stringliteral">"I2C: BUS_ERROR\r\n"</span>);
00626         <a class="code" href="rprintf_8c.html#a6">rprintfInit</a>(uart1SendByte);
00627 <span class="preprocessor">        #endif</span>
00628 <span class="preprocessor"></span>        <span class="comment">// reset internal hardware and release bus</span>
00629         outb(TWCR, (inb(TWCR)&amp;TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
00630         <span class="comment">// set state</span>
00631         I2cState = I2C_IDLE;
00632         <span class="keywordflow">break</span>;
00633     }
00634 }
00635 
<a name="l00636"></a><a class="code" href="i2c_8c.html#a27">00636</a> eI2cStateType <a class="code" href="i2c_8c.html#a27">i2cGetState</a>(<span class="keywordtype">void</span>)
00637 {
00638     <span class="keywordflow">return</span> I2cState;
00639 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
