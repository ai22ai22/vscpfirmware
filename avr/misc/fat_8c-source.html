<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>fat.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>fat.c</h1><a href="fat_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file fat.c \brief FAT16/32 file system driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'fat.c'</span>
00005 <span class="comment">// Title        : FAT16/32 file system driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/07/2000</span>
00008 <span class="comment">// Revised      : 12/12/2000</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : ATmega103 (should work for Atmel AVR Series)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is based in part on work done by Jesper Hansen for his</span>
00014 <span class="comment">//      YAMPP MP3 player project.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00017 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00018 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00019 <span class="comment">//</span>
00020 <span class="comment">// This code is distributed under the GNU Public License</span>
00021 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00022 <span class="comment">//</span>
00023 <span class="comment">//*****************************************************************************</span>
00024 
00025 
00026 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00027 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00028 <span class="preprocessor">#include &lt;string.h&gt;</span>
00029 
00030 <span class="preprocessor">#include "<a class="code" href="ata_8h.html">ata.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="fat_8h.html">fat.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="fatconf_8h.html">fatconf.h</a>"</span>
00035 
00036 <span class="comment">// globals</span>
00037 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *SectorBuffer  =      (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) SECTOR_BUFFER1_ADDR;
00038 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *LongNameBuffer =     (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) LONGNAME_BUFFER_ADDR;
00039 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *DirNameBuffer =      (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) DIRNAME_BUFFER_ADDR;
00040 
00041 <span class="keyword">struct </span>partrecord PartInfo;
00042 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Fat32Enabled;
00043 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FirstDataSector;
00044 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  BytesPerSector;
00045 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  SectorsPerCluster;
00046 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FirstFATSector;
00047 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FirstDirSector;
00048 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FileSize;
00049 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> FatInCache = 0;
00050 
00051 <span class="comment">/*************************************************************************/</span>
00052 <span class="comment">/*************************************************************************/</span>
00053 
00054 
00055 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatClustToSect(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> clust)
00056 {
00057     <span class="keywordflow">return</span> ((clust-2) * SectorsPerCluster) + FirstDataSector;
00058 }
00059 
00060 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fatClusterSize(<span class="keywordtype">void</span>)
00061 {
00062     <span class="comment">// return the number of sectors in a disk cluster</span>
00063     <span class="keywordflow">return</span> SectorsPerCluster;
00064 }
00065 
00066 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatInit( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> device)
00067 {
00068     <span class="comment">//struct partrecord *pr;</span>
00069     <span class="keyword">struct </span>bpb710 *bpb;
00070 
00071     <span class="comment">// read partition table</span>
00072     <span class="comment">// TODO.... error checking</span>
00073     ataReadSectors(DRIVE0, 0, 1, SectorBuffer);
00074     <span class="comment">// map first partition record   </span>
00075     <span class="comment">// save partition information to global PartInfo</span>
00076     PartInfo = *((<span class="keyword">struct </span>partrecord *) ((struct partsector *) SectorBuffer)-&gt;psPart);
00077 <span class="comment">//  PartInfo = *pr;</span>
00078     
00079     <span class="comment">// Read the Partition BootSector</span>
00080     <span class="comment">// **first sector of partition in PartInfo.prStartLBA</span>
00081     ataReadSectors( DRIVE0, PartInfo.prStartLBA, 1, SectorBuffer );
00082     bpb = (<span class="keyword">struct </span>bpb710 *) ((struct bootsector710 *) SectorBuffer)-&gt;bsBPB;
00083 
00084     <span class="comment">// setup global disk constants</span>
00085     FirstDataSector = PartInfo.prStartLBA;
00086     <span class="keywordflow">if</span>(bpb-&gt;bpbFATsecs)
00087     {
00088         <span class="comment">// bpbFATsecs is non-zero and is therefore valid</span>
00089         FirstDataSector += bpb-&gt;bpbResSectors + bpb-&gt;bpbFATs * bpb-&gt;bpbFATsecs;
00090     }
00091     <span class="keywordflow">else</span>
00092     {
00093         <span class="comment">// bpbFATsecs is zero, real value is in bpbBigFATsecs</span>
00094         FirstDataSector += bpb-&gt;bpbResSectors + bpb-&gt;bpbFATs * bpb-&gt;bpbBigFATsecs;
00095     }
00096     SectorsPerCluster   = bpb-&gt;bpbSecPerClust;
00097     BytesPerSector      = bpb-&gt;bpbBytesPerSec;
00098     FirstFATSector      = bpb-&gt;bpbResSectors + PartInfo.prStartLBA;
00099 
00100     <span class="keywordflow">switch</span> (PartInfo.prPartType)
00101     {
00102         <span class="keywordflow">case</span> PART_TYPE_DOSFAT16:
00103         <span class="keywordflow">case</span> PART_TYPE_FAT16:
00104         <span class="keywordflow">case</span> PART_TYPE_FAT16LBA:
00105             <span class="comment">// first directory cluster is 2 by default (clusters range 2-&gt;big)</span>
00106             FirstDirSector  = CLUST_FIRST;
00107             <span class="comment">// push data sector pointer to end of root directory area</span>
00108             <span class="comment">//FirstDataSector += (bpb-&gt;bpbRootDirEnts)/DIRENTRIES_PER_SECTOR;</span>
00109             Fat32Enabled = FALSE;
00110             <span class="keywordflow">break</span>;
00111         <span class="keywordflow">case</span> PART_TYPE_FAT32LBA:
00112         <span class="keywordflow">case</span> PART_TYPE_FAT32:
00113             <span class="comment">// bpbRootClust field exists in FAT32 bpb710, but not in lesser bpb's</span>
00114             FirstDirSector = bpb-&gt;bpbRootClust;
00115             <span class="comment">// push data sector pointer to end of root directory area</span>
00116             <span class="comment">// need this? FirstDataSector += (bpb-&gt;bpbRootDirEnts)/DIRENTRIES_PER_SECTOR;</span>
00117             Fat32Enabled = TRUE;
00118             <span class="keywordflow">break</span>;
00119         <span class="keywordflow">default</span>:
00120             rprintfProgStrM(<span class="stringliteral">"Found: No Partition!\r\n"</span>);
00121             <span class="comment">//return 1;</span>
00122             <span class="keywordflow">break</span>;
00123     }
00124 
00125 
00126 <span class="preprocessor">#ifdef DEBUG_FAT</span>
00127 <span class="preprocessor"></span>    <span class="keywordflow">switch</span> (PartInfo.prPartType)
00128     {
00129         <span class="keywordflow">case</span> PART_TYPE_DOSFAT16:
00130                 rprintfProgStrM(<span class="stringliteral">"Found: DOSFAT 16\r\n"</span>);
00131                 <span class="keywordflow">break</span>;
00132         <span class="keywordflow">case</span> PART_TYPE_FAT16:
00133                 rprintfProgStrM(<span class="stringliteral">"Found: FAT16\r\n"</span>);
00134                 <span class="keywordflow">break</span>;
00135         <span class="keywordflow">case</span> PART_TYPE_FAT16LBA:
00136                 rprintfProgStrM(<span class="stringliteral">"Found: FAT16 LBA\r\n"</span>);
00137                 <span class="keywordflow">break</span>;
00138         <span class="keywordflow">case</span> PART_TYPE_FAT32LBA:
00139                 rprintfProgStrM(<span class="stringliteral">"Found: FAT32 LBA\r\n"</span>);
00140                 <span class="keywordflow">break</span>;
00141         <span class="keywordflow">case</span> PART_TYPE_FAT32:
00142                 rprintfProgStrM(<span class="stringliteral">"Found: FAT32\r\n"</span>);
00143                 <span class="comment">//return 1; </span>
00144                 <span class="keywordflow">break</span>;
00145         <span class="keywordflow">default</span>:
00146                 rprintfProgStrM(<span class="stringliteral">"Found: No Partition!\r\n"</span>);
00147                 <span class="comment">//return 1;</span>
00148                 <span class="keywordflow">break</span>;
00149     }
00150 
00151     rprintfProgStrM(<span class="stringliteral">"First sector    : "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(PartInfo.prStartLBA);    <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00152     rprintfProgStrM(<span class="stringliteral">"Size            : "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(PartInfo.prSize);        <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00153     rprintfProgStrM(<span class="stringliteral">"bytes/sector    : "</span>);  <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(bpb-&gt;bpbBytesPerSec);    <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00154     rprintfProgStrM(<span class="stringliteral">"sectors/cluster : "</span>);  <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(bpb-&gt;bpbSecPerClust);    <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00155     rprintfProgStrM(<span class="stringliteral">"reserved sectors: "</span>);  <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(bpb-&gt;bpbResSectors);     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00156     rprintfProgStrM(<span class="stringliteral">"FatSectors      : "</span>);  <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(bpb-&gt;bpbFATsecs);        <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00157     rprintfProgStrM(<span class="stringliteral">"BigFatSectors   : "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(bpb-&gt;bpbBigFATsecs);     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00158     rprintfProgStrM(<span class="stringliteral">"Number of Fats  : "</span>);  <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(bpb-&gt;bpbFATs);           <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00159     rprintfProgStrM(<span class="stringliteral">"First Fat Sector: "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(FirstFATSector);         <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00160     rprintfProgStrM(<span class="stringliteral">"First Data Sect : "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(FirstDataSector);        <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00161     rprintfProgStrM(<span class="stringliteral">"First Dir Clust : "</span>);  <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(FirstDirSector);         <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00162 <span class="preprocessor">#endif</span>
00163 <span class="preprocessor"></span>
00164     <span class="keywordflow">return</span> 0;   
00165 }
00166 <span class="comment"></span>
00167 <span class="comment">//////////////////////////////////////////////////////////////</span>
00168 <span class="comment"></span>
00169 
00170 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baseentry = 0;
00171 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> entrycount = 0;
00172 
00173 
00174 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetDirEntry(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> entry, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count)
00175 {
00176     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00177     <span class="keyword">struct </span>direntry *de = 0;    <span class="comment">// avoid compiler warning by initializing</span>
00178     <span class="keyword">struct </span>winentry *we;
00179     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hasBuffer;
00180     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b;
00181     <span class="keywordtype">int</span> i,index;
00182     <span class="keywordtype">char</span> *p;
00183     
00184     <span class="keywordflow">if</span>(count == 0)
00185     {
00186         entrycount = 0;
00187         DirNameBuffer = 0;
00188     }
00189     
00190     <span class="comment">// read dir data</span>
00191     sector = fatClustToSect(FirstDirSector);
00192 
00193     hasBuffer = 0;
00194 
00195     index = 16; <span class="comment">// crank it up</span>
00196     <span class="keywordflow">do</span> 
00197     {
00198         <span class="keywordflow">if</span>(index == 16) <span class="comment">// time for next sector ?</span>
00199         {
00200             ataReadSectors( DRIVE0, sector++, 1, SectorBuffer);
00201             de = (<span class="keyword">struct </span>direntry *) SectorBuffer;
00202             index = 0;
00203         }   
00204     
00205         <span class="keywordflow">if</span>(*de-&gt;deName != 0xE5)
00206         {
00207             <span class="comment">// if not a deleted entry</span>
00208             <span class="keywordflow">if</span>(de-&gt;deAttributes == ATTR_LONG_FILENAME)
00209             {
00210                 <span class="comment">// we have a long name entry</span>
00211                 we = (<span class="keyword">struct </span>winentry *) de;
00212                 b = 13 *( (we-&gt;weCnt-1) &amp; 0x0f);                <span class="comment">// index into string</span>
00213                 p = &amp;LongNameBuffer[b];
00214                 <span class="keywordflow">for</span> (i=0;i&lt;5;i++)   *p++ = we-&gt;wePart1[i*2];    <span class="comment">// copy first part          </span>
00215                 <span class="keywordflow">for</span> (i=0;i&lt;6;i++)   *p++ = we-&gt;wePart2[i*2];    <span class="comment">// second part</span>
00216                 <span class="keywordflow">for</span> (i=0;i&lt;2;i++)   *p++ = we-&gt;wePart3[i*2];    <span class="comment">// and third part</span>
00217                 <span class="keywordflow">if</span> (we-&gt;weCnt &amp; 0x40) *p = 0;                   <span class="comment">// in case dirnamelength is multiple of 13</span>
00218                 <span class="keywordflow">if</span> ((we-&gt;weCnt &amp; 0x0f) == 1) hasBuffer = 1;     <span class="comment">// mark that we have a long entry</span>
00219             }
00220             <span class="keywordflow">else</span>
00221             {
00222                 <span class="comment">// we have a short name entry</span>
00223                 <span class="comment">// check if this is the end of a multi-part long name entry</span>
00224                 <span class="keywordflow">if</span>(hasBuffer)
00225                 {
00226                     <span class="comment">// a long entry name has been collected</span>
00227                     <span class="comment">// is it a directory ?</span>
00228                     <span class="keywordflow">if</span>(de-&gt;deAttributes == ATTR_DIRECTORY)
00229                     {
00230                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> save = FirstDirSector;
00231                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> save2 = baseentry;
00232                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rval;
00233                         
00234                         strcpy(DirNameBuffer,LongNameBuffer);
00235                         strcat(DirNameBuffer,<span class="stringliteral">"/"</span>);
00236 
00237 <span class="comment">//                      rprintfStr(LongNameBuffer); rprintfProgStrM("/"); //EOL();</span>
00238 
00239                         <span class="comment">// call recursively</span>
00240                         FirstDirSector = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)de-&gt;deHighClust &lt;&lt; 16) + de-&gt;deStartCluster;
00241                         rval = fatGetDirEntry(entry,1);
00242                         FirstDirSector = save;
00243                         baseentry = save2;
00244                         <span class="keywordflow">if</span> (rval)
00245                             <span class="keywordflow">return</span> rval;
00246                         <span class="keywordflow">else</span>    
00247                         {
00248                             <span class="comment">// reload original sector</span>
00249                             ataReadSectors( DRIVE0, sector-1, 1, SectorBuffer);
00250                             entrycount--;           <span class="comment">// decrement entry counter      </span>
00251                             *DirNameBuffer = 0;
00252                     }
00253                     }
00254                     <span class="keywordflow">else</span> <span class="comment">// normal file entry</span>
00255                         <span class="keywordflow">if</span>(entrycount == entry)     
00256                             <span class="keywordflow">break</span>;
00257                     hasBuffer = 0;  <span class="comment">// clear buffer </span>
00258                     entrycount++;   <span class="comment">// increment entry counter      </span>
00259                 }
00260                 <span class="comment">// else ignore short_name_only entries</span>
00261             }
00262         }
00263         de++;
00264         index++;
00265     }   <span class="keywordflow">while</span> (*de-&gt;deName || index == 16); <span class="comment">// 0 in de-&gt;deName[0] if no more entries</span>
00266 
00267     <span class="keywordflow">if</span> (hasBuffer == 0)     <span class="comment">// end of entries</span>
00268         <span class="keywordflow">return</span> 0;
00269     
00270     FileSize = de-&gt;deFileSize;
00271     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)de-&gt;deHighClust &lt;&lt; 16) + de-&gt;deStartCluster;
00272 }
00273 
00274 
00275 <span class="comment">// return the size of the last directory entry</span>
00276 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetFilesize(<span class="keywordtype">void</span>)
00277 {
00278     <span class="keywordflow">return</span> FileSize;
00279 }
00280 
00281 
00282 <span class="comment">// return the long name of the last directory entry</span>
00283 <span class="keywordtype">char</span>* fatGetFilename(<span class="keywordtype">void</span>)
00284 {   
00285     <span class="keywordflow">return</span> LongNameBuffer;
00286 }
00287 
00288 
00289 <span class="comment">// return the directory of the last directory entry</span>
00290 <span class="keywordtype">char</span>* fatGetDirname(<span class="keywordtype">void</span>)
00291 {   
00292     <span class="keywordflow">return</span> DirNameBuffer;
00293 }
00294 
00295 
00296 <span class="comment">// load a clusterfull of data</span>
00297 <span class="keywordtype">void</span> fatLoadCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer)
00298 {
00299     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00300     <span class="comment">// read cluster</span>
00301     <span class="comment">//while ( ataReadSectors( DRIVE0, clust2sect(cluster), SectorsPerCluster, buffer) != 0);</span>
00302     <span class="keywordflow">for</span>(i=0; i&lt;SectorsPerCluster; i++)
00303     {
00304 <span class="comment">//      ataReadSectors( DRIVE0, clust2sect(cluster)+i, 1, buffer+(i&lt;&lt;9) );</span>
00305         <span class="comment">// temporary fix for wierd misaligned cluster problem</span>
00306         <span class="comment">// (only when using FAT16?)</span>
00307         ataReadSectors( DRIVE0, fatClustToSect(cluster+8)+i, 1, buffer+(i&lt;&lt;9) );
00308     }
00309 }
00310 
00311 
00312 <span class="comment">// find next cluster in the FAT chain</span>
00313 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatNextCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster)
00314 {
00315     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nextCluster;
00316     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatMask;
00317     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatOffset;
00318     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sector;
00319     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
00320     
00321     <span class="comment">// get fat offset in bytes</span>
00322     <span class="keywordflow">if</span>(Fat32Enabled)
00323     {
00324         <span class="comment">// four FAT bytes (32 bits) for every cluster</span>
00325         fatOffset = cluster &lt;&lt; 2;
00326         <span class="comment">// set the FAT bit mask</span>
00327         fatMask = FAT32_MASK;
00328     }
00329     <span class="keywordflow">else</span>
00330     {
00331         <span class="comment">// two FAT bytes (16 bits) for every cluster</span>
00332         fatOffset = cluster &lt;&lt; 1;
00333         <span class="comment">// set the FAT bit mask</span>
00334         fatMask = FAT16_MASK;
00335     }
00336     
00337     <span class="comment">// calculate the FAT sector that we're interested in</span>
00338     sector = FirstFATSector + (fatOffset / BytesPerSector);
00339     <span class="comment">// calculate offset of the our entry within that FAT sector</span>
00340     offset = fatOffset % BytesPerSector;
00341 
00342     <span class="comment">// if we don't already have this FAT chunk loaded, go get it</span>
00343     <span class="keywordflow">if</span> (sector != FatInCache)
00344     {
00345         <span class="comment">// read sector of FAT table</span>
00346         <span class="keywordflow">while</span> (ataReadSectors( DRIVE0, sector, 1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)FAT_CACHE_ADDR) != 0);
00347         FatInCache = sector;
00348     }
00349 
00350     <span class="comment">// read the nextCluster value</span>
00351     nextCluster = (*((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) &amp;((<span class="keywordtype">char</span>*)FAT_CACHE_ADDR)[offset])) &amp; fatMask;
00352 
00353     <span class="comment">// check to see if we're at the end of the chain</span>
00354     <span class="keywordflow">if</span> (nextCluster == (CLUST_EOFE &amp; fatMask))
00355         nextCluster = 0;
00356 
00357 <span class="preprocessor">#ifdef DEBUG_FAT</span>
00358 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"&gt;"</span>);
00359     <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(nextCluster);
00360     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00361 <span class="preprocessor">#endif</span>
00362 <span class="preprocessor"></span>    
00363     <span class="keywordflow">return</span> nextCluster;
00364 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
