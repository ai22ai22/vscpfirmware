<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ata.h Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ata.h</h1><a href="ata_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file ata.h \brief IDE-ATA hard disk interface driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ata.h'</span>
00005 <span class="comment">// Title        : IDE-ATA interface driver for hard disks</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/22/2000</span>
00008 <span class="comment">// Revised      : 12/29/2000</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : ATmega103 (should work for Atmel AVR Series)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 
00023 <span class="preprocessor">#ifndef ATA_H</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define ATA_H</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="ataconf_8h.html">ataconf.h</a>"</span>
00028 
00029 <span class="comment">// constants</span>
00030 <span class="preprocessor">#define DRIVE0      0</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#define STANDBY     0</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP       1</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define IDLE        2</span>
00035 <span class="preprocessor"></span>
00036 <span class="comment">// ATA status register bits</span>
00037 <span class="preprocessor">#define ATA_SR_BSY      0x80</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_DRDY     0x40</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_DF       0x20</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_DSC      0x10</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_DRQ      0x08</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_CORR     0x04</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_IDX      0x02</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define ATA_SR_ERR      0x01</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">// ATA error register bits</span>
00047 <span class="preprocessor">#define ATA_ER_UNC      0x40</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_MC       0x20</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_IDNF     0x10</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_MCR      0x08</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_ABRT     0x04</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_TK0NF    0x02</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define ATA_ER_AMNF     0x01</span>
00054 <span class="preprocessor"></span>
00055 <span class="comment">// ATA head register bits</span>
00056 <span class="preprocessor">#define ATA_HEAD_USE_LBA    0x40</span>
00057 <span class="preprocessor"></span><span class="comment">/*</span>
00058 <span class="comment">// ATA registers</span>
00059 <span class="comment">#define ATA_REG_BASE        0x8000</span>
00060 <span class="comment">#define ATA_REG_DATAL       0x00</span>
00061 <span class="comment">#define ATA_REG_ERROR       0x01</span>
00062 <span class="comment">#define ATA_REG_SECCOUNT    0x02</span>
00063 <span class="comment">#define ATA_REG_STARTSEC    0x03</span>
00064 <span class="comment">#define ATA_REG_CYLLO       0x04</span>
00065 <span class="comment">#define ATA_REG_CYLHI       0x05</span>
00066 <span class="comment">#define ATA_REG_HDDEVSEL    0x06</span>
00067 <span class="comment">#define ATA_REG_CMDSTATUS1  0x07</span>
00068 <span class="comment">#define ATA_REG_CMDSTATUS2  0x08</span>
00069 <span class="comment">#define ATA_REG_ACTSTATUS   0x09</span>
00070 <span class="comment"></span>
00071 <span class="comment">#define ATA_REG_DATAH       0x10</span>
00072 <span class="comment">*/</span>
00073 <span class="comment">// ATA commands</span>
00074 <span class="preprocessor">#define ATA_CMD_READ            0x20</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_READNR          0x21</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_WRITE           0x30</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_WRITENR         0x31</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_IDENTIFY        0xEC</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_RECALIBRATE     0x10</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_SPINDOWN        0xE0    // spin down disk immediately</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_SPINUP          0xE1    // spin up disk immediately</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_STANDBY_5SU     0xE2    // spin down disk and set auto-power-down timer (sectorcount*5sec)</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_IDLE_5SU        0xE3    // keep disk spinning and set auto-power-down timer (sectorcount*5sec)</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_SLEEP           0xE6    // sleep disk (wakeup only on HW or SW reset)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_STANDBY_01SU    0xF2    // spin down disk and set auto-power-down timer (sectorcount*0.1sec)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define ATA_CMD_IDLE_01SU       0xF3    // keep disk spinning and set auto-power-down timer (sectorcount*0.1sec)</span>
00087 <span class="preprocessor"></span>
00088 
00089 <span class="comment">// ATA CHS disk parameters (examples, now we autodetect)</span>
00090 <span class="preprocessor">#define ATA_DISKPARM_CLYS       0x03A6  // number of cylinders per platter</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define ATA_DISKPARM_HEADS      0x10    // number of heads (usable plater sides)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define ATA_DISKPARM_SECTORS    0x11    // number of sectors per head per cylinder</span>
00093 <span class="preprocessor"></span>
00094 <span class="comment">// ATA Identity fields</span>
00095 <span class="comment">// all offsets refer to word offset (2 byte increments)</span>
00096 <span class="preprocessor">#define ATA_IDENT_DEVICETYPE    0       // specifies ATA/ATAPI, removable/non-removable</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_CYLINDERS     1       // number of logical cylinders</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_HEADS         3       // number of logical heads</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_SECTORS       6       // number of sectors per track</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_SERIAL        10      // drive model name (20 characters)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_MODEL         27      // drive model name (40 characters)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_FIELDVALID    53      // indicates field validity of higher words (bit0: words54-58, bit1: words 64-70)</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define ATA_IDENT_LBASECTORS    60      // number of sectors in LBA translation mode</span>
00104 <span class="preprocessor"></span>
00105 <span class="comment">// drive mode defines (for ataSetDrivePowerMode() )</span>
00106 <span class="preprocessor">#define ATA_DISKMODE_SPINDOWN   0</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define ATA_DISKMODE_SPINUP     1</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define ATA_DISKMODE_SETTIMEOUT 2</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define ATA_DISKMODE_SLEEP      3</span>
00110 <span class="preprocessor"></span>
00111 <span class="comment">// typedefs</span>
00112 <span class="comment">// drive info structure</span>
00113 <span class="keyword">typedef</span> <span class="keyword">struct </span>
00114 <span class="keyword"></span>{
00115     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  cylinders;
00116     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> heads;
00117     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> sectors;
00118     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sizeinsectors;
00119     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> LBAsupport;
00120     <span class="keywordtype">char</span> model[41];
00121 } typeDriveInfo;
00122 
00123 
00124 <span class="comment">// Prototypes</span>
00125 <span class="keywordtype">void</span> ataInit(<span class="keywordtype">void</span>);
00126 <span class="keywordtype">void</span> ataDriveInit(<span class="keywordtype">void</span>);
00127 <span class="keywordtype">void</span> ataDriveSelect(u08 DriveNo);
00128 <span class="keywordtype">void</span> ataSetDrivePowerMode(u08 DriveNo, u08 mode, u08 timeout);
00129 u08  ataReadByte(u08 reg);
00130 <span class="keywordtype">void</span> ataWriteByte(u08 reg, u08 data);
00131 <span class="keywordtype">void</span> ataShowRegisters(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> DriveNo);
00132 u08  ataSWReset(<span class="keywordtype">void</span>);
00133 <span class="keywordtype">void</span> ataDiskErr(<span class="keywordtype">void</span>);
00134 <span class="keywordtype">void</span> ataPrintSector( u08 *Buffer);
00135 <span class="keywordtype">void</span> ataReadDataBuffer(u08 *Buffer, u16 numBytes);
00136 <span class="keywordtype">void</span> ataWriteDataBuffer(u08 *Buffer, u16 numBytes);
00137 u08 ataStatusWait(u08 mask, u08 waitStatus);
00138 
00139 <span class="comment">// read and write routines for CHS based drives</span>
00140 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsCHS(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00141                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00142                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00143                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00144                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00145                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00146 
00147 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsCHS(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00148                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00149                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00150                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00151                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00152                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00153 
00154 <span class="comment">// read and write routines for LBA based drives</span>
00155 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsLBA(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00156                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00157                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00158                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00159 
00160 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsLBA(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00161                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00162                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00163                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00164 
00165 <span class="comment">// generic read and write routines using LBA</span>
00166 <span class="comment">//   uses native or translated LBA addressing</span>
00167 <span class="comment">//   given autodetected drive type</span>
00168 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectors(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00169                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00170                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00171                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00172 
00173 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectors(  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00174                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00175                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00176                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer);
00177 
00178 <span class="comment">//unsigned char IdentifyDrive(unsigned char DriveNo,  unsigned char *Buffer, tdefDriveInfo *DriveInfo);</span>
00179 <span class="comment">//unsigned char SetMode(unsigned char DriveNo, unsigned char Mode, unsigned char PwrDown);</span>
00180 <span class="comment">//unsigned char ATA_Idle(unsigned char Drive);</span>
00181 
00182 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:30 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
