<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>timer.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>timer.c</h1><a href="timer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file timer.c \brief System Timer function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer.c'</span>
00005 <span class="comment">// Title        : System Timer function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 07/09/2003</span>
00009 <span class="comment">// Version      : 1.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">    #include &lt;avr/sleep.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00028 
00029 <span class="comment">// Program ROM constants</span>
00030 <span class="comment">// the prescale division values stored in 2^n format</span>
00031 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00032 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,0,3,6,8,10};
00033 <span class="comment">// the prescale division values stored in 2^n format</span>
00034 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00035 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,0,3,5,6,7,8,10};
00036 
00037 
00038 <span class="comment">// Global variables</span>
00039 <span class="comment">// time registers</span>
00040 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00041 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00042 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00043 
00044 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00045 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00046 
00047 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00048 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00049 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00050 <span class="keywordtype">void</span> delay(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> us) 
00051 {
00052     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00053     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00054 
00055     delay_loops = (us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00056 
00057     <span class="comment">// one loop takes 5 cpu cycles </span>
00058     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00059 } 
00060 
<a name="l00061"></a><a class="code" href="timer_8c.html#a7">00061</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a7">timerInit</a>(<span class="keywordtype">void</span>)
00062 {
00063     u08 intNum;
00064     <span class="comment">// detach all user functions from interrupts</span>
00065     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00066         <a class="code" href="timer_8c.html#a13">timerDetach</a>(intNum);
00067 
00068     <span class="comment">// initialize all timers</span>
00069     <a class="code" href="timer_8c.html#a8">timer0Init</a>();
00070     <a class="code" href="timer_8c.html#a9">timer1Init</a>();
00071 <span class="preprocessor">    #ifdef TCNT2    // support timer2 only if it exists</span>
00072 <span class="preprocessor"></span>    timer2Init();
00073 <span class="preprocessor">    #endif</span>
00074 <span class="preprocessor"></span>    <span class="comment">// enable interrupts</span>
00075     sei();
00076 }
00077 
<a name="l00078"></a><a class="code" href="timer_8c.html#a8">00078</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a8">timer0Init</a>()
00079 {
00080     <span class="comment">// initialize timer 0</span>
00081     <a class="code" href="timer_8c.html#a10">timer0SetPrescaler</a>( TIMER0PRESCALE );   <span class="comment">// set prescaler</span>
00082     outp(0, TCNT0);                         <span class="comment">// reset TCNT0</span>
00083     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00084 
00085     <a class="code" href="timer_8c.html#a15">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00086 }
00087 
<a name="l00088"></a><a class="code" href="timer_8c.html#a9">00088</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a9">timer1Init</a>(<span class="keywordtype">void</span>)
00089 {
00090     <span class="comment">// initialize timer 1</span>
00091     <a class="code" href="timer_8c.html#a11">timer1SetPrescaler</a>( TIMER1PRESCALE );   <span class="comment">// set prescaler</span>
00092     outp(0, TCNT1H);                        <span class="comment">// reset TCNT1</span>
00093     outp(0, TCNT1L);
00094     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00095 }
00096 
00097 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00098 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00099 {
00100     <span class="comment">// initialize timer 2</span>
00101     timer2SetPrescaler( TIMER2PRESCALE );   <span class="comment">// set prescaler</span>
00102     outp(0, TCNT2);                         <span class="comment">// reset TCNT2</span>
00103     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00104 
00105     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00106 }
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
<a name="l00109"></a><a class="code" href="timer_8c.html#a10">00109</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a10">timer0SetPrescaler</a>(u08 prescale)
00110 {
00111     <span class="comment">// set prescaler on timer 0</span>
00112     outp( (inp(TCCR0) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR0);
00113 }
00114 
<a name="l00115"></a><a class="code" href="timer_8c.html#a11">00115</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a11">timer1SetPrescaler</a>(u08 prescale)
00116 {
00117     <span class="comment">// set prescaler on timer 1</span>
00118     outp( (inp(TCCR1B) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR1B);
00119 }
00120 
00121 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00122 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2SetPrescaler(u08 prescale)
00123 {
00124     <span class="comment">// set prescaler on timer 2</span>
00125     outp( (inp(TCCR2) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR2);
00126 }
00127 <span class="preprocessor">#endif</span>
00128 <span class="preprocessor"></span>
<a name="l00129"></a><a class="code" href="timer_8c.html#a12">00129</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a12">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00130 {
00131     <span class="comment">// make sure the interrupt number is within bounds</span>
00132     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00133     {
00134         <span class="comment">// set the interrupt function to run</span>
00135         <span class="comment">// the supplied user's function</span>
00136         TimerIntFunc[interruptNum] = userFunc;
00137     }
00138 }
00139 
<a name="l00140"></a><a class="code" href="timer_8c.html#a13">00140</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a13">timerDetach</a>(u08 interruptNum)
00141 {
00142     <span class="comment">// make sure the interrupt number is within bounds</span>
00143     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00144     {
00145         <span class="comment">// set the interrupt function to run nothing</span>
00146         TimerIntFunc[interruptNum] = 0;
00147     }
00148 }
00149 <span class="comment">/*</span>
00150 <span class="comment">u32 timerMsToTics(u16 ms)</span>
00151 <span class="comment">{</span>
00152 <span class="comment">    // calculate the prescaler division rate</span>
00153 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR0)));</span>
00154 <span class="comment">    // calculate the number of timer tics in x milliseconds</span>
00155 <span class="comment">    return (ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00156 <span class="comment">}</span>
00157 <span class="comment"></span>
00158 <span class="comment">u16 timerTicsToMs(u32 tics)</span>
00159 <span class="comment">{</span>
00160 <span class="comment">    // calculate the prescaler division rate</span>
00161 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR0)));</span>
00162 <span class="comment">    // calculate the number of milliseconds in x timer tics</span>
00163 <span class="comment">    return (tics*1000*(prescaleDiv*256))/F_CPU;</span>
00164 <span class="comment">}</span>
00165 <span class="comment">*/</span>
<a name="l00166"></a><a class="code" href="timer_8c.html#a14">00166</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a14">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00167 {
00168     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00169     u08 timerThres;
00170     u32 ticRateHz;
00171     u32 pause;
00172 
00173     <span class="comment">// capture current pause timer value</span>
00174     timerThres = inb(TCNT0);
00175     <span class="comment">// reset pause timer overflow count</span>
00176     TimerPauseReg = 0;
00177     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00178     <span class="comment">// prescaler division = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR0)))</span>
00179     ticRateHz = F_CPU/(1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR0))));
00180     <span class="comment">// precision management</span>
00181     <span class="keywordflow">if</span>( ticRateHz &gt; 1000000)
00182         pause = pause_ms*(ticRateHz/1000);
00183     <span class="keywordflow">else</span>
00184         pause = (pause_ms*ticRateHz)/1000;
00185     
00186     <span class="comment">// loop until time expires</span>
00187     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT0)) &lt; (pause+timerThres) )
00188     {
00189         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00190         {
00191             <span class="comment">// save power by idling the processor</span>
00192             set_sleep_mode(SLEEP_MODE_IDLE);
00193             sleep_mode();
00194         }
00195     }
00196 
00197     <span class="comment">/* old inaccurate code, for reference</span>
00198 <span class="comment">    </span>
00199 <span class="comment">    // calculate delay for [pause_ms] milliseconds</span>
00200 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR0)));</span>
00201 <span class="comment">    u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00202 <span class="comment">    </span>
00203 <span class="comment">    TimerPauseReg = 0;</span>
00204 <span class="comment">    while(TimerPauseReg &lt; pause);</span>
00205 <span class="comment"></span>
00206 <span class="comment">    */</span>
00207 }
00208 
<a name="l00209"></a><a class="code" href="timer_8c.html#a15">00209</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a15">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00210 {
00211     <span class="comment">// clear the timer overflow counter registers</span>
00212     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00213 }
00214 
<a name="l00215"></a><a class="code" href="timer_8c.html#a16">00215</a> <span class="keywordtype">long</span> <a class="code" href="timer_8c.html#a16">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00216 {
00217     <span class="comment">// return the current timer overflow count</span>
00218     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00219     <span class="keywordflow">return</span> Timer0Reg0;
00220 }
00221 
00222 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00223 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00224 {
00225     <span class="comment">// clear the timer overflow counter registers</span>
00226     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00227 }
00228 
00229 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00230 {
00231     <span class="comment">// return the current timer overflow count</span>
00232     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00233     <span class="keywordflow">return</span> Timer2Reg0;
00234 }
00235 <span class="preprocessor">#endif</span>
00236 <span class="preprocessor"></span>
<a name="l00237"></a><a class="code" href="timer_8c.html#a17">00237</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a17">timer1PWMInit</a>(u08 bitRes)
00238 {
00239     <span class="comment">// configures timer1 for use with PWM output</span>
00240     <span class="comment">// on OC1A and OC1B pins</span>
00241 
00242     <span class="comment">// enable timer1 as 8,9,10bit PWM</span>
00243     <span class="keywordflow">if</span>(bitRes == 9)
00244     {   <span class="comment">// 9bit mode</span>
00245         sbi(TCCR1A,PWM11);
00246         cbi(TCCR1A,PWM10);
00247     }
00248     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00249     {   <span class="comment">// 10bit mode</span>
00250         sbi(TCCR1A,PWM11);
00251         sbi(TCCR1A,PWM10);
00252     }
00253     <span class="keywordflow">else</span>
00254     {   <span class="comment">// default 8bit mode</span>
00255         cbi(TCCR1A,PWM11);
00256         sbi(TCCR1A,PWM10);
00257     }
00258 
00259     <span class="comment">// clear output compare value A</span>
00260     outp(0, OCR1AH);
00261     outp(0, OCR1AL);
00262     <span class="comment">// clear output compare value B</span>
00263     outp(0, OCR1BH);
00264     outp(0, OCR1BL);
00265 }
00266 
<a name="l00267"></a><a class="code" href="timer_8c.html#a18">00267</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a18">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00268 {
00269     <span class="comment">// turn off timer1 PWM mode</span>
00270     cbi(TCCR1A,PWM11);
00271     cbi(TCCR1A,PWM10);
00272     <span class="comment">// set PWM1A/B (OutputCompare action) to none</span>
00273     <a class="code" href="timer_8c.html#a21">timer1PWMAOff</a>();
00274     <a class="code" href="timer_8c.html#a22">timer1PWMBOff</a>();
00275 }
00276 
<a name="l00277"></a><a class="code" href="timer_8c.html#a19">00277</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a19">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00278 {
00279     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00280     <span class="comment">// set OC1A as non-inverted PWM</span>
00281     sbi(TCCR1A,COM1A1);
00282     cbi(TCCR1A,COM1A0);
00283 }
00284 
<a name="l00285"></a><a class="code" href="timer_8c.html#a20">00285</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a20">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00286 {
00287     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00288     <span class="comment">// set OC1B as non-inverted PWM</span>
00289     sbi(TCCR1A,COM1B1);
00290     cbi(TCCR1A,COM1B0);
00291 }
00292 
<a name="l00293"></a><a class="code" href="timer_8c.html#a21">00293</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a21">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00294 {
00295     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00296     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00297     cbi(TCCR1A,COM1A1);
00298     cbi(TCCR1A,COM1A0);
00299 }
00300 
<a name="l00301"></a><a class="code" href="timer_8c.html#a22">00301</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a22">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00302 {
00303     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00304     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00305     cbi(TCCR1A,COM1B1);
00306     cbi(TCCR1A,COM1B0);
00307 }
00308 
<a name="l00309"></a><a class="code" href="timer_8c.html#a23">00309</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a23">timer1PWMASet</a>(u16 pwmDuty)
00310 {
00311     <span class="comment">// set PWM (output compare) duty for channel A</span>
00312     <span class="comment">// this PWM output is generated on OC1A pin</span>
00313     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00314     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00315     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00316     outp( (pwmDuty&gt;&gt;8), OCR1AH);        <span class="comment">// set the high 8bits of OCR1A</span>
00317     outp( (pwmDuty&amp;0x00FF), OCR1AL);    <span class="comment">// set the low 8bits of OCR1A</span>
00318 }
00319 
<a name="l00320"></a><a class="code" href="timer_8c.html#a24">00320</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a24">timer1PWMBSet</a>(u16 pwmDuty)
00321 {
00322     <span class="comment">// set PWM (output compare) duty for channel B</span>
00323     <span class="comment">// this PWM output is generated on OC1B pin</span>
00324     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00325     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00326     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00327     outp( (pwmDuty&gt;&gt;8), OCR1BH);        <span class="comment">// set the high 8bits of OCR1B</span>
00328     outp( (pwmDuty&amp;0x00FF), OCR1BL);    <span class="comment">// set the low 8bits of OCR1B</span>
00329 }
00330 <span class="comment"></span>
00331 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00332"></a><a class="code" href="timer_8c.html#a25">00332</a> <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW0)
00333 {
00334     Timer0Reg0++;           <span class="comment">// increment low-order counter</span>
00335 
00336     <span class="comment">// increment pause counter</span>
00337     TimerPauseReg++;
00338 
00339     <span class="comment">// if a user function is defined, execute it too</span>
00340     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00341         TimerIntFunc[TIMER0OVERFLOW_INT]();
00342 }
00343 <span class="comment"></span>
00344 <span class="comment">//! Interrupt handler for tcnt1 overflow interrupt</span>
00345 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW1)
00346 {
00347     <span class="comment">// if a user function is defined, execute it</span>
00348     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00349         TimerIntFunc[TIMER1OVERFLOW_INT]();
00350 }
00351 
00352 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00353 <span class="preprocessor"></span><span class="comment">//! Interrupt handler for tcnt2 overflow interrupt</span>
00354 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW2)
00355 {
00356     Timer2Reg0++;           <span class="comment">// increment low-order counter</span>
00357 
00358     <span class="comment">// if a user function is defined, execute it</span>
00359     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00360         TimerIntFunc[TIMER2OVERFLOW_INT]();
00361 }
00362 <span class="preprocessor">#endif</span>
00363 <span class="preprocessor"></span>
00364 <span class="preprocessor">#ifdef OC0</span>
00365 <span class="preprocessor"></span><span class="comment">// include support for Output Compare 0 for new AVR processors that support it</span><span class="comment"></span>
00366 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00367 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00368 {
00369     <span class="comment">// if a user function is defined, execute it</span>
00370     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00371         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00372 }
00373 <span class="preprocessor">#endif</span>
00374 <span class="preprocessor"></span><span class="comment"></span>
00375 <span class="comment">//! Interrupt handler for CutputCompare1A match (OC1A) interrupt</span>
00376 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE1A)
00377 {
00378     <span class="comment">// if a user function is defined, execute it</span>
00379     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00380         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00381 }
00382 <span class="comment"></span>
00383 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
00384 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE1B)
00385 {
00386     <span class="comment">// if a user function is defined, execute it</span>
00387     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00388         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00389 }
00390 <span class="comment"></span>
00391 <span class="comment">//! Interrupt handler for InputCapture1 (IC1) interrupt</span>
00392 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_INPUT_CAPTURE1)
00393 {
00394     <span class="comment">// if a user function is defined, execute it</span>
00395     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00396         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00397 }
00398 <span class="comment"></span>
00399 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
00400 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE2)
00401 {
00402     <span class="comment">// if a user function is defined, execute it</span>
00403     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00404         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00405 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
