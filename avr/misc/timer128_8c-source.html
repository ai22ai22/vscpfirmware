<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>timer128.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>timer128.c</h1><a href="timer128_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file timer128.c \brief System Timer function library for Mega128. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer128.c'</span>
00005 <span class="comment">// Title        : System Timer function library for Mega128</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2003</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 02/24/2003</span>
00009 <span class="comment">// Version      : 1.2</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="timer128_8h.html">timer128.h</a>"</span>
00027 
00028 <span class="comment">// Program ROM constants</span>
00029 <span class="comment">// the prescale division values stored in 2^n format</span>
00030 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00031 <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,0,3,6,8,10};
00032 <span class="comment">// the prescale division values stored in 2^n format</span>
00033 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00034 <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,0,3,5,6,7,8,10};
00035 
00036 <span class="comment">// Global variables</span>
00037 <span class="comment">// time registers</span>
00038 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00039 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00040 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg1;
00041 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00042 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg1;
00043 
00044 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00045 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00046 
00047 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00048 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00049 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00050 <span class="keywordtype">void</span> delay(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> us) 
00051 {
00052     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00053     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00054 
00055     delay_loops = (us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00056 
00057     <span class="comment">// one loop takes 5 cpu cycles </span>
00058     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00059 } 
00060 
<a name="l00061"></a><a class="code" href="timer128_8c.html#a9">00061</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a7">timerInit</a>(<span class="keywordtype">void</span>)
00062 {
00063     u08 intNum;
00064     <span class="comment">// detach all user functions from interrupts</span>
00065     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00066         <a class="code" href="timer_8c.html#a13">timerDetach</a>(intNum);
00067 
00068     <span class="comment">// initialize all timers</span>
00069     <a class="code" href="timer_8c.html#a8">timer0Init</a>();
00070     <a class="code" href="timer_8c.html#a9">timer1Init</a>();
00071     timer2Init();
00072     timer3Init();
00073     <span class="comment">// enable interrupts</span>
00074     sei();
00075 }
00076 
<a name="l00077"></a><a class="code" href="timer128_8c.html#a10">00077</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a8">timer0Init</a>()
00078 {
00079     <span class="comment">// initialize timer 0</span>
00080     <a class="code" href="timer_8c.html#a10">timer0SetPrescaler</a>( TIMER0PRESCALE );   <span class="comment">// set prescaler</span>
00081     outp(0, TCNT0);                         <span class="comment">// reset TCNT0</span>
00082     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00083 
00084     <a class="code" href="timer_8c.html#a15">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00085 }
00086 
<a name="l00087"></a><a class="code" href="timer128_8c.html#a11">00087</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a9">timer1Init</a>(<span class="keywordtype">void</span>)
00088 {
00089     <span class="comment">// initialize timer 1</span>
00090     <a class="code" href="timer_8c.html#a11">timer1SetPrescaler</a>( TIMER1PRESCALE );   <span class="comment">// set prescaler</span>
00091     outp(0, TCNT1H);                        <span class="comment">// reset TCNT1</span>
00092     outp(0, TCNT1L);
00093     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00094 }
00095 
00096 <span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00097 {
00098     <span class="comment">// initialize timer 2</span>
00099     timer2SetPrescaler( TIMER2PRESCALE );   <span class="comment">// set prescaler</span>
00100     outp(0, TCNT2);                         <span class="comment">// reset TCNT2</span>
00101     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00102 
00103     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00104 }
00105 
00106 <span class="keywordtype">void</span> timer3Init(<span class="keywordtype">void</span>)
00107 {
00108     <span class="comment">// initialize timer 3</span>
00109     timer3SetPrescaler( TIMER3PRESCALE );   <span class="comment">// set prescaler</span>
00110     outp(0, TCNT3H);                        <span class="comment">// reset TCNT3</span>
00111     outp(0, TCNT3L);
00112     sbi(ETIMSK, TOIE3);                     <span class="comment">// enable TCNT3 overflow</span>
00113 }
00114 
<a name="l00115"></a><a class="code" href="timer128_8c.html#a14">00115</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a10">timer0SetPrescaler</a>(u08 prescale)
00116 {
00117     <span class="comment">// set prescaler on timer 0</span>
00118     outp( (inp(TCCR0) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR0);
00119 }
00120 
<a name="l00121"></a><a class="code" href="timer128_8c.html#a15">00121</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a11">timer1SetPrescaler</a>(u08 prescale)
00122 {
00123     <span class="comment">// set prescaler on timer 1</span>
00124     outp( (inp(TCCR1B) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR1B);
00125 }
00126 
00127 <span class="keywordtype">void</span> timer2SetPrescaler(u08 prescale)
00128 {
00129     <span class="comment">// set prescaler on timer 2</span>
00130     outp( (inp(TCCR2) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR2);
00131 }
00132 
00133 <span class="keywordtype">void</span> timer3SetPrescaler(u08 prescale)
00134 {
00135     <span class="comment">// set prescaler on timer 2</span>
00136     outp( (inp(TCCR3B) &amp; ~TIMER_PRESCALE_MASK) | prescale, TCCR3B);
00137 }
00138 
<a name="l00139"></a><a class="code" href="timer128_8c.html#a18">00139</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a12">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00140 {
00141     <span class="comment">// make sure the interrupt number is within bounds</span>
00142     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00143     {
00144         <span class="comment">// set the interrupt function to run</span>
00145         <span class="comment">// the supplied user's function</span>
00146         TimerIntFunc[interruptNum] = userFunc;
00147     }
00148 }
00149 
<a name="l00150"></a><a class="code" href="timer128_8c.html#a19">00150</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a13">timerDetach</a>(u08 interruptNum)
00151 {
00152     <span class="comment">// make sure the interrupt number is within bounds</span>
00153     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00154     {
00155         <span class="comment">// set the interrupt function to run nothing</span>
00156         TimerIntFunc[interruptNum] = 0;
00157     }
00158 }
00159 
<a name="l00160"></a><a class="code" href="timer128_8c.html#a20">00160</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a14">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00161 {
00162     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00163     u08 timerThres;
00164     u32 ticRateHz;
00165     u32 pause;
00166 
00167     <span class="comment">// capture current pause timer value</span>
00168     timerThres = inb(TCNT2);
00169     <span class="comment">// reset pause timer overflow count</span>
00170     TimerPauseReg = 0;
00171     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00172     <span class="comment">// prescaler division = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR2)))</span>
00173     ticRateHz = F_CPU/(1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+inp(TCCR2))));
00174     <span class="comment">// precision management</span>
00175     <span class="keywordflow">if</span>( ticRateHz &gt; 1000000)
00176         pause = pause_ms*(ticRateHz/1000);
00177     <span class="keywordflow">else</span>
00178         pause = (pause_ms*ticRateHz)/1000;
00179     
00180     <span class="comment">// loop until time expires</span>
00181     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT2)) &lt; (pause+timerThres) )
00182     {
00183         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00184         {
00185             <span class="comment">// save power by idling the processor</span>
00186             set_sleep_mode(SLEEP_MODE_IDLE);
00187             sleep_mode();
00188         }
00189     }
00190 }
00191 
<a name="l00192"></a><a class="code" href="timer128_8c.html#a21">00192</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a15">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00193 {
00194     <span class="comment">// clear the timer overflow counter registers</span>
00195     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00196     Timer0Reg1 = 0; <span class="comment">// initialize time registers</span>
00197 }
00198 
<a name="l00199"></a><a class="code" href="timer128_8c.html#a22">00199</a> <span class="keywordtype">long</span> <a class="code" href="timer_8c.html#a16">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00200 {
00201     <span class="comment">// return the current timer overflow count</span>
00202     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00203     <span class="keywordflow">return</span> Timer0Reg0;
00204 }
00205 
00206 <span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00207 {
00208     <span class="comment">// clear the timer overflow counter registers</span>
00209     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00210     Timer2Reg1 = 0; <span class="comment">// initialize time registers</span>
00211 }
00212 
00213 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00214 {
00215     <span class="comment">// return the current timer overflow count</span>
00216     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00217     <span class="keywordflow">return</span> Timer2Reg0;
00218 }
00219 
00220 
<a name="l00221"></a><a class="code" href="timer128_8c.html#a25">00221</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a17">timer1PWMInit</a>(u08 bitRes)
00222 {
00223     <span class="comment">// configures timer1 for use with PWM output</span>
00224     <span class="comment">// on pins OC1A, OC1B, and OC1C</span>
00225 
00226     <span class="comment">// enable Timer1 as 8,9,10bit PWM</span>
00227     <span class="keywordflow">if</span>(bitRes == 9)
00228     {   <span class="comment">// 9bit mode</span>
00229         sbi(TCCR1A,WGMA1);
00230         cbi(TCCR1A,WGMA0);
00231     }
00232     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00233     {   <span class="comment">// 10bit mode</span>
00234         sbi(TCCR1A,WGMA1);
00235         sbi(TCCR1A,WGMA0);
00236     }
00237     <span class="keywordflow">else</span>
00238     {   <span class="comment">// default 8bit mode</span>
00239         cbi(TCCR1A,WGMA1);
00240         sbi(TCCR1A,WGMA0);
00241     }
00242 
00243     <span class="comment">// set clear-timer-on-compare-match</span>
00244     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00245     <span class="comment">// clear output compare value A</span>
00246     outb(OCR1AH, 0);
00247     outb(OCR1AL, 0);
00248     <span class="comment">// clear output compare value B</span>
00249     outb(OCR1BH, 0);
00250     outb(OCR1BL, 0);
00251     <span class="comment">// clear output compare value C</span>
00252     outb(OCR1CH, 0);
00253     outb(OCR1CL, 0);
00254 }
00255 
<a name="l00256"></a><a class="code" href="timer128_8c.html#a26">00256</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a18">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00257 {
00258     <span class="comment">// turn off PWM on Timer1</span>
00259     cbi(TCCR1A,WGMA1);
00260     cbi(TCCR1A,WGMA0);
00261     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00262     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00263     <span class="comment">// set PWM1A/B/C (OutputCompare action) to none</span>
00264     <a class="code" href="timer_8c.html#a21">timer1PWMAOff</a>();
00265     <a class="code" href="timer_8c.html#a22">timer1PWMBOff</a>();
00266     <a class="code" href="timer128_8c.html#a32">timer1PWMCOff</a>();
00267 }
00268 
<a name="l00269"></a><a class="code" href="timer128_8c.html#a27">00269</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a19">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00270 {
00271     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00272     <span class="comment">// set OC1A as non-inverted PWM</span>
00273     sbi(TCCR1A,COMA1);
00274     cbi(TCCR1A,COMA0);
00275 }
00276 
<a name="l00277"></a><a class="code" href="timer128_8c.html#a28">00277</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a20">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00278 {
00279     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00280     <span class="comment">// set OC1B as non-inverted PWM</span>
00281     sbi(TCCR1A,COMB1);
00282     cbi(TCCR1A,COMB0);
00283 }
00284 
<a name="l00285"></a><a class="code" href="timer128_8c.html#a29">00285</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a29">timer1PWMCOn</a>(<span class="keywordtype">void</span>)
00286 {
00287     <span class="comment">// turn on channel C (OC1C) PWM output</span>
00288     <span class="comment">// set OC1C as non-inverted PWM</span>
00289     sbi(TCCR1A,COMC1);
00290     cbi(TCCR1A,COMC0);
00291 }
00292 
<a name="l00293"></a><a class="code" href="timer128_8c.html#a30">00293</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a21">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00294 {
00295     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00296     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00297     cbi(TCCR1A,COMA1);
00298     cbi(TCCR1A,COMA0);
00299 }
00300 
<a name="l00301"></a><a class="code" href="timer128_8c.html#a31">00301</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a22">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00302 {
00303     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00304     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00305     cbi(TCCR1A,COMB1);
00306     cbi(TCCR1A,COMB0);
00307 }
00308 
<a name="l00309"></a><a class="code" href="timer128_8c.html#a32">00309</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a32">timer1PWMCOff</a>(<span class="keywordtype">void</span>)
00310 {
00311     <span class="comment">// turn off channel C (OC1C) PWM output</span>
00312     <span class="comment">// set OC1C (OutputCompare action) to none</span>
00313     cbi(TCCR1A,COMC1);
00314     cbi(TCCR1A,COMC0);
00315 }
00316 
<a name="l00317"></a><a class="code" href="timer128_8c.html#a33">00317</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a23">timer1PWMASet</a>(u16 pwmDuty)
00318 {
00319     <span class="comment">// set PWM (output compare) duty for channel A</span>
00320     <span class="comment">// this PWM output is generated on OC1A pin</span>
00321     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00322     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00323     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00324     outp( (pwmDuty&gt;&gt;8), OCR1AH);        <span class="comment">// set the high 8bits of OCR1A</span>
00325     outp( (pwmDuty&amp;0x00FF), OCR1AL);    <span class="comment">// set the low 8bits of OCR1A</span>
00326 }
00327 
<a name="l00328"></a><a class="code" href="timer128_8c.html#a34">00328</a> <span class="keywordtype">void</span> <a class="code" href="timer_8c.html#a24">timer1PWMBSet</a>(u16 pwmDuty)
00329 {
00330     <span class="comment">// set PWM (output compare) duty for channel B</span>
00331     <span class="comment">// this PWM output is generated on OC1B pin</span>
00332     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00333     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00334     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00335     outp( (pwmDuty&gt;&gt;8), OCR1BH);        <span class="comment">// set the high 8bits of OCR1B</span>
00336     outp( (pwmDuty&amp;0x00FF), OCR1BL);    <span class="comment">// set the low 8bits of OCR1B</span>
00337 }
00338 
<a name="l00339"></a><a class="code" href="timer128_8c.html#a35">00339</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a35">timer1PWMCSet</a>(u16 pwmDuty)
00340 {
00341     <span class="comment">// set PWM (output compare) duty for channel C</span>
00342     <span class="comment">// this PWM output is generated on OC1C pin</span>
00343     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00344     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00345     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00346     outp( (pwmDuty&gt;&gt;8), OCR1CH);        <span class="comment">// set the high 8bits of OCR1C</span>
00347     outp( (pwmDuty&amp;0x00FF), OCR1CL);    <span class="comment">// set the low 8bits of OCR1C</span>
00348 }
00349 
00350 
<a name="l00351"></a><a class="code" href="timer128_8c.html#a36">00351</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a36">timer3PWMInit</a>(u08 bitRes)
00352 {
00353     <span class="comment">// configures timer1 for use with PWM output</span>
00354     <span class="comment">// on pins OC3A, OC3B, and OC3C</span>
00355 
00356     <span class="comment">// enable Timer3 as 8,9,10bit PWM</span>
00357     <span class="keywordflow">if</span>(bitRes == 9)
00358     {   <span class="comment">// 9bit mode</span>
00359         sbi(TCCR3A,WGMA1);
00360         cbi(TCCR3A,WGMA0);
00361     }
00362     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00363     {   <span class="comment">// 10bit mode</span>
00364         sbi(TCCR3A,WGMA1);
00365         sbi(TCCR3A,WGMA0);
00366     }
00367     <span class="keywordflow">else</span>
00368     {   <span class="comment">// default 8bit mode</span>
00369         cbi(TCCR3A,WGMA1);
00370         sbi(TCCR3A,WGMA0);
00371     }
00372 
00373     <span class="comment">// set clear-timer-on-compare-match</span>
00374     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00375     <span class="comment">// clear output compare value A</span>
00376     outb(OCR3AH, 0);
00377     outb(OCR3AL, 0);
00378     <span class="comment">// clear output compare value B</span>
00379     outb(OCR3BH, 0);
00380     outb(OCR3BL, 0);
00381     <span class="comment">// clear output compare value B</span>
00382     outb(OCR3CH, 0);
00383     outb(OCR3CL, 0);
00384 }
00385 
<a name="l00386"></a><a class="code" href="timer128_8c.html#a37">00386</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a37">timer3PWMOff</a>(<span class="keywordtype">void</span>)
00387 {
00388     <span class="comment">// turn off PWM mode on Timer3</span>
00389     cbi(TCCR3A,WGMA1);
00390     cbi(TCCR3A,WGMA0);
00391     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00392     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00393     <span class="comment">// set OC3A/B/C (OutputCompare action) to none</span>
00394     <a class="code" href="timer128_8c.html#a41">timer3PWMAOff</a>();
00395     <a class="code" href="timer128_8c.html#a42">timer3PWMBOff</a>();
00396     <a class="code" href="timer128_8c.html#a43">timer3PWMCOff</a>();
00397 }
00398 
<a name="l00399"></a><a class="code" href="timer128_8c.html#a38">00399</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a38">timer3PWMAOn</a>(<span class="keywordtype">void</span>)
00400 {
00401     <span class="comment">// turn on channel A (OC3A) PWM output</span>
00402     <span class="comment">// set OC3A as non-inverted PWM</span>
00403     sbi(TCCR3A,COMA1);
00404     cbi(TCCR3A,COMA0);
00405 }
00406 
<a name="l00407"></a><a class="code" href="timer128_8c.html#a39">00407</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a39">timer3PWMBOn</a>(<span class="keywordtype">void</span>)
00408 {
00409     <span class="comment">// turn on channel B (OC3B) PWM output</span>
00410     <span class="comment">// set OC3B as non-inverted PWM</span>
00411     sbi(TCCR3A,COMB1);
00412     cbi(TCCR3A,COMB0);
00413 }
00414 
<a name="l00415"></a><a class="code" href="timer128_8c.html#a40">00415</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a40">timer3PWMCOn</a>(<span class="keywordtype">void</span>)
00416 {
00417     <span class="comment">// turn on channel C (OC3C) PWM output</span>
00418     <span class="comment">// set OC3C as non-inverted PWM</span>
00419     sbi(TCCR3A,COMC1);
00420     cbi(TCCR3A,COMC0);
00421 }
00422 
<a name="l00423"></a><a class="code" href="timer128_8c.html#a41">00423</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a41">timer3PWMAOff</a>(<span class="keywordtype">void</span>)
00424 {
00425     <span class="comment">// turn off channel A (OC3A) PWM output</span>
00426     <span class="comment">// set OC3A (OutputCompare action) to none</span>
00427     cbi(TCCR3A,COMA1);
00428     cbi(TCCR3A,COMA0);
00429 }
00430 
<a name="l00431"></a><a class="code" href="timer128_8c.html#a42">00431</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a42">timer3PWMBOff</a>(<span class="keywordtype">void</span>)
00432 {
00433     <span class="comment">// turn off channel B (OC3B) PWM output</span>
00434     <span class="comment">// set OC3B (OutputCompare action) to none</span>
00435     cbi(TCCR3A,COMB1);
00436     cbi(TCCR3A,COMB0);
00437 }
00438 
<a name="l00439"></a><a class="code" href="timer128_8c.html#a43">00439</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a43">timer3PWMCOff</a>(<span class="keywordtype">void</span>)
00440 {
00441     <span class="comment">// turn off channel C (OC3C) PWM output</span>
00442     <span class="comment">// set OC3C (OutputCompare action) to none</span>
00443     cbi(TCCR3A,COMC1);
00444     cbi(TCCR3A,COMC0);
00445 }
00446 
<a name="l00447"></a><a class="code" href="timer128_8c.html#a44">00447</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a44">timer3PWMASet</a>(u16 pwmDuty)
00448 {
00449     <span class="comment">// set PWM (output compare) duty for channel A</span>
00450     <span class="comment">// this PWM output is generated on OC3A pin</span>
00451     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00452     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00453     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00454     outp( (pwmDuty&gt;&gt;8), OCR3AH);        <span class="comment">// set the high 8bits of OCR3A</span>
00455     outp( (pwmDuty&amp;0x00FF), OCR3AL);    <span class="comment">// set the low 8bits of OCR3A</span>
00456 }
00457 
<a name="l00458"></a><a class="code" href="timer128_8c.html#a45">00458</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a45">timer3PWMBSet</a>(u16 pwmDuty)
00459 {
00460     <span class="comment">// set PWM (output compare) duty for channel B</span>
00461     <span class="comment">// this PWM output is generated on OC3B pin</span>
00462     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00463     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00464     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00465     outp( (pwmDuty&gt;&gt;8), OCR3BH);        <span class="comment">// set the high 8bits of OCR3B</span>
00466     outp( (pwmDuty&amp;0x00FF), OCR3BL);    <span class="comment">// set the low 8bits of OCR3B</span>
00467 }
00468 
<a name="l00469"></a><a class="code" href="timer128_8c.html#a46">00469</a> <span class="keywordtype">void</span> <a class="code" href="timer128_8c.html#a46">timer3PWMCSet</a>(u16 pwmDuty)
00470 {
00471     <span class="comment">// set PWM (output compare) duty for channel B</span>
00472     <span class="comment">// this PWM output is generated on OC3C pin</span>
00473     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00474     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00475     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00476     outp( (pwmDuty&gt;&gt;8), OCR3CH);        <span class="comment">// set the high 8bits of OCR3C</span>
00477     outp( (pwmDuty&amp;0x00FF), OCR3CL);    <span class="comment">// set the low 8bits of OCR3C</span>
00478 }
00479 
00480 <span class="comment"></span>
00481 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00482"></a><a class="code" href="timer128_8c.html#a47">00482</a> <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW0)
00483 {
00484     Timer0Reg0++;       <span class="comment">// increment low-order counter</span>
00485     <span class="keywordflow">if</span>(!Timer0Reg0)     <span class="comment">// if low-order counter rollover</span>
00486         Timer0Reg1++;   <span class="comment">// increment high-order counter </span>
00487 
00488     <span class="comment">// if a user function is defined, execute it too</span>
00489     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00490         TimerIntFunc[TIMER0OVERFLOW_INT]();
00491 }
00492 <span class="comment"></span>
00493 <span class="comment">//! Interrupt handler for Timer1 overflow interrupt</span>
00494 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW1)
00495 {
00496     <span class="comment">// if a user function is defined, execute it</span>
00497     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00498         TimerIntFunc[TIMER1OVERFLOW_INT]();
00499 }
00500 <span class="comment"></span>
00501 <span class="comment">//! Interrupt handler for Timer2 overflow interrupt</span>
00502 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW2)
00503 {
00504     Timer2Reg0++;       <span class="comment">// increment low-order counter</span>
00505     <span class="keywordflow">if</span>(!Timer2Reg0)     <span class="comment">// if low-order counter rollover</span>
00506         Timer2Reg1++;   <span class="comment">// increment high-order counter </span>
00507 
00508     <span class="comment">// increment pause counter</span>
00509     TimerPauseReg++;
00510 
00511     <span class="comment">// if a user function is defined, execute it</span>
00512     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00513         TimerIntFunc[TIMER2OVERFLOW_INT]();
00514 }
00515 <span class="comment"></span>
00516 <span class="comment">//! Interrupt handler for Timer3 overflow interrupt</span>
00517 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OVERFLOW3)
00518 {
00519     <span class="comment">// if a user function is defined, execute it</span>
00520     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OVERFLOW_INT])
00521         TimerIntFunc[TIMER3OVERFLOW_INT]();
00522 }
00523 <span class="comment"></span>
00524 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00525 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE0)
00526 {
00527     <span class="comment">// if a user function is defined, execute it</span>
00528     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00529         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00530 }
00531 <span class="comment"></span>
00532 <span class="comment">//! Interrupt handler for OutputCompare1A match (OC1A) interrupt</span>
00533 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE1A)
00534 {
00535     <span class="comment">// if a user function is defined, execute it</span>
00536     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00537         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00538 }
00539 <span class="comment"></span>
00540 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
00541 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE1B)
00542 {
00543     <span class="comment">// if a user function is defined, execute it</span>
00544     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00545         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00546 }
00547 <span class="comment"></span>
00548 <span class="comment">//! Interrupt handler for OutputCompare1C match (OC1C) interrupt</span>
00549 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE1C)
00550 {
00551     <span class="comment">// if a user function is defined, execute it</span>
00552     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREC_INT])
00553         TimerIntFunc[TIMER1OUTCOMPAREC_INT]();
00554 }
00555 <span class="comment"></span>
00556 <span class="comment">//! Interrupt handler for InputCapture1(IC1) interrupt</span>
00557 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_INPUT_CAPTURE1)
00558 {
00559     <span class="comment">// if a user function is defined, execute it</span>
00560     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00561         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00562 }
00563 <span class="comment"></span>
00564 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
00565 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE2)
00566 {
00567     <span class="comment">// if a user function is defined, execute it</span>
00568     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00569         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00570 }
00571 <span class="comment"></span>
00572 <span class="comment">//! Interrupt handler for OutputCompare3A match (OC3A) interrupt</span>
00573 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE3A)
00574 {
00575     <span class="comment">// if a user function is defined, execute it</span>
00576     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREA_INT])
00577         TimerIntFunc[TIMER3OUTCOMPAREA_INT]();
00578 }
00579 <span class="comment"></span>
00580 <span class="comment">//! Interrupt handler for OutputCompare3B match (OC3B) interrupt</span>
00581 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE3B)
00582 {
00583     <span class="comment">// if a user function is defined, execute it</span>
00584     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00585         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00586 }
00587 <span class="comment"></span>
00588 <span class="comment">//! Interrupt handler for OutputCompare3C match (OC3C) interrupt</span>
00589 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_OUTPUT_COMPARE3C)
00590 {
00591     <span class="comment">// if a user function is defined, execute it</span>
00592     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREC_INT])
00593         TimerIntFunc[TIMER3OUTCOMPAREC_INT]();
00594 }
00595 <span class="comment"></span>
00596 <span class="comment">//! Interrupt handler for InputCapture3 (IC3) interrupt</span>
00597 <span class="comment"></span><a class="code" href="timer128_8c.html#a47">TIMER_INTERRUPT_HANDLER</a>(SIG_INPUT_CAPTURE3)
00598 {
00599     <span class="comment">// if a user function is defined, execute it</span>
00600     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3INPUTCAPTURE_INT])
00601         TimerIntFunc[TIMER3INPUTCAPTURE_INT]();
00602 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
