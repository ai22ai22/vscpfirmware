<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uart2.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>uart2.c</h1><a href="uart2_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file uart2.c \brief Dual UART driver with buffer support. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uart2.c'</span>
00005 <span class="comment">// Title        : Dual UART driver with buffer support</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2003</span>
00007 <span class="comment">// Created      : 11/20/2000</span>
00008 <span class="comment">// Revised      : 06/09/2003</span>
00009 <span class="comment">// Version      : 1.0</span>
00010 <span class="comment">// Target MCU   : ATMEL AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description  : This is a UART driver for AVR-series processors with two</span>
00014 <span class="comment">//      hardware UARTs such as the mega161 and mega128 </span>
00015 <span class="comment">//</span>
00016 <span class="comment">// This code is distributed under the GNU Public License</span>
00017 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00018 <span class="comment">//</span>
00019 <span class="comment">//*****************************************************************************</span>
00020 
00021 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00022 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00023 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="uart2_8h.html">uart2.h</a>"</span>
00027 
00028 <span class="comment">// UART global variables</span>
00029 <span class="comment">// flag variables</span>
00030 <span class="keyword">volatile</span> u08   uartReadyTx[2];
00031 <span class="keyword">volatile</span> u08   uartBufferedTx[2];
00032 <span class="comment">// receive and transmit buffers</span>
00033 cBuffer uartRxBuffer[2];
00034 cBuffer uartTxBuffer[2];
00035 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> uartRxOverflow[2];
00036 <span class="preprocessor">#ifndef UART_BUFFERS_EXTERNAL_RAM</span>
00037 <span class="preprocessor"></span>    <span class="comment">// using internal ram,</span>
00038     <span class="comment">// automatically allocate space in ram for each buffer</span>
00039     <span class="keyword">static</span> <span class="keywordtype">char</span> uart0RxData[<a class="code" href="uart2_8h.html#a3">UART0_RX_BUFFER_SIZE</a>];
00040     <span class="keyword">static</span> <span class="keywordtype">char</span> uart0TxData[<a class="code" href="uart2_8h.html#a2">UART0_TX_BUFFER_SIZE</a>];
00041     <span class="keyword">static</span> <span class="keywordtype">char</span> uart1RxData[<a class="code" href="uart2_8h.html#a5">UART1_RX_BUFFER_SIZE</a>];
00042     <span class="keyword">static</span> <span class="keywordtype">char</span> uart1TxData[<a class="code" href="uart2_8h.html#a4">UART1_TX_BUFFER_SIZE</a>];
00043 <span class="preprocessor">#endif</span>
00044 <span class="preprocessor"></span>
00045 <span class="keyword">typedef</span> void (*voidFuncPtru08)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
00046 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtru08 UartRxFunc[2];
00047 
<a name="l00048"></a><a class="code" href="uart2_8c.html#a11">00048</a> <span class="keywordtype">void</span> <a class="code" href="uart_8c.html#a9">uartInit</a>(<span class="keywordtype">void</span>)
00049 {
00050     <span class="comment">// initialize the buffers</span>
00051     <a class="code" href="uart_8c.html#a10">uartInitBuffers</a>();
00052     <span class="comment">// initialize user receive handlers</span>
00053     UartRxFunc[0] = 0;
00054     UartRxFunc[1] = 0;
00055 
00056     <span class="comment">// enable RxD/TxD and interrupts</span>
00057 <span class="preprocessor">    #ifdef UCR</span>
00058 <span class="preprocessor"></span>        <span class="comment">// this line for AT90S8515,8535,ATmega103,etc</span>
00059         outb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00060 <span class="preprocessor">    #endif</span>
00061 <span class="preprocessor"></span><span class="preprocessor">    #ifdef UCSRB</span>
00062 <span class="preprocessor"></span>        <span class="comment">// this line for the Mega163</span>
00063         outb(UCSRB, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00064 <span class="preprocessor">    #endif</span>
00065 <span class="preprocessor"></span><span class="preprocessor">    #ifdef UCSR0B</span>
00066 <span class="preprocessor"></span>        <span class="comment">// this line for the Mega161/128</span>
00067         outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00068         outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00069 <span class="preprocessor">    #endif</span>
00070 <span class="preprocessor"></span>
00071     <span class="comment">// set default baud rate</span>
00072     uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
00073     uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
00074     <span class="comment">// initialize states</span>
00075     uartReadyTx[0] = TRUE;
00076     uartReadyTx[1] = TRUE;
00077     uartBufferedTx[0] = FALSE;
00078     uartBufferedTx[1] = FALSE;
00079     <span class="comment">// clear overflow count</span>
00080     uartRxOverflow[0] = 0;
00081     uartRxOverflow[1] = 0;
00082     <span class="comment">// enable interrupts</span>
00083     sei();
00084 }
00085 
<a name="l00086"></a><a class="code" href="uart2_8c.html#a12">00086</a> <span class="keywordtype">void</span> <a class="code" href="uart_8c.html#a10">uartInitBuffers</a>(<span class="keywordtype">void</span>)
00087 {
00088 <span class="preprocessor">    #ifndef UART_BUFFERS_EXTERNAL_RAM</span>
00089 <span class="preprocessor"></span>        <span class="comment">// initialize the UART0 buffers</span>
00090         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartRxBuffer[0], uart0RxData, UART0_RX_BUFFER_SIZE);
00091         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartTxBuffer[0], uart0TxData, UART0_TX_BUFFER_SIZE);
00092         <span class="comment">// initialize the UART1 buffers</span>
00093         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartRxBuffer[1], uart1RxData, UART1_RX_BUFFER_SIZE);
00094         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartTxBuffer[1], uart1TxData, UART1_TX_BUFFER_SIZE);
00095 <span class="preprocessor">    #else</span>
00096 <span class="preprocessor"></span>        <span class="comment">// initialize the UART0 buffers</span>
00097         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
00098         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
00099         <span class="comment">// initialize the UART1 buffers</span>
00100         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
00101         <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
00102 <span class="preprocessor">    #endif</span>
00103 <span class="preprocessor"></span>}
00104 
00105 <span class="keywordtype">void</span> uartSetRxHandler(u08 nUart, <span class="keywordtype">void</span> (*rx_func)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00106 {
00107     <span class="comment">// make sure the uart number is within bounds</span>
00108     <span class="keywordflow">if</span>(nUart &lt; 2)
00109     {
00110         <span class="comment">// set the receive interrupt to run the supplied user function</span>
00111         UartRxFunc[nUart] = rx_func;
00112     }
00113 }
00114 
00115 <span class="keywordtype">void</span> uartSetBaudRate(u08 nUart, u32 baudrate)
00116 {
00117     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00118     u08 baudrateDiv;
00119     baudrateDiv = (u08)((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
00120     <span class="keywordflow">if</span>(nUart)
00121         outb(UBRR1L, baudrateDiv);
00122     <span class="keywordflow">else</span>
00123         outb(UBRR0L, baudrateDiv);
00124 }
00125 
00126 cBuffer* <a class="code" href="uart_8c.html#a13">uartGetRxBuffer</a>(u08 nUart)
00127 {
00128     <span class="comment">// return rx buffer pointer</span>
00129     <span class="keywordflow">return</span> &amp;uartRxBuffer[nUart];
00130 }
00131 
00132 cBuffer* <a class="code" href="uart_8c.html#a14">uartGetTxBuffer</a>(u08 nUart)
00133 {
00134     <span class="comment">// return tx buffer pointer</span>
00135     <span class="keywordflow">return</span> &amp;uartTxBuffer[nUart];
00136 }
00137 
00138 <span class="keywordtype">void</span> uartSendByte(u08 nUart, u08 txData)
00139 {
00140     <span class="comment">// wait for the transmitter to be ready</span>
00141     <span class="keywordflow">while</span>(!uartReadyTx[nUart]);
00142     <span class="comment">// send byte</span>
00143     <span class="keywordflow">if</span>(nUart)
00144         outb(UDR1, txData);
00145     <span class="keywordflow">else</span>
00146         outb(UDR0, txData);
00147     <span class="comment">// set ready state to FALSE</span>
00148     uartReadyTx[nUart] = FALSE;
00149 }
00150 
00151 <span class="keywordtype">void</span> uart0SendByte(u08 data)
00152 {
00153     <span class="comment">// send byte on UART0</span>
00154     uartSendByte(0, data);
00155 }
00156 
00157 <span class="keywordtype">void</span> uart1SendByte(u08 data)
00158 {
00159     <span class="comment">// send byte on UART1</span>
00160     uartSendByte(1, data);
00161 }
00162 
00163 u08 uartReceiveByte(u08 nUart, u08* rxData)
00164 {
00165     <span class="comment">// make sure we have a receive buffer</span>
00166     <span class="keywordflow">if</span>(uartRxBuffer[nUart].size)
00167     {
00168         <span class="comment">// make sure we have data</span>
00169         <span class="keywordflow">if</span>(uartRxBuffer[nUart].datalength)
00170         {
00171             <span class="comment">// get byte from beginning of buffer</span>
00172             *rxData = <a class="code" href="buffer_8c.html#a1">bufferGetFromFront</a>(&amp;uartRxBuffer[nUart]);
00173             <span class="keywordflow">return</span> TRUE;
00174         }
00175         <span class="keywordflow">else</span>
00176             <span class="keywordflow">return</span> FALSE;           <span class="comment">// no data</span>
00177     }
00178     <span class="keywordflow">else</span>
00179         <span class="keywordflow">return</span> FALSE;               <span class="comment">// no buffer</span>
00180 }
00181 
00182 <span class="keywordtype">void</span> <a class="code" href="uart_8c.html#a17">uartFlushReceiveBuffer</a>(u08 nUart)
00183 {
00184     <span class="comment">// flush all data from receive buffer</span>
00185     <a class="code" href="buffer_8c.html#a6">bufferFlush</a>(&amp;uartRxBuffer[nUart]);
00186 }
00187 
00188 u08 <a class="code" href="uart_8c.html#a18">uartReceiveBufferIsEmpty</a>(u08 nUart)
00189 {
00190     <span class="keywordflow">return</span> (uartRxBuffer[nUart].datalength == 0);
00191 }
00192 
<a name="l00193"></a><a class="code" href="uart2_8c.html#a23">00193</a> <span class="keywordtype">void</span> <a class="code" href="uart2_8c.html#a23">uartAddToTxBuffer</a>(u08 nUart, u08 data)
00194 {
00195     <span class="comment">// add data byte to the end of the tx buffer</span>
00196     <a class="code" href="buffer_8c.html#a4">bufferAddToEnd</a>(&amp;uartTxBuffer[nUart], data);
00197 }
00198 
00199 <span class="keywordtype">void</span> uart0AddToTxBuffer(u08 data)
00200 {
00201     <a class="code" href="uart2_8c.html#a23">uartAddToTxBuffer</a>(0,data);
00202 }
00203 
00204 <span class="keywordtype">void</span> uart1AddToTxBuffer(u08 data)
00205 {
00206     <a class="code" href="uart2_8c.html#a23">uartAddToTxBuffer</a>(1,data);
00207 }
00208 
00209 <span class="keywordtype">void</span> <a class="code" href="uart_8c.html#a20">uartSendTxBuffer</a>(u08 nUart)
00210 {
00211     <span class="comment">// turn on buffered transmit</span>
00212     uartBufferedTx[nUart] = TRUE;
00213     <span class="comment">// send the first byte to get things going by interrupts</span>
00214     uartSendByte(nUart, <a class="code" href="buffer_8c.html#a1">bufferGetFromFront</a>(&amp;uartTxBuffer[nUart]));
00215 }
00216 
00217 u08 uartSendBuffer(u08 nUart, <span class="keywordtype">char</span> *buffer, u16 nBytes)
00218 {
00219     <span class="keyword">register</span> u08 first;
00220     <span class="keyword">register</span> u16 i;
00221 
00222     <span class="comment">// check if there's space (and that we have any bytes to send at all)</span>
00223     <span class="keywordflow">if</span>((uartTxBuffer[nUart].datalength + nBytes &lt; uartTxBuffer[nUart].size) &amp;&amp; nBytes)
00224     {
00225         <span class="comment">// grab first character</span>
00226         first = *buffer++;
00227         <span class="comment">// copy user buffer to uart transmit buffer</span>
00228         <span class="keywordflow">for</span>(i = 0; i &lt; nBytes-1; i++)
00229         {
00230             <span class="comment">// put data bytes at end of buffer</span>
00231             <a class="code" href="buffer_8c.html#a4">bufferAddToEnd</a>(&amp;uartTxBuffer[nUart], *buffer++);
00232         }
00233 
00234         <span class="comment">// send the first byte to get things going by interrupts</span>
00235         uartBufferedTx[nUart] = TRUE;
00236         uartSendByte(nUart, first);
00237         <span class="comment">// return success</span>
00238         <span class="keywordflow">return</span> TRUE;
00239     }
00240     <span class="keywordflow">else</span>
00241     {
00242         <span class="comment">// return failure</span>
00243         <span class="keywordflow">return</span> FALSE;
00244     }
00245 }
00246 
00247 <span class="comment">// UART Transmit Complete Interrupt Function</span>
00248 <span class="keywordtype">void</span> uartTransmitService(u08 nUart)
00249 {
00250     <span class="comment">// check if buffered tx is enabled</span>
00251     <span class="keywordflow">if</span>(uartBufferedTx[nUart])
00252     {
00253         <span class="comment">// check if there's data left in the buffer</span>
00254         <span class="keywordflow">if</span>(uartTxBuffer[nUart].datalength)
00255         {
00256             <span class="comment">// send byte from top of buffer</span>
00257             <span class="keywordflow">if</span>(nUart)
00258                 outb(UDR1,  <a class="code" href="buffer_8c.html#a1">bufferGetFromFront</a>(&amp;uartTxBuffer[1]) );
00259             <span class="keywordflow">else</span>
00260                 outb(UDR0,  <a class="code" href="buffer_8c.html#a1">bufferGetFromFront</a>(&amp;uartTxBuffer[0]) );
00261         }
00262         <span class="keywordflow">else</span>
00263         {
00264             <span class="comment">// no data left</span>
00265             uartBufferedTx[nUart] = FALSE;
00266             <span class="comment">// return to ready state</span>
00267             uartReadyTx[nUart] = TRUE;
00268         }
00269     }
00270     <span class="keywordflow">else</span>
00271     {
00272         <span class="comment">// we're using single-byte tx mode</span>
00273         <span class="comment">// indicate transmit complete, back to ready</span>
00274         uartReadyTx[nUart] = TRUE;
00275     }
00276 }
00277 
00278 <span class="comment">// UART Receive Complete Interrupt Function</span>
00279 <span class="keywordtype">void</span> uartReceiveService(u08 nUart)
00280 {
00281     u08 c;
00282     <span class="comment">// get received char</span>
00283     <span class="keywordflow">if</span>(nUart)
00284         c = inb(UDR1);
00285     <span class="keywordflow">else</span>
00286         c = inb(UDR0);
00287 
00288     <span class="comment">// if there's a user function to handle this receive event</span>
00289     <span class="keywordflow">if</span>(UartRxFunc[nUart])
00290     {
00291         <span class="comment">// call it and pass the received data</span>
00292         UartRxFunc[nUart](c);
00293     }
00294     <span class="keywordflow">else</span>
00295     {
00296         <span class="comment">// otherwise do default processing</span>
00297         <span class="comment">// put received char in buffer</span>
00298         <span class="comment">// check if there's space</span>
00299         <span class="keywordflow">if</span>( !<a class="code" href="buffer_8c.html#a4">bufferAddToEnd</a>(&amp;uartRxBuffer[nUart], c) )
00300         {
00301             <span class="comment">// no space in buffer</span>
00302             <span class="comment">// count overflow</span>
00303             uartRxOverflow[nUart]++;
00304         }
00305     }
00306 }
00307 
00308 UART_INTERRUPT_HANDLER(SIG_UART0_TRANS)      
00309 {
00310     <span class="comment">// service UART0 transmit interrupt</span>
00311     uartTransmitService(0);
00312 }
00313 
00314 UART_INTERRUPT_HANDLER(SIG_UART1_TRANS)      
00315 {
00316     <span class="comment">// service UART1 transmit interrupt</span>
00317     uartTransmitService(1);
00318 }
00319 
00320 UART_INTERRUPT_HANDLER(SIG_UART0_RECV)      
00321 {
00322     <span class="comment">// service UART0 receive interrupt</span>
00323     uartReceiveService(0);
00324 }
00325 
00326 UART_INTERRUPT_HANDLER(SIG_UART1_RECV)      
00327 {
00328     <span class="comment">// service UART1 receive interrupt</span>
00329     uartReceiveService(1);
00330 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
