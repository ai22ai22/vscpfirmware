<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>fat.h Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>fat.h</h1><a href="fat_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file fat.h \brief FAT16/32 file system driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'fat.h'</span>
00005 <span class="comment">// Title        : FAT16/32 file system driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/07/2000</span>
00008 <span class="comment">// Revised      : 12/12/2000</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : ATmega103 (should work for Atmel AVR Series)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#ifndef FAT_H</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define FAT_H</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 
00027 
00028 <span class="comment">// Some useful cluster numbers</span>
00029 <span class="preprocessor">#define MSDOSFSROOT     0               // cluster 0 means the root dir</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_FREE      0               // cluster 0 also means a free cluster</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define MSDOSFSFREE     CLUST_FREE</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_FIRST     2               // first legal cluster number</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_RSRVD     0xfffffff6      // reserved cluster range</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_BAD       0xfffffff7      // a cluster with a defect</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_EOFS      0xfffffff8      // start of eof cluster range</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_EOFE      0xffffffff      // end of eof cluster range</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define FAT12_MASK      0x00000fff      // mask for 12 bit cluster numbers</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define FAT16_MASK      0x0000ffff      // mask for 16 bit cluster numbers</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define FAT32_MASK      0x0fffffff      // mask for FAT32 cluster numbers</span>
00041 <span class="preprocessor"></span>
00042 
00043 <span class="comment">// Partition Type used in the partition record</span>
00044 <span class="preprocessor">#define PART_TYPE_UNKNOWN       0x00</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT12         0x01</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_XENIX         0x02</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_DOSFAT16      0x04</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_EXTDOS        0x05</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT16         0x06</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_NTFS          0x07</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT32         0x0B</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT32LBA      0x0C</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT16LBA      0x0E</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_EXTDOSLBA     0x0F</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_ONTRACK       0x33</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_NOVELL        0x40</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_PCIX          0x4B</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_PHOENIXSAVE   0xA0</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_CPM           0xDB</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_DBFS          0xE0</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_BBT           0xFF</span>
00062 <span class="preprocessor"></span>
00063 <span class="keyword">struct </span>partrecord <span class="comment">// length 16 bytes</span>
00064 {           
00065     BYTE    prIsActive;                 <span class="comment">// 0x80 indicates active partition</span>
00066     BYTE    prStartHead;                <span class="comment">// starting head for partition</span>
00067     WORD    prStartCylSect;             <span class="comment">// starting cylinder and sector</span>
00068     BYTE    prPartType;                 <span class="comment">// partition type (see above)</span>
00069     BYTE    prEndHead;                  <span class="comment">// ending head for this partition</span>
00070     WORD    prEndCylSect;               <span class="comment">// ending cylinder and sector</span>
00071     DWORD   prStartLBA;                 <span class="comment">// first LBA sector for this partition</span>
00072     DWORD   prSize;                     <span class="comment">// size of this partition (bytes or sectors ?)</span>
00073 };
00074 
00075         
00076 <span class="keyword">struct </span>partsector
00077 {
00078     CHAR    psPartCode[512-64-2];       <span class="comment">// pad so struct is 512b</span>
00079     BYTE    psPart[64];                 <span class="comment">// four partition records (64 bytes)</span>
00080     BYTE    psBootSectSig0;             <span class="comment">// two signature bytes (2 bytes)</span>
00081     BYTE    psBootSectSig1;
00082 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00084 <span class="preprocessor"></span>};
00085 
00086 
00087 
00088 <span class="comment">// Format of a boot sector.  This is the first sector on a DOS floppy disk</span>
00089 <span class="comment">// or the first sector of a partition on a hard disk.  But, it is not the</span>
00090 <span class="comment">// first sector of a partitioned hard disk.</span>
00091 <span class="keyword">struct </span>bootsector33 {
00092     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00093     CHAR    bsOemName[8];               <span class="comment">// OEM name and version</span>
00094     CHAR    bsBPB[19];                  <span class="comment">// BIOS parameter block</span>
00095     CHAR    bsDriveNumber;              <span class="comment">// drive number (0x80)</span>
00096     CHAR    bsBootCode[479];            <span class="comment">// pad so struct is 512b</span>
00097     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55</span>
00098     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00099 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00101 <span class="preprocessor"></span>};
00102 
00103 <span class="keyword">struct </span>extboot {
00104     CHAR    exDriveNumber;              <span class="comment">// drive number (0x80)</span>
00105     CHAR    exReserved1;                <span class="comment">// reserved</span>
00106     CHAR    exBootSignature;            <span class="comment">// ext. boot signature (0x29)</span>
00107 <span class="preprocessor">#define EXBOOTSIG       0x29</span>
00108 <span class="preprocessor"></span>    CHAR    exVolumeID[4];              <span class="comment">// volume ID number</span>
00109     CHAR    exVolumeLabel[11];          <span class="comment">// volume label</span>
00110     CHAR    exFileSysType[8];           <span class="comment">// fs type (FAT12 or FAT16)</span>
00111 };
00112 
00113 <span class="keyword">struct </span>bootsector50 {
00114     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00115     CHAR    bsOemName[8];               <span class="comment">// OEM name and version</span>
00116     CHAR    bsBPB[25];                  <span class="comment">// BIOS parameter block</span>
00117     CHAR    bsExt[26];                  <span class="comment">// Bootsector Extension</span>
00118     CHAR    bsBootCode[448];            <span class="comment">// pad so structure is 512b</span>
00119     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55 </span>
00120     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00121 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00123 <span class="preprocessor"></span>};
00124 
00125 <span class="keyword">struct </span>bootsector710 {
00126     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00127     CHAR    bsOEMName[8];               <span class="comment">// OEM name and version</span>
00128     CHAR    bsBPB[53];                  <span class="comment">// BIOS parameter block</span>
00129     CHAR    bsExt[26];                  <span class="comment">// Bootsector Extension</span>
00130     CHAR    bsBootCode[418];            <span class="comment">// pad so structure is 512b</span>
00131     BYTE    bsBootSectSig2;             <span class="comment">// 2 &amp; 3 are only defined for FAT32?</span>
00132     BYTE    bsBootSectSig3;
00133     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55</span>
00134     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00135 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG2        0</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG3        0</span>
00139 <span class="preprocessor"></span>};
00140 
00141 
00142 <span class="comment">/***************************************************************/</span>
00143 <span class="comment">/***************************************************************/</span>
00144 
00145 <span class="comment">// BIOS Parameter Block (BPB) for DOS 3.3</span>
00146 <span class="keyword">struct </span>bpb33 {
00147         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00148         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00149         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00150         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00151         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00152         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00153         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00154         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00155         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00156         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00157         WORD    bpbHiddenSecs;  <span class="comment">// number of hidden sectors</span>
00158 };
00159 
00160 <span class="comment">// BPB for DOS 5.0</span>
00161 <span class="comment">// The difference is bpbHiddenSecs is a short for DOS 3.3,</span>
00162 <span class="comment">// and bpbHugeSectors is not present in the DOS 3.3 bpb.</span>
00163 <span class="keyword">struct </span>bpb50 {
00164         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00165         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00166         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00167         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00168         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00169         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00170         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00171         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00172         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00173         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00174         DWORD   bpbHiddenSecs;  <span class="comment">// # of hidden sectors</span>
00175 <span class="comment">// 3.3 compat ends here</span>
00176         DWORD   bpbHugeSectors; <span class="comment">// # of sectors if bpbSectors == 0</span>
00177 };
00178 
00179 <span class="comment">// BPB for DOS 7.10 (FAT32)</span>
00180 <span class="comment">// This one has a few extensions to bpb50.</span>
00181 <span class="keyword">struct </span>bpb710 {
00182         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00183         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00184         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00185         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00186         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00187         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00188         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00189         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00190         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00191         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00192         DWORD   bpbHiddenSecs;  <span class="comment">// # of hidden sectors</span>
00193 <span class="comment">// 3.3 compat ends here</span>
00194         DWORD   bpbHugeSectors; <span class="comment">// # of sectors if bpbSectors == 0</span>
00195 <span class="comment">// 5.0 compat ends here</span>
00196         DWORD     bpbBigFATsecs;<span class="comment">// like bpbFATsecs for FAT32</span>
00197         WORD      bpbExtFlags;  <span class="comment">// extended flags:</span>
00198 <span class="preprocessor">#define FATNUM    0xf           // mask for numbering active FAT</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define FATMIRROR 0x80          // FAT is mirrored (like it always was)</span>
00200 <span class="preprocessor"></span>        WORD      bpbFSVers;    <span class="comment">// filesystem version</span>
00201 <span class="preprocessor">#define FSVERS    0             // currently only 0 is understood</span>
00202 <span class="preprocessor"></span>        DWORD     bpbRootClust; <span class="comment">// start cluster for root directory</span>
00203         WORD      bpbFSInfo;    <span class="comment">// filesystem info structure sector</span>
00204         WORD      bpbBackup;    <span class="comment">// backup boot sector</span>
00205         <span class="comment">// There is a 12 byte filler here, but we ignore it</span>
00206 };
00207 
00208 
00209 
00210 
00211 <span class="comment">// ***************************************************************</span>
00212 <span class="comment">// * byte versions of the above structs                          *</span>
00213 <span class="comment">// ***************************************************************</span>
00214 
00215 
00216 <span class="comment">// BIOS Parameter Block (BPB) for DOS 3.3</span>
00217 <span class="keyword">struct </span>byte_bpb33 {
00218         CHAR bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00219         CHAR bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00220         CHAR bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00221         CHAR bpbFATs;               <span class="comment">// number of FATs</span>
00222         CHAR bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00223         CHAR bpbSectors[2];         <span class="comment">// total number of sectors</span>
00224         CHAR bpbMedia;              <span class="comment">// media descriptor</span>
00225         CHAR bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00226         CHAR bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00227         CHAR bpbHeads[2];           <span class="comment">// number of heads</span>
00228         CHAR bpbHiddenSecs[2];      <span class="comment">// number of hidden sectors</span>
00229 };
00230 
00231 <span class="comment">// BPB for DOS 5.0</span>
00232 <span class="comment">// The difference is bpbHiddenSecs is a short for DOS 3.3,</span>
00233 <span class="comment">// and bpbHugeSectors is not in the 3.3 bpb.</span>
00234 <span class="keyword">struct </span>byte_bpb50 {
00235         CHAR bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00236         CHAR bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00237         CHAR bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00238         CHAR bpbFATs;               <span class="comment">// number of FATs</span>
00239         CHAR bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00240         CHAR bpbSectors[2];         <span class="comment">// total number of sectors</span>
00241         CHAR bpbMedia;              <span class="comment">// media descriptor</span>
00242         CHAR bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00243         CHAR bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00244         CHAR bpbHeads[2];           <span class="comment">// number of heads</span>
00245         CHAR bpbHiddenSecs[4];      <span class="comment">// number of hidden sectors</span>
00246         CHAR bpbHugeSectors[4];     <span class="comment">// # of sectors if bpbSectors == 0</span>
00247 };
00248 
00249 <span class="comment">// BPB for DOS 7.10 (FAT32).</span>
00250 <span class="comment">// This one has a few extensions to bpb50.</span>
00251 <span class="keyword">struct </span>byte_bpb710 {
00252         BYTE bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00253         BYTE bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00254         BYTE bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00255         BYTE bpbFATs;               <span class="comment">// number of FATs</span>
00256         BYTE bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00257         BYTE bpbSectors[2];         <span class="comment">// total number of sectors</span>
00258         BYTE bpbMedia;              <span class="comment">// media descriptor</span>
00259         BYTE bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00260         BYTE bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00261         BYTE bpbHeads[2];           <span class="comment">// number of heads</span>
00262         BYTE bpbHiddenSecs[4];      <span class="comment">// # of hidden sectors</span>
00263         BYTE bpbHugeSectors[4];     <span class="comment">// # of sectors if bpbSectors == 0</span>
00264         BYTE bpbBigFATsecs[4];      <span class="comment">// like bpbFATsecs for FAT32</span>
00265         BYTE bpbExtFlags[2];        <span class="comment">// extended flags:</span>
00266         BYTE bpbFSVers[2];          <span class="comment">// filesystem version</span>
00267         BYTE bpbRootClust[4];       <span class="comment">// start cluster for root directory</span>
00268         BYTE bpbFSInfo[2];          <span class="comment">// filesystem info structure sector</span>
00269         BYTE bpbBackup[2];          <span class="comment">// backup boot sector</span>
00270         <span class="comment">// There is a 12 byte filler here, but we ignore it</span>
00271 };
00272 
00273 <span class="comment">// FAT32 FSInfo block.</span>
00274 <span class="keyword">struct </span>fsinfo {
00275         BYTE fsisig1[4];
00276         BYTE fsifill1[480];
00277         BYTE fsisig2[4];
00278         BYTE fsinfree[4];
00279         BYTE fsinxtfree[4];
00280         BYTE fsifill2[12];
00281         BYTE fsisig3[4];
00282         BYTE fsifill3[508];
00283         BYTE fsisig4[4];
00284 };
00285 
00286 
00287 <span class="comment">/***************************************************************/</span>
00288 <span class="comment">/***************************************************************/</span>
00289 
00290 
00291 <span class="comment">// Structure of a dos directory entry.</span>
00292 <span class="keyword">struct </span>direntry {
00293         BYTE        deName[8];      <span class="comment">// filename, blank filled</span>
00294 <span class="preprocessor">#define SLOT_EMPTY      0x00            // slot has never been used</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define SLOT_E5         0x05            // the real value is 0xe5</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define SLOT_DELETED    0xe5            // file in this slot deleted</span>
00297 <span class="preprocessor"></span>        BYTE        deExtension[3]; <span class="comment">// extension, blank filled</span>
00298         BYTE        deAttributes;   <span class="comment">// file attributes</span>
00299 <span class="preprocessor">#define ATTR_NORMAL     0x00            // normal file</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_READONLY   0x01            // file is readonly</span>
00301 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_HIDDEN     0x02            // file is hidden</span>
00302 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_SYSTEM     0x04            // file is a system file</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_VOLUME     0x08            // entry is a volume label</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_LONG_FILENAME  0x0f        // this is a long filename entry                </span>
00305 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_DIRECTORY  0x10            // entry is a directory name</span>
00306 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_ARCHIVE    0x20            // file is new or modified</span>
00307 <span class="preprocessor"></span>        BYTE        deLowerCase;    <span class="comment">// NT VFAT lower case flags</span>
00308 <span class="preprocessor">#define LCASE_BASE      0x08            // filename base in lower case</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define LCASE_EXT       0x10            // filename extension in lower case</span>
00310 <span class="preprocessor"></span>        BYTE        deCHundredth;   <span class="comment">// hundredth of seconds in CTime</span>
00311         BYTE        deCTime[2];     <span class="comment">// create time</span>
00312         BYTE        deCDate[2];     <span class="comment">// create date</span>
00313         BYTE        deADate[2];     <span class="comment">// access date</span>
00314         WORD        deHighClust;    <span class="comment">// high bytes of cluster number</span>
00315         BYTE        deMTime[2];     <span class="comment">// last update time</span>
00316         BYTE        deMDate[2];     <span class="comment">// last update date</span>
00317         WORD        deStartCluster; <span class="comment">// starting cluster of file</span>
00318         DWORD       deFileSize;     <span class="comment">// size of file in bytes</span>
00319 };
00320 
00321 <span class="comment">// number of directory entries in one sector</span>
00322 <span class="preprocessor">#define DIRENTRIES_PER_SECTOR   0x10</span>
00323 <span class="preprocessor"></span>
00324 <span class="comment">// Structure of a Win95 long name directory entry</span>
00325 <span class="keyword">struct </span>winentry {
00326         BYTE        weCnt;
00327 <span class="preprocessor">#define WIN_LAST        0x40</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define WIN_CNT         0x3f</span>
00329 <span class="preprocessor"></span>        BYTE        wePart1[10];
00330         BYTE        weAttributes;
00331 <span class="preprocessor">#define ATTR_WIN95      0x0f</span>
00332 <span class="preprocessor"></span>        BYTE        weReserved1;
00333         BYTE        weChksum;
00334         BYTE        wePart2[12];
00335         WORD        weReserved2;
00336         BYTE        wePart3[4];
00337 };
00338 
00339 <span class="preprocessor">#define WIN_CHARS   13      // Number of chars per winentry</span>
00340 <span class="preprocessor"></span>
00341 <span class="comment">// Maximum filename length in Win95</span>
00342 <span class="comment">// Note: Must be &lt; sizeof(dirent.d_name)</span>
00343 <span class="preprocessor">#define WIN_MAXLEN      255</span>
00344 <span class="preprocessor"></span>
00345 <span class="comment">// This is the format of the contents of the deTime field in the direntry</span>
00346 <span class="comment">// structure.</span>
00347 <span class="comment">// We don't use bitfields because we don't know how compilers for</span>
00348 <span class="comment">// arbitrary machines will lay them out.</span>
00349 <span class="preprocessor">#define DT_2SECONDS_MASK        0x1F    // seconds divided by 2</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define DT_2SECONDS_SHIFT       0</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define DT_MINUTES_MASK         0x7E0   // minutes</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define DT_MINUTES_SHIFT        5</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#define DT_HOURS_MASK           0xF800  // hours</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define DT_HOURS_SHIFT          11</span>
00355 <span class="preprocessor"></span>
00356 <span class="comment">// This is the format of the contents of the deDate field in the direntry</span>
00357 <span class="comment">// structure.</span>
00358 <span class="preprocessor">#define DD_DAY_MASK             0x1F    // day of month</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#define DD_DAY_SHIFT            0</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define DD_MONTH_MASK           0x1E0   // month</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define DD_MONTH_SHIFT          5</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#define DD_YEAR_MASK            0xFE00  // year - 1980</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define DD_YEAR_SHIFT           9</span>
00364 <span class="preprocessor"></span>
00365 <span class="comment">// Prototypes</span>
00366 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatInit( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> device);
00367 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fatClusterSize(<span class="keywordtype">void</span>);
00368 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetDirEntry(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> entry, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count);
00369 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetFilesize(<span class="keywordtype">void</span>);
00370 <span class="keywordtype">char</span>* fatGetFilename(<span class="keywordtype">void</span>);
00371 <span class="keywordtype">char</span>* fatGetDirname(<span class="keywordtype">void</span>);
00372 <span class="keywordtype">void</span> fatLoadCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer);
00373 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatNextCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster);
00374 
00375 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
