<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pulse.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>pulse.c</h1><a href="pulse_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file pulse.c \brief Pulse/frequency generation function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'pulse.c'</span>
00005 <span class="comment">// Title        : Pulse/frequency generation function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 2002-08-19</span>
00008 <span class="comment">// Revised      : 2003-05-29</span>
00009 <span class="comment">// Version      : 0.7</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00021 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00022 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="pulse_8h.html">pulse.h</a>"</span>
00028 
00029 <span class="comment">// Global variables</span>
00030 <span class="keyword">extern</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[];
00031 <span class="comment">// pulse generation registers</span>
00032 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  PulseT1AMode;
00033 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1ACount;
00034 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1APeriodTics;
00035 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  PulseT1BMode;
00036 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1BCount;
00037 <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> PulseT1BPeriodTics;
00038 
00039 <span class="comment">// pulse mode bit definitions</span>
00040 <span class="comment">// PULSE_MODE_COUNTED</span>
00041 <span class="comment">//      if true, the requested number of pulses are output, then output is turned off</span>
00042 <span class="comment">//      if false, pulses are output continuously</span>
00043 <span class="preprocessor">#define PULSE_MODE_COUNTED      0x01</span>
00044 <span class="preprocessor"></span>
00045 <span class="comment">// functions</span>
00046 
00047 <span class="keywordtype">void</span> pulseInit(<span class="keywordtype">void</span>)
00048 {
00049     <span class="comment">// initialize timer1 for pulse operation</span>
00050     pulseT1Init();
00051 }
00052 
00053 <span class="keywordtype">void</span> pulseT1Init(<span class="keywordtype">void</span>)
00054 {
00055     <span class="comment">// try to make sure that timer1 is in "normal" mode</span>
00056     <span class="comment">// most importantly, turn off PWM mode</span>
00057     <a class="code" href="timer_8c.html#a18">timer1PWMOff</a>();
00058 
00059     <span class="comment">// set some reasonable initial values</span>
00060     <span class="comment">// in case the user forgets to</span>
00061     PulseT1AMode = 0;
00062     PulseT1BMode = 0;
00063     PulseT1ACount = 0;
00064     PulseT1BCount = 0;
00065     PulseT1APeriodTics = 0x8000;
00066     PulseT1BPeriodTics = 0x8000;
00067 
00068     <span class="comment">// attach the pulse service routines to</span>
00069     <span class="comment">// the timer 1 output compare A and B interrupts</span>
00070     <a class="code" href="timer_8c.html#a12">timerAttach</a>(TIMER1OUTCOMPAREA_INT,pulseT1AService);
00071     <a class="code" href="timer_8c.html#a12">timerAttach</a>(TIMER1OUTCOMPAREB_INT,pulseT1BService);
00072 }
00073 
00074 <span class="keywordtype">void</span> pulseT1Off(<span class="keywordtype">void</span>)
00075 {
00076     <span class="comment">// turns pulse outputs off immediately</span>
00077     
00078     <span class="comment">// set pulse counters to zero (finished)</span>
00079     PulseT1ACount = 0;
00080     PulseT1BCount = 0;
00081     <span class="comment">// disconnect OutputCompare action from OC1A pin</span>
00082     cbi(TCCR1A,COM1A1);
00083     cbi(TCCR1A,COM1A0);
00084     <span class="comment">// disconnect OutputCompare action from OC1B pin</span>
00085     cbi(TCCR1A,COM1B1);
00086     cbi(TCCR1A,COM1B0);
00087     <span class="comment">// detach the pulse service routines</span>
00088     <a class="code" href="timer_8c.html#a13">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00089     <a class="code" href="timer_8c.html#a13">timerDetach</a>(TIMER1OUTCOMPAREB_INT);
00090 }
00091 
00092 <span class="keywordtype">void</span> pulseT1ASetFreq(u16 freqHz)
00093 {
00094     <span class="comment">// set the frequency of the pulse output</span>
00095     <span class="comment">// we need to find the requested period/2 (in timer tics)</span>
00096     <span class="comment">// from the frequency (in hertz)</span>
00097 
00098     <span class="comment">// get the current prescaler setting</span>
00099     u16 prescaleDiv = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+(inp(TCCR1B) &amp; TIMER_PRESCALE_MASK)));
00100     <span class="comment">// calculate how many tics in period/2</span>
00101     <span class="comment">// this is the (timer tic rate)/(2*requested freq)</span>
00102     PulseT1APeriodTics = ((u32)F_CPU/((u32)prescaleDiv*2*freqHz));
00103 }
00104 
00105 <span class="keywordtype">void</span> pulseT1BSetFreq(u16 freqHz)
00106 {
00107     <span class="comment">// set the frequency of the pulse output</span>
00108     <span class="comment">// we need to find the requested period/2 (in timer tics)</span>
00109     <span class="comment">// from the frequency (in hertz)</span>
00110 
00111     <span class="comment">// get the current prescaler setting</span>
00112     u16 prescaleDiv = 1&lt;&lt;(PRG_RDB(TimerPrescaleFactor+(inp(TCCR1B) &amp; TIMER_PRESCALE_MASK)));
00113     <span class="comment">// calculate how many tics in period/2</span>
00114     <span class="comment">// this is the (timer tic rate)/(2*requested freq)</span>
00115     PulseT1BPeriodTics = ((u32)F_CPU/((u32)prescaleDiv*2*freqHz));
00116 }
00117 
00118 <span class="keywordtype">void</span> pulseT1ARun(u16 nPulses)
00119 {
00120     <span class="comment">// set the number of pulses we want and the mode</span>
00121     <span class="keywordflow">if</span>(nPulses)
00122     {
00123         <span class="comment">// if the nPulses is non-zero, use "counted" mode</span>
00124         PulseT1AMode |= PULSE_MODE_COUNTED;
00125         PulseT1ACount = nPulses&lt;&lt;1;
00126     }
00127     <span class="keywordflow">else</span>
00128     {
00129         <span class="comment">// if nPulses is zero, run forever</span>
00130         PulseT1AMode &amp;= ~PULSE_MODE_COUNTED;
00131         PulseT1ACount = 1&lt;&lt;1;
00132     }
00133     <span class="comment">// set OutputCompare action to toggle OC1A pin</span>
00134     cbi(TCCR1A,COM1A1);
00135     sbi(TCCR1A,COM1A0);
00136 
00137     <span class="comment">// now the "enabling" stuff</span>
00138 
00139     <span class="comment">// set the output compare one pulse cycle ahead of current timer position </span>
00140     <span class="comment">// to make sure we don't have to wait until the timer overflows and comes</span>
00141     <span class="comment">// back to the current value</span>
00142     <span class="comment">// set future output compare time to TCNT1 + PulseT1APeriodTics</span>
00143     outw(OCR1A, inw(TCNT1) + PulseT1APeriodTics);
00144 
00145     <span class="comment">// enable OutputCompare interrupt</span>
00146     sbi(TIMSK, OCIE1A);
00147 }
00148 
00149 <span class="keywordtype">void</span> pulseT1BRun(u16 nPulses)
00150 {
00151     <span class="comment">// set the number of pulses we want and the mode</span>
00152     <span class="keywordflow">if</span>(nPulses)
00153     {
00154         <span class="comment">// if the nPulses is non-zero, use "counted" mode</span>
00155         PulseT1BMode |= PULSE_MODE_COUNTED;
00156         PulseT1BCount = nPulses&lt;&lt;1;
00157     }
00158     <span class="keywordflow">else</span>
00159     {
00160         <span class="comment">// if nPulses is zero, run forever</span>
00161         PulseT1BMode &amp;= ~PULSE_MODE_COUNTED;
00162         PulseT1BCount = 1&lt;&lt;1;
00163     }
00164     <span class="comment">// set OutputCompare action to toggle OC1B pin</span>
00165     <span class="comment">// (note: with all the A's and B's flying around, TCCR1A is not a bug)</span>
00166     cbi(TCCR1A,COM1B1);
00167     sbi(TCCR1A,COM1B0);
00168 
00169     <span class="comment">// now the "enabling" stuff</span>
00170 
00171     <span class="comment">// set the output compare one pulse cycle ahead of current timer position </span>
00172     <span class="comment">// to make sure we don't have to wait until the timer overflows and comes</span>
00173     <span class="comment">// back to the current value</span>
00174     <span class="comment">// set future output compare time to TCNT1 + PulseT1APeriodTics</span>
00175     outw(OCR1B, inw(TCNT1) + PulseT1BPeriodTics);
00176 
00177     <span class="comment">// enable OutputCompare interrupt</span>
00178     sbi(TIMSK, OCIE1B);
00179 }
00180 
00181 <span class="keywordtype">void</span> pulseT1AStop(<span class="keywordtype">void</span>)
00182 {
00183     <span class="comment">// stop output regardless of remaining pulses or mode</span>
00184     <span class="comment">// go to "counted" mode</span>
00185     PulseT1AMode |= PULSE_MODE_COUNTED;
00186     <span class="comment">// set pulses to zero</span>
00187     PulseT1ACount = 0;
00188 }
00189 
00190 <span class="keywordtype">void</span> pulseT1BStop(<span class="keywordtype">void</span>)
00191 {
00192     <span class="comment">// stop output regardless of remaining pulses or mode</span>
00193     <span class="comment">// go to "counted" mode</span>
00194     PulseT1BMode |= PULSE_MODE_COUNTED;
00195     <span class="comment">// set pulses to zero</span>
00196     PulseT1BCount = 0;
00197 }
00198 
00199 u16 pulseT1ARemaining(<span class="keywordtype">void</span>)
00200 {
00201     <span class="comment">// return the number of pulses remaining for channel A</span>
00202     <span class="comment">// add 1 to make sure we round up, &gt;&gt;1 equivalent to /2</span>
00203     <span class="keywordflow">return</span> (PulseT1ACount+1)&gt;&gt;1;
00204 }
00205 
00206 u16 pulseT1BRemaining(<span class="keywordtype">void</span>)
00207 {
00208     <span class="comment">// return the number of pulses remaining for channel A</span>
00209     <span class="comment">// add 1 to make sure we round up, &gt;&gt;1 equivalent to /2</span>
00210     <span class="keywordflow">return</span> (PulseT1BCount+1)&gt;&gt;1;
00211 }
00212 
00213 <span class="keywordtype">void</span> pulseT1AService(<span class="keywordtype">void</span>)
00214 {
00215     <span class="comment">// check if TimerPulseACount is non-zero</span>
00216     <span class="comment">//      (i.e. pulses are still requested)</span>
00217     <span class="keywordflow">if</span>(PulseT1ACount)
00218     {
00219         <span class="comment">//u16 OCValue;</span>
00220         <span class="comment">// read in current value of output compare register OCR1A</span>
00221         <span class="comment">//OCValue =  inp(OCR1AL);       // read low byte of OCR1A</span>
00222         <span class="comment">//OCValue += inp(OCR1AH)&lt;&lt;8;    // read high byte of OCR1A</span>
00223         <span class="comment">// increment OCR1A value by PulseT1APeriodTics</span>
00224         <span class="comment">//OCValue += PulseT1APeriodTics;</span>
00225         <span class="comment">// set future output compare time to this new value</span>
00226         <span class="comment">//outp((OCValue&gt;&gt;8),        OCR1AH);    // write high byte</span>
00227         <span class="comment">//outp((OCValue &amp; 0x00FF),OCR1AL);  // write low byte</span>
00228 
00229         <span class="comment">// the following line should be identical in operation</span>
00230         <span class="comment">// to the lines above, but for the moment, I'm not convinced</span>
00231         <span class="comment">// this method is bug-free.  At least it's simpler!</span>
00232         outw(OCR1A, inw(OCR1A) + PulseT1APeriodTics);
00233                 
00234         <span class="comment">// decrement the number of pulses executed</span>
00235         <span class="keywordflow">if</span>(PulseT1AMode &amp; PULSE_MODE_COUNTED)
00236             PulseT1ACount--;
00237     }
00238     <span class="keywordflow">else</span>
00239     {
00240         <span class="comment">// pulse count has reached zero</span>
00241         <span class="comment">// disable the output compare's action on OC1A pin</span>
00242         cbi(TCCR1A,COM1A1);
00243         cbi(TCCR1A,COM1A0);
00244         <span class="comment">// and disable the output compare's interrupt to stop pulsing</span>
00245         cbi(TIMSK, OCIE1A);
00246     }
00247 }
00248 
00249 <span class="keywordtype">void</span> pulseT1BService(<span class="keywordtype">void</span>)
00250 {
00251     <span class="comment">// check if TimerPulseACount is non-zero</span>
00252     <span class="comment">//      (i.e. pulses are still requested)</span>
00253     <span class="keywordflow">if</span>(PulseT1BCount)
00254     {
00255         <span class="comment">//u16 OCValue;</span>
00256         <span class="comment">// read in current value of output compare register OCR1B</span>
00257         <span class="comment">//OCValue =  inp(OCR1BL);       // read low byte of OCR1B</span>
00258         <span class="comment">//OCValue += inp(OCR1BH)&lt;&lt;8;    // read high byte of OCR1B</span>
00259         <span class="comment">// increment OCR1B value by PulseT1BPeriodTics</span>
00260         <span class="comment">//OCValue += PulseT1BPeriodTics; </span>
00261         <span class="comment">// set future output compare time to this new value</span>
00262         <span class="comment">//outp((OCValue&gt;&gt;8),        OCR1BH);    // write high byte</span>
00263         <span class="comment">//outp((OCValue &amp; 0x00FF),OCR1BL);  // write low byte</span>
00264 
00265         <span class="comment">// the following line should be identical in operation</span>
00266         <span class="comment">// to the lines above, but for the moment, I'm not convinced</span>
00267         <span class="comment">// this method is bug-free.  At least it's simpler!</span>
00268         outw(OCR1B, inw(OCR1B) + PulseT1BPeriodTics);
00269         
00270         <span class="comment">// decrement the number of pulses executed</span>
00271         <span class="keywordflow">if</span>(PulseT1BMode &amp; PULSE_MODE_COUNTED)
00272             PulseT1BCount--;
00273     }
00274     <span class="keywordflow">else</span>
00275     {
00276         <span class="comment">// pulse count has reached zero</span>
00277         <span class="comment">// disable the output compare's action on OC1B pin</span>
00278         cbi(TCCR1A,COM1B1);
00279         cbi(TCCR1A,COM1B0);
00280         <span class="comment">// and disable the output compare's interrupt to stop pulsing</span>
00281         cbi(TIMSK, OCIE1B);
00282     }
00283 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
