<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ata.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ata.c</h1><a href="ata_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file ata.c \brief IDE-ATA hard disk interface driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ata.c'</span>
00005 <span class="comment">// Title        : IDE-ATA interface driver for hard disks</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/22/2000</span>
00008 <span class="comment">// Revised      : 4/19/2003</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#ifndef WIN32</span>
00023 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00024 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00025 <span class="preprocessor">    #include &lt;avr/signal.h&gt;</span>
00026 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00027 <span class="comment">//  #include &lt;stdio.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="ata_8h.html">ata.h</a>"</span>
00034 
00035 <span class="comment">//#define DEBUG_ATA 1</span>
00036 
00037 <span class="comment">// global variables</span>
00038 
00039 <span class="comment">// drive information</span>
00040 typeDriveInfo ataDriveInfo;
00041 
00042 
00043 <span class="keywordtype">void</span> ataInit(<span class="keywordtype">void</span>)
00044 {
00045 
00046 }
00047 
00048 <span class="keywordtype">void</span> ataDriveInit(<span class="keywordtype">void</span>)
00049 {
00050     u08 i;
00051     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) SECTOR_BUFFER_ADDR;
00052 
00053     <span class="comment">// read drive identity</span>
00054     rprintfProgStrM(<span class="stringliteral">"\r\nScanning IDE interface...\r\n"</span>);
00055     <span class="comment">// Wait for drive to be ready</span>
00056     ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00057     <span class="comment">// issue identify command</span>
00058     ataWriteByte(ATA_REG_CMDSTATUS1, 0xEC);
00059     <span class="comment">// wait for drive to request data transfer</span>
00060     ataStatusWait(ATA_SR_DRQ, ATA_SR_DRQ);
00061     <a class="code" href="timer_8c.html#a14">timerPause</a>(200);
00062     <span class="comment">// read in the data</span>
00063     ataReadDataBuffer(buffer, 512);
00064 
00065     <span class="comment">// set local drive info parameters</span>
00066     ataDriveInfo.cylinders =        *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_CYLINDERS );
00067     ataDriveInfo.heads =            *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_HEADS );
00068     ataDriveInfo.sectors =          *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_SECTORS );
00069     ataDriveInfo.LBAsupport =       *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_FIELDVALID );
00070     ataDriveInfo.sizeinsectors =    *( (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) (buffer + ATA_IDENT_LBASECTORS*2) );
00071     <span class="comment">// copy model string</span>
00072     <span class="keywordflow">for</span>(i=0; i&lt;40; i+=2)
00073     {
00074         <span class="comment">// correct for byte order</span>
00075         ataDriveInfo.model[i  ] = buffer[(ATA_IDENT_MODEL*2) + i + 1];
00076         ataDriveInfo.model[i+1] = buffer[(ATA_IDENT_MODEL*2) + i    ];
00077     }
00078     <span class="comment">// terminate string</span>
00079     ataDriveInfo.model[40] = 0;
00080 
00081     <span class="comment">// process and print info</span>
00082     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00083     {
00084         <span class="comment">// LBA support</span>
00085         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, ataDriveInfo.sizeinsectors/(1000000/512) );
00086         rprintf(<span class="stringliteral">"LBA mode -- MODEL: "</span>);
00087     }
00088     <span class="keywordflow">else</span>
00089     {
00090         <span class="comment">// CHS, no LBA support</span>
00091         <span class="comment">// calculate drive size</span>
00092         ataDriveInfo.sizeinsectors = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) ataDriveInfo.cylinders*
00093                                                 ataDriveInfo.heads*ataDriveInfo.sectors;
00094         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, ataDriveInfo.sizeinsectors/(1000000/512) );
00095         rprintf(<span class="stringliteral">"CHS mode C=%d H=%d S=%d -- MODEL: "</span>, ataDriveInfo.cylinders, ataDriveInfo.heads, ataDriveInfo.sectors );
00096     }
00097     <span class="comment">// print model information  </span>
00098     <a class="code" href="rprintf_8c.html#a8">rprintfStr</a>(ataDriveInfo.model); <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00099 
00100     <span class="comment">// initialize local disk parameters</span>
00101     <span class="comment">//ataDriveInfo.cylinders = ATA_DISKPARM_CLYS;</span>
00102     <span class="comment">//ataDriveInfo.heads = ATA_DISKPARM_HEADS;</span>
00103     <span class="comment">//ataDriveInfo.sectors = ATA_DISKPARM_SECTORS;</span>
00104 
00105 }
00106 
00107 <span class="keywordtype">void</span> ataDiskErr(<span class="keywordtype">void</span>)
00108 {
00109     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b;
00110 
00111     b = ataReadByte(ATA_REG_ERROR); 
00112     rprintfProgStrM(<span class="stringliteral">"ATA Error: "</span>); 
00113     <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(b); 
00114     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00115 }
00116 
00117 <span class="keywordtype">void</span> ataSetDrivePowerMode(u08 DriveNo, u08 mode, u08 timeout)
00118 {
00119     <span class="comment">// select drive</span>
00120     ataDriveSelect(DriveNo);
00121     <span class="comment">// Wait for drive to be ready</span>
00122     ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00123 
00124     <span class="comment">// set mode</span>
00125     <span class="keywordflow">switch</span>(mode)
00126     {
00127     <span class="keywordflow">case</span> ATA_DISKMODE_SPINDOWN:     ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SPINDOWN); <span class="keywordflow">break</span>;
00128     <span class="keywordflow">case</span> ATA_DISKMODE_SPINUP:       ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SPINUP); <span class="keywordflow">break</span>;
00129     <span class="keywordflow">case</span> ATA_DISKMODE_SETTIMEOUT:
00130         ataWriteByte(ATA_REG_SECCOUNT, timeout);
00131         ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_IDLE_5SU);
00132         <span class="keywordflow">break</span>;
00133     <span class="keywordflow">case</span> ATA_DISKMODE_SLEEP:        ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SLEEP); <span class="keywordflow">break</span>;
00134     <span class="keywordflow">default</span>:
00135         <span class="keywordflow">break</span>;
00136     }
00137 }
00138 
00139 <span class="keywordtype">void</span> ataPrintSector( u08 *Buffer)
00140 {
00141     u08 i;
00142     u16 j;
00143     u08 *buf;
00144     u08 s;
00145 
00146     buf = Buffer;
00147     
00148     <span class="comment">// print the low order address indicies</span>
00149     rprintfProgStrM(<span class="stringliteral">"     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF\r\n"</span>);
00150     rprintfProgStrM(<span class="stringliteral">"     -----------------------------------------------  ---- ASCII -----\r\n"</span>);
00151     
00152     <span class="comment">// print the data</span>
00153     <span class="keywordflow">for</span>(j=0; j&lt;0x20; j++)
00154     {
00155         <span class="comment">// print the high order address index for this line</span>
00156         <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(j&lt;&lt;4);
00157         rprintfProgStrM(<span class="stringliteral">" "</span>);
00158 
00159         <span class="comment">// print the hex data</span>
00160         <span class="keywordflow">for</span>(i=0; i&lt;0x10; i++)
00161         {
00162             <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(buf[(j&lt;&lt;4)+i]);
00163             rprintfProgStrM(<span class="stringliteral">" "</span>);
00164         }
00165         
00166         <span class="comment">// leave some space</span>
00167         rprintfProgStrM(<span class="stringliteral">" "</span>);
00168 
00169         <span class="comment">// print the ascii data</span>
00170         <span class="keywordflow">for</span>(i=0; i&lt;0x10; i++)
00171         {
00172             s = buf[(j&lt;&lt;4)+i]; 
00173             <span class="comment">// make sure character is printable</span>
00174             <span class="keywordflow">if</span>(s &gt;= 0x20)
00175             {
00176                 <a class="code" href="rprintf_8c.html#a7">rprintfChar</a>(s);
00177             }
00178             <span class="keywordflow">else</span>
00179             {
00180                 <a class="code" href="rprintf_8c.html#a7">rprintfChar</a>(0x20);
00181             }
00182 
00183         }
00184         <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00185     }
00186 }
00187 
00188 <span class="keywordtype">void</span> ataReadDataBuffer(u08 *Buffer, u16 numBytes)
00189 {
00190     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00191 
00192     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00193 
00194     <span class="comment">// read data from drive</span>
00195     <span class="keywordflow">for</span> (i=0; i&lt;(numBytes/16); i++)
00196     {
00197         <span class="comment">// optimize by reading 16 bytes in-line before looping</span>
00198         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00199         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00200         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00201         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00202         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00203         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00204         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00205         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00206         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00207         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00208         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00209         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00210         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00211         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00212         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00213         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00214     }
00215     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00216     
00217 }
00218 
00219 <span class="keywordtype">void</span> ataWriteDataBuffer(u08 *Buffer, u16 numBytes)
00220 {
00221     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00222     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00223 
00224     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00225 
00226     <span class="comment">// write data to drive</span>
00227     <span class="keywordflow">for</span> (i=0; i&lt;(numBytes/16); i++)     
00228     {
00229         <span class="comment">// optimize by writing 16 bytes in-line before looping</span>
00230         <span class="comment">// keep byte order correct by using temp register</span>
00231         temp = *Buffer++;
00232         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00233         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00234         temp = *Buffer++;
00235         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00236         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00237         temp = *Buffer++;
00238         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00239         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00240         temp = *Buffer++;
00241         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00242         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00243         temp = *Buffer++;
00244         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00245         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00246         temp = *Buffer++;
00247         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00248         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00249         temp = *Buffer++;
00250         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00251         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00252         temp = *Buffer++;
00253         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00254         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00255     }
00256     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00257 
00258 }
00259 
00260 u08 ataStatusWait(u08 mask, u08 waitStatus)
00261 {
00262     <span class="keyword">register</span> u08 status;
00263 
00264     delay(100);
00265 
00266     <span class="comment">// wait for desired status</span>
00267     <span class="keywordflow">while</span>( ((status = ataReadByte(ATA_REG_CMDSTATUS1)) &amp; mask) == waitStatus );
00268 
00269     <span class="keywordflow">return</span> status;
00270 }
00271 
00272 
00273 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsCHS(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00274                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00275                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00276                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00277                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00278                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00279 {
00280     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00281 
00282     <span class="comment">// Wait for drive to be ready</span>
00283     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00284 
00285     <span class="comment">// Prepare parameters...</span>
00286     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(Drive ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00287     ataWriteByte(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00288     ataWriteByte(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00289     ataWriteByte(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00290     ataWriteByte(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00291 
00292     <span class="comment">// Issue read sector command...</span>
00293     ataWriteByte(ATA_REG_CMDSTATUS1, 0x21);
00294 
00295     <span class="comment">// Wait for drive to be ready</span>
00296     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00297 
00298     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00299     {
00300         rprintfProgStrM(<span class="stringliteral">"RD ERR\r\n"</span>);
00301         <span class="keywordflow">return</span> 1;
00302     }
00303 
00304     <span class="comment">// Wait for drive to request data transfer</span>
00305     ataStatusWait(ATA_SR_DRQ, 0);
00306 
00307     <span class="comment">// read data from drive</span>
00308     ataReadDataBuffer(Buffer, 512*numsectors);
00309 
00310     <span class="comment">// Return the error bit from the status register...</span>
00311     temp = ataReadByte(ATA_REG_CMDSTATUS1); <span class="comment">// read status register</span>
00312 
00313     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00314 }
00315 
00316 
00317 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsCHS(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00318                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00319                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00320                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00321                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00322                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00323 {
00324     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00325 
00326     <span class="comment">// Wait for drive to be ready</span>
00327     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00328 
00329     <span class="comment">// Prepare parameters...</span>
00330     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(Drive ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00331     ataWriteByte(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00332     ataWriteByte(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00333     ataWriteByte(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00334     ataWriteByte(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00335 
00336     <span class="comment">// Issue write sector command</span>
00337     ataWriteByte(ATA_REG_CMDSTATUS1, 0x31);
00338 
00339     <span class="comment">//delay(100);</span>
00340 
00341     <span class="comment">// Wait for drive to request data transfer</span>
00342     ataStatusWait(ATA_SR_DRQ, 0);
00343 
00344     <span class="comment">// write data to drive</span>
00345     ataWriteDataBuffer(Buffer, 512*numsectors);
00346     
00347     <span class="comment">// Wait for drive to finish write</span>
00348     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00349 
00350     <span class="comment">// check for errors</span>
00351     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00352     {
00353         rprintfProgStrM(<span class="stringliteral">"WR ERR\r\n"</span>);
00354         <span class="keywordflow">return</span> 1;
00355     }
00356 
00357     <span class="comment">// Return the error bit from the status register...</span>
00358     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00359 }
00360 
00361 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsLBA(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00362                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00363                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00364                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00365 {
00366     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00367     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00368 
00369 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00370 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"ATA LBA read "</span>);
00371     <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(lba); rprintfProgStrM(<span class="stringliteral">" "</span>);
00372     <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(numsectors); rprintfProgStrM(<span class="stringliteral">" "</span>);
00373     <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00374     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00375 <span class="preprocessor">#endif</span>
00376 <span class="preprocessor"></span>
00377     sect = (int) ( lba &amp; 0x000000ffL );
00378     lba = lba &gt;&gt; 8;
00379     cyl = (int) ( lba &amp; 0x0000ffff );
00380     lba = lba &gt;&gt; 16;
00381     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00382 
00383     temp = ataReadSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00384 
00385     <span class="keywordflow">if</span>(temp)
00386         ataDiskErr();
00387     <span class="keywordflow">return</span> temp;
00388 }
00389 
00390 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsLBA(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00391                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00392                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00393                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00394 {
00395     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00396     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00397 
00398 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00399 <span class="preprocessor"></span>    rprintfProgStrM(<span class="stringliteral">"ATA LBA write "</span>);
00400     <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(lba); rprintfProgStrM(<span class="stringliteral">" "</span>);
00401     <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(numsectors); rprintfProgStrM(<span class="stringliteral">" "</span>);
00402     <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00403     <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00404 <span class="preprocessor">#endif</span>
00405 <span class="preprocessor"></span>
00406     sect = (int) ( lba &amp; 0x000000ffL );
00407     lba = lba &gt;&gt; 8;
00408     cyl = (int) ( lba &amp; 0x0000ffff );
00409     lba = lba &gt;&gt; 16;
00410     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00411 
00412     temp = ataWriteSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00413 
00414     <span class="keywordflow">if</span>(temp)
00415         ataDiskErr();
00416     <span class="keywordflow">return</span> temp;
00417 }                                   
00418 
00419 
00420 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectors(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00421                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00422                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00423                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00424 {
00425     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00426     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00427 
00428     <span class="comment">// check if drive supports native LBA mode</span>
00429     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00430     {
00431         <span class="comment">// drive supports using native LBA</span>
00432         temp = ataReadSectorsLBA(Drive, lba, numsectors, Buffer);
00433     }
00434     <span class="keywordflow">else</span>
00435     {
00436         <span class="comment">// drive required CHS access</span>
00437 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00438 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00439             rprintfProgStrM(<span class="stringliteral">"ATA LBA for CHS read: "</span>);
00440             rprintfProgStrM(<span class="stringliteral">"LBA="</span>); <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(lba); rprintfProgStrM(<span class="stringliteral">" "</span>);
00441 <span class="preprocessor">        #endif</span>
00442 <span class="preprocessor"></span>
00443         <span class="comment">// convert LBA to pseudo CHS</span>
00444         <span class="comment">// remember to offset the sector count by one</span>
00445         sect = (u08) (lba % ataDriveInfo.sectors)+1;
00446         lba = lba / ataDriveInfo.sectors;
00447         head = (u08) (lba % ataDriveInfo.heads);
00448         lba = lba / ataDriveInfo.heads;
00449         cyl = (u16) lba;
00450 
00451 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00452 <span class="preprocessor"></span>            rprintfProgStrM(<span class="stringliteral">"C:H:S="</span>);
00453             <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(cyl); rprintfProgStrM(<span class="stringliteral">":"</span>);
00454             <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(head); rprintfProgStrM(<span class="stringliteral">":"</span>);
00455             <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(sect); <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00456 <span class="preprocessor">        #endif</span>
00457 <span class="preprocessor"></span>
00458         temp = ataReadSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00459     }
00460 
00461     <span class="keywordflow">if</span>(temp)
00462         ataDiskErr();
00463     <span class="keywordflow">return</span> temp;
00464 }
00465 
00466 
00467 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectors(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00468                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00469                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00470                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00471 {
00472     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00473     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00474 
00475     <span class="comment">// check if drive supports native LBA mode</span>
00476     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00477     {
00478         <span class="comment">// drive supports using native LBA</span>
00479         temp = ataWriteSectorsLBA(Drive, lba, numsectors, Buffer);
00480     }
00481     <span class="keywordflow">else</span>
00482     {
00483         <span class="comment">// drive required CHS access</span>
00484 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00485 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00486             rprintfProgStrM(<span class="stringliteral">"ATA LBA for CHS write: "</span>);
00487             rprintfProgStrM(<span class="stringliteral">"LBA="</span>); <a class="code" href="rprintf_8c.html#a15">rprintfu32</a>(lba); rprintfProgStrM(<span class="stringliteral">" "</span>);
00488 <span class="preprocessor">        #endif</span>
00489 <span class="preprocessor"></span>
00490         <span class="comment">// convert LBA to pseudo CHS</span>
00491         <span class="comment">// remember to offset the sector count by one</span>
00492         sect = (u08) (lba % ataDriveInfo.sectors)+1;
00493         lba = lba / ataDriveInfo.sectors;
00494         head = (u08) (lba % ataDriveInfo.heads);
00495         lba = lba / ataDriveInfo.heads;
00496         cyl = (u16) lba;
00497 
00498 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00499 <span class="preprocessor"></span>            rprintfProgStrM(<span class="stringliteral">"C:H:S="</span>);
00500             <a class="code" href="rprintf_8c.html#a14">rprintfu16</a>(cyl); rprintfProgStrM(<span class="stringliteral">":"</span>);
00501             <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(head); rprintfProgStrM(<span class="stringliteral">":"</span>);
00502             <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(sect); <a class="code" href="rprintf_8c.html#a11">rprintfCRLF</a>();
00503 <span class="preprocessor">        #endif</span>
00504 <span class="preprocessor"></span>
00505         temp = ataWriteSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00506     }
00507 
00508     <span class="keywordflow">if</span>(temp)
00509         ataDiskErr();
00510     <span class="keywordflow">return</span> temp;
00511 }                                   
00512 
00513 <span class="keywordtype">void</span> ataDriveSelect(u08 DriveNo)
00514 {
00515     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(DriveNo ? 0x10:00)); <span class="comment">// Drive selection</span>
00516 }
00517  
00518 <span class="comment">//----------------------------------------------------------------------------</span>
00519 <span class="comment">// Set drive mode (STANDBY, IDLE)</span>
00520 <span class="comment">//----------------------------------------------------------------------------</span>
00521 <span class="comment">/*#define STANDBY 0</span>
00522 <span class="comment">#define IDLE    1</span>
00523 <span class="comment">#define SLEEP   2 </span>
00524 <span class="comment">*/</span> 
00525 
00526 <span class="comment">/*</span>
00527 <span class="comment">unsigned char SetMode(unsigned char DriveNo, unsigned char Mode, unsigned char PwrDown) </span>
00528 <span class="comment">{</span>
00529 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (DriveNo ? 0x10:0x00)); // Select drive</span>
00530 <span class="comment">  WriteBYTE(CMD, 2, (PwrDown ? 0x01:0x00)); // Enable automatic power down</span>
00531 <span class="comment">  switch (Mode) </span>
00532 <span class="comment">  {</span>
00533 <span class="comment">    case STANDBY: WriteBYTE(CMD,7, 0xE2); break;</span>
00534 <span class="comment">    case IDLE:    WriteBYTE(CMD,7, 0xE3); break;</span>
00535 <span class="comment">    // NOTE: To recover from sleep, either issue a soft or hardware reset !</span>
00536 <span class="comment">    // (But not on all drives, f.ex seagate ST3655A it's not nessecary to reset</span>
00537 <span class="comment">    // but only to go in Idle mode, But on a Conner CFA170A it's nessecary with</span>
00538 <span class="comment">    // a reset)</span>
00539 <span class="comment">    case SLEEP:   WriteBYTE(CMD,7, 0xE6); break;</span>
00540 <span class="comment">  }</span>
00541 <span class="comment">  Timer10mSec=10000;</span>
00542 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40 &amp;&amp; Timer10mSec); // Wait for DRDY &amp; NOT BUSY </span>
00543 <span class="comment">  if (Timer10mSec==0) return 0xFF;                       //   or timeout</span>
00544 <span class="comment"> </span>
00545 <span class="comment">  // Return the error register...</span>
00546 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00547 <span class="comment">}</span>
00548 <span class="comment"></span>
00549 <span class="comment">*/</span>
00550 
00551 u08 ataReadByte(u08 reg)
00552 {
00553     <span class="keyword">register</span> u08 ret;
00554     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00555     ret = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + reg);
00556     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00557     <span class="keywordflow">return</span> ret;
00558 }
00559 
00560 <span class="keywordtype">void</span> ataWriteByte(u08 reg, u08 data)
00561 {
00562     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00563     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + reg) = data;
00564     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00565 }
00566 
00567  
00568 <span class="keywordtype">void</span> ataShowRegisters(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> DriveNo) 
00569 { 
00570     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0 + (DriveNo ? 0x10:0x00)); <span class="comment">// Select drive</span>
00571     
00572     rprintfProgStrM(<span class="stringliteral">"R0: DATALOW  = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_DATAL    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00573     rprintfProgStrM(<span class="stringliteral">"R1: ERROR    = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_ERROR    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00574     rprintfProgStrM(<span class="stringliteral">"R2: SECT CNT = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_SECCOUNT));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00575     rprintfProgStrM(<span class="stringliteral">"R3: SECT NUM = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_STARTSEC));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00576     rprintfProgStrM(<span class="stringliteral">"R4: CYL LOW  = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_CYLLO    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00577     rprintfProgStrM(<span class="stringliteral">"R5: CYL HIGH = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_CYLHI    ));     rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00578     rprintfProgStrM(<span class="stringliteral">"R6: HEAD/DEV = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_HDDEVSEL));      rprintfProgStrM(<span class="stringliteral">" \r\n"</span>);
00579     rprintfProgStrM(<span class="stringliteral">"R7: CMD/STA  = 0x"</span>);   <a class="code" href="rprintf_8c.html#a13">rprintfu08</a>(ataReadByte(ATA_REG_CMDSTATUS1));    rprintfProgStrM(<span class="stringliteral">"\r\n"</span>);
00580 } 
00581 
00582 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataSWReset(<span class="keywordtype">void</span>)
00583 {
00584     ataWriteByte(ATA_REG_HDDEVSEL, 0x06);   <span class="comment">// SRST and nIEN bits</span>
00585     delay(10);  <span class="comment">// 10uS delay</span>
00586     ataWriteByte(ATA_REG_HDDEVSEL, 0x02);   <span class="comment">// nIEN bits</span>
00587     delay(10);  <span class="comment">// 10 uS delay</span>
00588    
00589    <span class="keywordflow">while</span>( (ataReadByte(ATA_REG_CMDSTATUS1) &amp; 0xC0) != 0x40 ); <span class="comment">// Wait for DRDY and not BSY</span>
00590     
00591     <span class="keywordflow">return</span> ataReadByte(ATA_REG_CMDSTATUS1) + ataReadByte(ATA_REG_ERROR);
00592 }
00593 
00594 <span class="comment">/*</span>
00595 <span class="comment">unsigned char ATA_Idle(unsigned char Drive)</span>
00596 <span class="comment">{</span>
00597 <span class="comment"></span>
00598 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (Drive ? 0x10:0x00)); // Select drive</span>
00599 <span class="comment">  WriteBYTE(CMD,7, 0xE1);</span>
00600 <span class="comment"></span>
00601 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40); // Wait for DRDY &amp; NOT BUSY </span>
00602 <span class="comment"></span>
00603 <span class="comment">  // Return the error register...</span>
00604 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00605 <span class="comment">}</span>
00606 <span class="comment">*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:30 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
