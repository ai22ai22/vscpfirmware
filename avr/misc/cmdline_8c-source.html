<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cmdline.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>cmdline.c</h1><a href="cmdline_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file cmdline.c \brief Command-Line Interface Library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'cmdline.c'</span>
00005 <span class="comment">// Title        : Command-Line Interface Library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2003</span>
00007 <span class="comment">// Created      : 2003.07.16</span>
00008 <span class="comment">// Revised      : 2003.07.23</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="comment">//----- Include Files ---------------------------------------------------------</span>
00023 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>         <span class="comment">// include I/O definitions (port names, pin names, etc)</span>
00024 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>     <span class="comment">// include "signal" names (interrupt names)</span>
00025 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>  <span class="comment">// include interrupt support</span>
00026 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>   <span class="comment">// include AVR program memory support</span>
00027 <span class="preprocessor">#include &lt;string.h&gt;</span>         <span class="comment">// include standard C string functions</span>
00028 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>         <span class="comment">// include stdlib for string conversion functions</span>
00029 
00030 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>     <span class="comment">// include our global settings</span>
00031 <span class="preprocessor">#include "<a class="code" href="cmdline_8h.html">cmdline.h</a>"</span>
00032 
00033 <span class="comment">// include project-specific configuration</span>
00034 <span class="preprocessor">#include "<a class="code" href="cmdlineconf_8h.html">cmdlineconf.h</a>"</span>
00035 
00036 <span class="comment">// defines</span>
00037 <span class="preprocessor">#define ASCII_BEL               0x07</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_BS                0x08</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_CR                0x0D</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_LF                0x0A</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_ESC               0x1B</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_DEL               0x7F</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#define VT100_ARROWUP           'A'</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWDOWN         'B'</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWRIGHT        'C'</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWLEFT         'D'</span>
00048 <span class="preprocessor"></span>
00049 <span class="preprocessor">#define CMDLINE_HISTORY_SAVE    0</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define CMDLINE_HISTORY_PREV    1</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define CMDLINE_HISTORY_NEXT    2</span>
00052 <span class="preprocessor"></span>
00053 
00054 <span class="comment">// Global variables</span>
00055 
00056 <span class="comment">// strings</span>
00057 u08 PROGMEM CmdlinePrompt[] = <span class="stringliteral">"cmd&gt;"</span>;
00058 u08 PROGMEM CmdlineNotice[] = <span class="stringliteral">"cmdline: "</span>;
00059 u08 PROGMEM CmdlineCmdNotFound[] = <span class="stringliteral">"command not found"</span>;
00060 
00061 <span class="comment">// command list</span>
00062 <span class="comment">// -commands are null-terminated strings</span>
00063 <span class="keyword">static</span> <span class="keywordtype">char</span> CmdlineCommandList[CMDLINE_MAX_COMMANDS][CMDLINE_MAX_CMD_LENGTH];
00064 <span class="comment">// command function pointer list</span>
00065 <span class="keyword">static</span> CmdlineFuncPtrType CmdlineFunctionList[CMDLINE_MAX_COMMANDS];
00066 <span class="comment">// number of commands currently registered</span>
00067 u08 CmdlineNumCommands;
00068 
00069 u08 CmdlineBuffer[CMDLINE_BUFFERSIZE];
00070 u08 CmdlineBufferLength;
00071 u08 CmdlineBufferEditPos;
00072 u08 CmdlineInputVT100State;
00073 u08 CmdlineHistory[CMDLINE_HISTORYSIZE][CMDLINE_BUFFERSIZE];
00074 CmdlineFuncPtrType CmdlineExecFunction;
00075 
00076 <span class="comment">// Functions</span>
00077 
00078 <span class="comment">// function pointer to single character output routine</span>
00079 <span class="keyword">static</span> void (*cmdlineOutputFunc)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c);
00080 
<a name="l00081"></a><a class="code" href="cmdline_8c.html#a26">00081</a> <span class="keywordtype">void</span> <a class="code" href="cmdline_8c.html#a26">cmdlineInit</a>(<span class="keywordtype">void</span>)
00082 {
00083     <span class="comment">// reset vt100 processing state</span>
00084     CmdlineInputVT100State = 0;
00085     <span class="comment">// initialize input buffer</span>
00086     CmdlineBufferLength = 0;
00087     CmdlineBufferEditPos = 0;
00088     <span class="comment">// initialize executing function</span>
00089     CmdlineExecFunction = 0;
00090     <span class="comment">// initialize command list</span>
00091     CmdlineNumCommands = 0;
00092 }
00093 
<a name="l00094"></a><a class="code" href="cmdline_8c.html#a27">00094</a> <span class="keywordtype">void</span> <a class="code" href="cmdline_8c.html#a27">cmdlineAddCommand</a>(u08* newCmdString, CmdlineFuncPtrType newCmdFuncPtr)
00095 {
00096     <span class="comment">// add command string to end of command list</span>
00097     strcpy(CmdlineCommandList[CmdlineNumCommands], newCmdString);
00098     <span class="comment">// add command function ptr to end of function list</span>
00099     CmdlineFunctionList[CmdlineNumCommands] = newCmdFuncPtr;
00100     <span class="comment">// increment number of registered commands</span>
00101     CmdlineNumCommands++;
00102 }
00103 
<a name="l00104"></a><a class="code" href="cmdline_8c.html#a28">00104</a> <span class="keywordtype">void</span> <a class="code" href="cmdline_8c.html#a28">cmdlineSetOutputFunc</a>(<span class="keywordtype">void</span> (*output_func)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00105 {
00106     <span class="comment">// set new output function</span>
00107     cmdlineOutputFunc = output_func;
00108     
00109     <span class="comment">// should we really do this?</span>
00110     <span class="comment">// print a prompt </span>
00111     <span class="comment">//cmdlinePrintPrompt();</span>
00112 }
00113 
<a name="l00114"></a><a class="code" href="cmdline_8c.html#a29">00114</a> <span class="keywordtype">void</span> <a class="code" href="cmdline_8c.html#a29">cmdlineInputFunc</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
00115 {
00116     u08 i;
00117     <span class="comment">// process the received character</span>
00118 
00119     <span class="comment">// VT100 handling</span>
00120     <span class="comment">// are we processing a VT100 command?</span>
00121     <span class="keywordflow">if</span>(CmdlineInputVT100State == 2)
00122     {
00123         <span class="comment">// we have already received ESC and [</span>
00124         <span class="comment">// now process the vt100 code</span>
00125         <span class="keywordflow">switch</span>(c)
00126         {
00127         <span class="keywordflow">case</span> VT100_ARROWUP:
00128             cmdlineDoHistory(CMDLINE_HISTORY_PREV);
00129             <span class="keywordflow">break</span>;
00130         <span class="keywordflow">case</span> VT100_ARROWDOWN:
00131             cmdlineDoHistory(CMDLINE_HISTORY_NEXT);
00132             <span class="keywordflow">break</span>;
00133         <span class="keywordflow">case</span> VT100_ARROWRIGHT:
00134             <span class="comment">// if the edit position less than current string length</span>
00135             <span class="keywordflow">if</span>(CmdlineBufferEditPos &lt; CmdlineBufferLength)
00136             {
00137                 <span class="comment">// increment the edit position</span>
00138                 CmdlineBufferEditPos++;
00139                 <span class="comment">// move cursor forward one space (no erase)</span>
00140                 cmdlineOutputFunc(ASCII_ESC);
00141                 cmdlineOutputFunc(<span class="charliteral">'['</span>);
00142                 cmdlineOutputFunc(VT100_ARROWRIGHT);
00143             }
00144             <span class="keywordflow">else</span>
00145             {
00146                 <span class="comment">// else, ring the bell</span>
00147                 cmdlineOutputFunc(ASCII_BEL);
00148             }
00149             <span class="keywordflow">break</span>;
00150         <span class="keywordflow">case</span> VT100_ARROWLEFT:
00151             <span class="comment">// if the edit position is non-zero</span>
00152             <span class="keywordflow">if</span>(CmdlineBufferEditPos)
00153             {
00154                 <span class="comment">// decrement the edit position</span>
00155                 CmdlineBufferEditPos--;
00156                 <span class="comment">// move cursor back one space (no erase)</span>
00157                 cmdlineOutputFunc(ASCII_BS);
00158             }
00159             <span class="keywordflow">else</span>
00160             {
00161                 <span class="comment">// else, ring the bell</span>
00162                 cmdlineOutputFunc(ASCII_BEL);
00163             }
00164             <span class="keywordflow">break</span>;
00165         <span class="keywordflow">default</span>:
00166             <span class="keywordflow">break</span>;
00167         }
00168         <span class="comment">// done, reset state</span>
00169         CmdlineInputVT100State = 0;
00170         <span class="keywordflow">return</span>;
00171     }
00172     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(CmdlineInputVT100State == 1)
00173     {
00174         <span class="comment">// we last received [ESC]</span>
00175         <span class="keywordflow">if</span>(c == <span class="charliteral">'['</span>)
00176         {
00177             CmdlineInputVT100State = 2;
00178             <span class="keywordflow">return</span>;
00179         }
00180         <span class="keywordflow">else</span>
00181             CmdlineInputVT100State = 0;
00182     }
00183     <span class="keywordflow">else</span>
00184     {
00185         <span class="comment">// anything else, reset state</span>
00186         CmdlineInputVT100State = 0;
00187     }
00188 
00189     <span class="comment">// Regular handling</span>
00190     <span class="keywordflow">if</span>( (c &gt;= 0x20) &amp;&amp; (c &lt; 0x7F) )
00191     {
00192         <span class="comment">// character is printable</span>
00193         <span class="comment">// is this a simple append</span>
00194         <span class="keywordflow">if</span>(CmdlineBufferEditPos == CmdlineBufferLength)
00195         {
00196             <span class="comment">// echo character to the output</span>
00197             cmdlineOutputFunc(c);
00198             <span class="comment">// add it to the command line buffer</span>
00199             CmdlineBuffer[CmdlineBufferEditPos++] = c;
00200             <span class="comment">// update buffer length</span>
00201             CmdlineBufferLength++;
00202         }
00203         <span class="keywordflow">else</span>
00204         {
00205             <span class="comment">// edit/cursor position != end of buffer</span>
00206             <span class="comment">// we're inserting characters at a mid-line edit position</span>
00207             <span class="comment">// make room at the insert point</span>
00208             CmdlineBufferLength++;
00209             <span class="keywordflow">for</span>(i=CmdlineBufferLength; i&gt;CmdlineBufferEditPos; i--)
00210                 CmdlineBuffer[i] = CmdlineBuffer[i-1];
00211             <span class="comment">// insert character</span>
00212             CmdlineBuffer[CmdlineBufferEditPos++] = c;
00213             <span class="comment">// repaint</span>
00214             cmdlineRepaint();
00215             <span class="comment">// reposition cursor</span>
00216             <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;CmdlineBufferLength; i++)
00217                 cmdlineOutputFunc(ASCII_BS);
00218         }
00219     }
00220     <span class="comment">// handle special characters</span>
00221     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_CR)
00222     {
00223         <span class="comment">// user pressed [ENTER]</span>
00224         <span class="comment">// echo CR and LF to terminal</span>
00225         cmdlineOutputFunc(ASCII_CR);
00226         cmdlineOutputFunc(ASCII_LF);
00227         <span class="comment">// add null termination to command</span>
00228         CmdlineBuffer[CmdlineBufferLength++] = 0;
00229         CmdlineBufferEditPos++;
00230         <span class="comment">// command is complete, process it</span>
00231         cmdlineProcessInputString();
00232         <span class="comment">// reset buffer</span>
00233         CmdlineBufferLength = 0;
00234         CmdlineBufferEditPos = 0;
00235     }
00236     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_BS)
00237     {
00238         <span class="keywordflow">if</span>(CmdlineBufferEditPos)
00239         {
00240             <span class="comment">// is this a simple delete (off the end of the line)</span>
00241             <span class="keywordflow">if</span>(CmdlineBufferEditPos == CmdlineBufferLength)
00242             {
00243                 <span class="comment">// destructive backspace</span>
00244                 <span class="comment">// echo backspace-space-backspace</span>
00245                 cmdlineOutputFunc(ASCII_BS);
00246                 cmdlineOutputFunc(<span class="charliteral">' '</span>);
00247                 cmdlineOutputFunc(ASCII_BS);
00248                 <span class="comment">// decrement our buffer length and edit position</span>
00249                 CmdlineBufferLength--;
00250                 CmdlineBufferEditPos--;
00251             }
00252             <span class="keywordflow">else</span>
00253             {
00254                 <span class="comment">// edit/cursor position != end of buffer</span>
00255                 <span class="comment">// we're deleting characters at a mid-line edit position</span>
00256                 <span class="comment">// shift characters down, effectively deleting</span>
00257                 CmdlineBufferLength--;
00258                 CmdlineBufferEditPos--;
00259                 <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;CmdlineBufferLength; i++)
00260                     CmdlineBuffer[i] = CmdlineBuffer[i+1];
00261                 <span class="comment">// repaint</span>
00262                 cmdlineRepaint();
00263                 <span class="comment">// add space to clear leftover characters</span>
00264                 cmdlineOutputFunc(<span class="charliteral">' '</span>);
00265                 <span class="comment">// reposition cursor</span>
00266                 <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;(CmdlineBufferLength+1); i++)
00267                     cmdlineOutputFunc(ASCII_BS);
00268             }
00269         }
00270         <span class="keywordflow">else</span>
00271         {
00272             <span class="comment">// else, ring the bell</span>
00273             cmdlineOutputFunc(ASCII_BEL);
00274         }
00275     }
00276     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_DEL)
00277     {
00278         <span class="comment">// not yet handled</span>
00279     }
00280     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_ESC)
00281     {
00282         CmdlineInputVT100State = 1;
00283     }
00284 }
00285 
00286 <span class="keywordtype">void</span> cmdlineRepaint(<span class="keywordtype">void</span>)
00287 {
00288     u08* ptr;
00289     u08 i;
00290 
00291     <span class="comment">// carriage return</span>
00292     cmdlineOutputFunc(ASCII_CR);
00293     <span class="comment">// print fresh prompt</span>
00294     cmdlinePrintPrompt();
00295     <span class="comment">// print the new command line buffer</span>
00296     i = CmdlineBufferLength;
00297     ptr = CmdlineBuffer;
00298     <span class="keywordflow">while</span>(i--) cmdlineOutputFunc(*ptr++);
00299 }
00300 
00301 <span class="keywordtype">void</span> cmdlineDoHistory(u08 action)
00302 {
00303     <span class="keywordflow">switch</span>(action)
00304     {
00305     <span class="keywordflow">case</span> CMDLINE_HISTORY_SAVE:
00306         <span class="comment">// copy CmdlineBuffer to history if not null string</span>
00307         <span class="keywordflow">if</span>( strlen(CmdlineBuffer) )
00308             strcpy(CmdlineHistory[0], CmdlineBuffer);
00309         <span class="keywordflow">break</span>;
00310     <span class="keywordflow">case</span> CMDLINE_HISTORY_PREV:
00311         <span class="comment">// copy history to current buffer</span>
00312         strcpy(CmdlineBuffer, CmdlineHistory[0]);
00313         <span class="comment">// set the buffer position to the end of the line</span>
00314         CmdlineBufferLength = strlen(CmdlineBuffer);
00315         CmdlineBufferEditPos = CmdlineBufferLength;
00316         <span class="comment">// "re-paint" line</span>
00317         cmdlineRepaint();
00318         <span class="keywordflow">break</span>;
00319     <span class="keywordflow">case</span> CMDLINE_HISTORY_NEXT:
00320         <span class="keywordflow">break</span>;
00321     }
00322 }
00323 
00324 <span class="keywordtype">void</span> cmdlineProcessInputString(<span class="keywordtype">void</span>)
00325 {
00326     u08 cmdIndex;
00327     u08 i=0;
00328 
00329     <span class="comment">// save command in history</span>
00330     cmdlineDoHistory(CMDLINE_HISTORY_SAVE);
00331 
00332     <span class="comment">// find the end of the command (excluding arguments)</span>
00333     <span class="comment">// find first whitespace character in CmdlineBuffer</span>
00334     <span class="keywordflow">while</span>( !((CmdlineBuffer[i] == <span class="charliteral">' '</span>) || (CmdlineBuffer[i] == 0)) ) i++;
00335 
00336     <span class="keywordflow">if</span>(!i)
00337     {
00338         <span class="comment">// command was null or empty</span>
00339         <span class="comment">// output a new prompt</span>
00340         cmdlinePrintPrompt();
00341         <span class="comment">// we're done</span>
00342         <span class="keywordflow">return</span>;
00343     }
00344 
00345     <span class="comment">// search command list for match with entered command</span>
00346     <span class="keywordflow">for</span>(cmdIndex=0; cmdIndex&lt;CmdlineNumCommands; cmdIndex++)
00347     {
00348         <span class="keywordflow">if</span>( !strncmp(CmdlineCommandList[cmdIndex], CmdlineBuffer, i) )
00349         {
00350             <span class="comment">// user-entered command matched a command in the list (database)</span>
00351             <span class="comment">// run the corresponding function</span>
00352             CmdlineExecFunction = CmdlineFunctionList[cmdIndex];
00353             <span class="comment">// new prompt will be output after user function runs</span>
00354             <span class="comment">// and we're done</span>
00355             <span class="keywordflow">return</span>;
00356         }
00357     }
00358 
00359     <span class="comment">// if we did not get a match</span>
00360     <span class="comment">// output an error message</span>
00361     cmdlinePrintError();
00362     <span class="comment">// output a new prompt</span>
00363     cmdlinePrintPrompt();
00364 }
00365 
<a name="l00366"></a><a class="code" href="cmdline_8c.html#a33">00366</a> <span class="keywordtype">void</span> <a class="code" href="cmdline_8c.html#a33">cmdlineMainLoop</a>(<span class="keywordtype">void</span>)
00367 {
00368     <span class="comment">// do we have a command/function to be executed</span>
00369     <span class="keywordflow">if</span>(CmdlineExecFunction)
00370     {
00371         <span class="comment">// run it</span>
00372         CmdlineExecFunction();
00373         <span class="comment">// reset</span>
00374         CmdlineExecFunction = 0;
00375         <span class="comment">// output new prompt</span>
00376         cmdlinePrintPrompt();
00377     }
00378 }
00379 
00380 <span class="keywordtype">void</span> cmdlinePrintPrompt(<span class="keywordtype">void</span>)
00381 {
00382     <span class="comment">// print a new command prompt</span>
00383     u08* ptr = CmdlinePrompt;
00384     <span class="keywordflow">while</span>(PRG_RDB(ptr)) cmdlineOutputFunc( PRG_RDB(ptr++) );
00385 }
00386 
00387 <span class="keywordtype">void</span> cmdlinePrintError(<span class="keywordtype">void</span>)
00388 {
00389     u08 * ptr;
00390 
00391     <span class="comment">// print a notice header</span>
00392     <span class="comment">// (u08*) cast used to avoid compiler warning</span>
00393     ptr = (u08*)CmdlineNotice;
00394     <span class="keywordflow">while</span>(PRG_RDB(ptr)) cmdlineOutputFunc( PRG_RDB(ptr++) );
00395     
00396     <span class="comment">// print the offending command</span>
00397     ptr = CmdlineBuffer;
00398     <span class="keywordflow">while</span>((*ptr) &amp;&amp; (*ptr != <span class="charliteral">' '</span>)) cmdlineOutputFunc(*ptr++);
00399 
00400     cmdlineOutputFunc(<span class="charliteral">':'</span>);
00401     cmdlineOutputFunc(<span class="charliteral">' '</span>);
00402 
00403     <span class="comment">// print the not-found message</span>
00404     <span class="comment">// (u08*) cast used to avoid compiler warning</span>
00405     ptr = (u08*)CmdlineCmdNotFound;
00406     <span class="keywordflow">while</span>(PRG_RDB(ptr)) cmdlineOutputFunc( PRG_RDB(ptr++) );
00407 
00408     cmdlineOutputFunc(<span class="charliteral">'\r'</span>);
00409     cmdlineOutputFunc(<span class="charliteral">'\n'</span>);
00410 }
00411 
00412 <span class="comment">// argument retrieval commands</span>
00413 
00414 <span class="comment">// return string pointer to argument [argnum]</span>
<a name="l00415"></a><a class="code" href="cmdline_8c.html#a36">00415</a> u08* <a class="code" href="cmdline_8c.html#a36">cmdlineGetArgStr</a>(u08 argnum)
00416 {
00417     <span class="comment">// find the offset of argument number [argnum]</span>
00418     u08 idx=0;
00419     u08 arg;
00420     
00421     <span class="comment">// find the first non-whitespace character</span>
00422     <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] == <span class="charliteral">' '</span>)) idx++;
00423     
00424     <span class="comment">// we are at the first argument</span>
00425     <span class="keywordflow">for</span>(arg=0; arg&lt;argnum; arg++)
00426     {
00427         <span class="comment">// find the next whitespace character</span>
00428         <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] != <span class="charliteral">' '</span>)) idx++;
00429         <span class="comment">// find the first non-whitespace character</span>
00430         <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] == <span class="charliteral">' '</span>)) idx++;
00431     }
00432     <span class="comment">// we are at the requested argument or the end of the buffer</span>
00433     <span class="keywordflow">return</span> &amp;CmdlineBuffer[idx];
00434 }
00435 
00436 <span class="comment">// return argument [argnum] interpreted as a decimal integer</span>
<a name="l00437"></a><a class="code" href="cmdline_8c.html#a37">00437</a> <span class="keywordtype">long</span> <a class="code" href="cmdline_8c.html#a37">cmdlineGetArgInt</a>(u08 argnum)
00438 {
00439     <span class="keywordtype">char</span>* endptr;
00440     <span class="keywordflow">return</span> strtol(<a class="code" href="cmdline_8c.html#a36">cmdlineGetArgStr</a>(argnum), &amp;endptr, 10);
00441 }
00442 
00443 <span class="comment">// return argument [argnum] interpreted as a hex integer</span>
<a name="l00444"></a><a class="code" href="cmdline_8c.html#a38">00444</a> <span class="keywordtype">long</span> <a class="code" href="cmdline_8c.html#a38">cmdlineGetArgHex</a>(u08 argnum)
00445 {
00446     <span class="keywordtype">char</span>* endptr;
00447     <span class="keywordflow">return</span> strtol(<a class="code" href="cmdline_8c.html#a36">cmdlineGetArgStr</a>(argnum), &amp;endptr, 16);
00448 }
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
