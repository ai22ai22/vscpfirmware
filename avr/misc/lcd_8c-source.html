<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>lcd.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>lcd.c</h1><a href="lcd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file lcd.c \brief Character LCD driver for HD44780/SED1278 displays. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'lcd.c'</span>
00005 <span class="comment">// Title        : Character LCD driver for HD44780/SED1278 displays</span>
00006 <span class="comment">//                  (usable in mem-mapped, or I/O mode)</span>
00007 <span class="comment">// Author       : Pascal Stang</span>
00008 <span class="comment">// Created      : 11/22/2000</span>
00009 <span class="comment">// Revised      : 4/30/2002</span>
00010 <span class="comment">// Version      : 1.1</span>
00011 <span class="comment">// Target MCU   : Atmel AVR series</span>
00012 <span class="comment">// Editor Tabs  : 4</span>
00013 <span class="comment">//</span>
00014 <span class="comment">// This code is distributed under the GNU Public License</span>
00015 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00016 <span class="comment">//</span>
00017 <span class="comment">//*****************************************************************************</span>
00018 
00019 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="lcd_8h.html">lcd.h</a>"</span>
00026 
00027 <span class="comment">// custom LCD characters</span>
00028 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> __attribute__ ((progmem)) LcdCustomChar[] =
00029 {
00030     0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, <span class="comment">// 0. 0/5 full progress block</span>
00031     0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x00, <span class="comment">// 1. 1/5 full progress block</span>
00032     0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, <span class="comment">// 2. 2/5 full progress block</span>
00033     0x00, 0x1F, 0x1C, 0x1C, 0x1C, 0x1C, 0x1F, 0x00, <span class="comment">// 3. 3/5 full progress block</span>
00034     0x00, 0x1F, 0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x00, <span class="comment">// 4. 4/5 full progress block</span>
00035     0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, <span class="comment">// 5. 5/5 full progress block</span>
00036     0x03, 0x07, 0x0F, 0x1F, 0x0F, 0x07, 0x03, 0x00, <span class="comment">// 6. rewind arrow</span>
00037     0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, <span class="comment">// 7. stop block</span>
00038     0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, <span class="comment">// 8. pause bars</span>
00039     0x18, 0x1C, 0x1E, 0x1F, 0x1E, 0x1C, 0x18, 0x00, <span class="comment">// 9. fast-forward arrow</span>
00040     0x00, 0x04, 0x04, 0x0E, 0x0E, 0x1F, 0x1F, 0x00, <span class="comment">// 10. scroll up arrow</span>
00041     0x00, 0x1F, 0x1F, 0x0E, 0x0E, 0x04, 0x04, 0x00, <span class="comment">// 11. scroll down arrow</span>
00042     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, <span class="comment">// 12. blank character</span>
00043     0x00, 0x0E, 0x19, 0x15, 0x13, 0x0E, 0x00, 0x00, <span class="comment">// 13. animated play icon frame 0</span>
00044     0x00, 0x0E, 0x15, 0x15, 0x15, 0x0E, 0x00, 0x00, <span class="comment">// 14. animated play icon frame 1</span>
00045     0x00, 0x0E, 0x13, 0x15, 0x19, 0x0E, 0x00, 0x00, <span class="comment">// 15. animated play icon frame 2</span>
00046     0x00, 0x0E, 0x11, 0x1F, 0x11, 0x0E, 0x00, 0x00, <span class="comment">// 16. animated play icon frame 3</span>
00047 };
00048 
00049 <span class="comment">/*************************************************************/</span>
00050 <span class="comment">/********************** LOCAL FUNCTIONS **********************/</span>
00051 <span class="comment">/*************************************************************/</span>
00052 
00053 <span class="keywordtype">void</span> lcdInitHW(<span class="keywordtype">void</span>)
00054 {
00055     <span class="comment">// initialize I/O ports</span>
00056     <span class="comment">// if I/O interface is in use</span>
00057 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00058 <span class="preprocessor"></span>    <span class="comment">// initialize LCD control lines</span>
00059     cbi(LCD_CTRL_PORT, LCD_CTRL_RS);
00060     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);
00061     cbi(LCD_CTRL_PORT, LCD_CTRL_E);
00062     <span class="comment">// initialize LCD control lines to output</span>
00063     sbi(LCD_CTRL_DDR, LCD_CTRL_RS);
00064     sbi(LCD_CTRL_DDR, LCD_CTRL_RW);
00065     sbi(LCD_CTRL_DDR, LCD_CTRL_E);
00066     <span class="comment">// initialize LCD data port to input</span>
00067     <span class="comment">// initialize LCD data lines to pull-up</span>
00068 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00069 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00070         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00071 <span class="preprocessor">    #else</span>
00072 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);                       <span class="comment">// set data I/O lines to input (8bit)</span>
00073         outb(LCD_DATA_POUT, 0xFF);                      <span class="comment">// set pull-ups to on (8bit)</span>
00074 <span class="preprocessor">    #endif</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>}
00077 
00078 <span class="keywordtype">void</span> lcdBusyWait(<span class="keywordtype">void</span>)
00079 {
00080     <span class="comment">// wait until LCD busy bit goes to zero</span>
00081     <span class="comment">// do a read from control register</span>
00082 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00083 <span class="preprocessor"></span>    cbi(LCD_CTRL_PORT, LCD_CTRL_RS);                <span class="comment">// set RS to "control"</span>
00084 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00085 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F); <span class="comment">// set data I/O lines to input (4bit)</span>
00086         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00087 <span class="preprocessor">    #else</span>
00088 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);                   <span class="comment">// set data I/O lines to input (8bit)</span>
00089         outb(LCD_DATA_POUT, 0xFF);                  <span class="comment">// set pull-ups to on (8bit)</span>
00090 <span class="preprocessor">    #endif</span>
00091 <span class="preprocessor"></span>    sbi(LCD_CTRL_PORT, LCD_CTRL_RW);                <span class="comment">// set R/W to "read"</span>
00092     sbi(LCD_CTRL_PORT, LCD_CTRL_E);                 <span class="comment">// set "E" line</span>
00093     LCD_DELAY;                              <span class="comment">// wait</span>
00094     <span class="keywordflow">while</span>(inp(LCD_DATA_PIN) &amp; 1&lt;&lt;LCD_BUSY)
00095     {
00096         cbi(LCD_CTRL_PORT, LCD_CTRL_E);     <span class="comment">// clear "E" line</span>
00097         LCD_DELAY;                                  <span class="comment">// wait</span>
00098         LCD_DELAY;                                  <span class="comment">// wait</span>
00099         sbi(LCD_CTRL_PORT, LCD_CTRL_E);     <span class="comment">// set "E" line</span>
00100         LCD_DELAY;                                  <span class="comment">// wait</span>
00101         LCD_DELAY;                                  <span class="comment">// wait</span>
00102 <span class="preprocessor">        #ifdef LCD_DATA_4BIT                        // do an extra clock for 4 bit reads</span>
00103 <span class="preprocessor"></span>            cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00104             LCD_DELAY;                              <span class="comment">// wait</span>
00105             LCD_DELAY;                              <span class="comment">// wait</span>
00106             sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00107             LCD_DELAY;                              <span class="comment">// wait</span>
00108             LCD_DELAY;                              <span class="comment">// wait</span>
00109 <span class="preprocessor">        #endif</span>
00110 <span class="preprocessor"></span>    }
00111     cbi(LCD_CTRL_PORT, LCD_CTRL_E);         <span class="comment">// clear "E" line</span>
00112     <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00113 <span class="preprocessor">#else</span>
00114 <span class="preprocessor"></span>    <span class="comment">// memory bus read</span>
00115     <span class="comment">// sbi(MCUCR, SRW);         // enable RAM waitstate</span>
00116     <span class="comment">// wait until LCD busy bit goes to zero</span>
00117     <span class="keywordflow">while</span>( (*((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR))) &amp; (1&lt;&lt;LCD_BUSY) );
00118     <span class="comment">// cbi(MCUCR, SRW);         // disable RAM waitstate</span>
00119 <span class="preprocessor">#endif</span>
00120 <span class="preprocessor"></span>}
00121 
00122 <span class="keywordtype">void</span> lcdControlWrite(u08 data) 
00123 {
00124 <span class="comment">// write the control byte to the display controller</span>
00125 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00126 <span class="preprocessor"></span>    lcdBusyWait();                          <span class="comment">// wait until LCD not busy</span>
00127     cbi(LCD_CTRL_PORT, LCD_CTRL_RS);            <span class="comment">// set RS to "control"</span>
00128     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);            <span class="comment">// set R/W to "write"</span>
00129 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00130 <span class="preprocessor"></span>        <span class="comment">// 4 bit write</span>
00131         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00132         outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); <span class="comment">// set data I/O lines to output (4bit)</span>
00133         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&amp;0xF0) );  <span class="comment">// output data, high 4 bits</span>
00134         LCD_DELAY;                              <span class="comment">// wait</span>
00135         LCD_DELAY;                              <span class="comment">// wait</span>
00136         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00137         LCD_DELAY;                              <span class="comment">// wait</span>
00138         LCD_DELAY;                              <span class="comment">// wait</span>
00139         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00140         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&lt;&lt;4) );    <span class="comment">// output data, low 4 bits</span>
00141         LCD_DELAY;                              <span class="comment">// wait</span>
00142         LCD_DELAY;                              <span class="comment">// wait</span>
00143         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00144 <span class="preprocessor">    #else</span>
00145 <span class="preprocessor"></span>        <span class="comment">// 8 bit write</span>
00146         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00147         outb(LCD_DATA_DDR, 0xFF);               <span class="comment">// set data I/O lines to output (8bit)</span>
00148         outb(LCD_DATA_POUT, data);              <span class="comment">// output data, 8bits</span>
00149         LCD_DELAY;                              <span class="comment">// wait</span>
00150         LCD_DELAY;                              <span class="comment">// wait</span>
00151         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00152 <span class="preprocessor">    #endif</span>
00153 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00154 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00155 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00156         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00157 <span class="preprocessor">    #else</span>
00158 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00159         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00160 <span class="preprocessor">    #endif</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00162 <span class="preprocessor"></span>    <span class="comment">// memory bus write</span>
00163     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00164     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00165     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR)) = data;
00166     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00167 <span class="preprocessor">#endif</span>
00168 <span class="preprocessor"></span>}
00169 
00170 u08 lcdControlRead(<span class="keywordtype">void</span>)
00171 {
00172 <span class="comment">// read the control byte from the display controller</span>
00173     <span class="keyword">register</span> u08 data;
00174 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00175 <span class="preprocessor"></span>    lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00176 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00177 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00178         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00179 <span class="preprocessor">    #else</span>
00180 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00181         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00182 <span class="preprocessor">    #endif</span>
00183 <span class="preprocessor"></span>    cbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "control"</span>
00184     sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "read"</span>
00185 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00186 <span class="preprocessor"></span>        <span class="comment">// 4 bit read</span>
00187         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00188         LCD_DELAY;                      <span class="comment">// wait</span>
00189         LCD_DELAY;                      <span class="comment">// wait</span>
00190         data = inb(LCD_DATA_PIN)&amp;0xF0;  <span class="comment">// input data, high 4 bits</span>
00191         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00192         LCD_DELAY;                      <span class="comment">// wait</span>
00193         LCD_DELAY;                      <span class="comment">// wait</span>
00194         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00195         LCD_DELAY;                      <span class="comment">// wait</span>
00196         LCD_DELAY;                      <span class="comment">// wait</span>
00197         data |= inb(LCD_DATA_PIN)&gt;&gt;4;   <span class="comment">// input data, low 4 bits</span>
00198         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00199 <span class="preprocessor">    #else</span>
00200 <span class="preprocessor"></span>        <span class="comment">// 8 bit read</span>
00201         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00202         LCD_DELAY;                      <span class="comment">// wait</span>
00203         LCD_DELAY;                      <span class="comment">// wait</span>
00204         data = inb(LCD_DATA_PIN);       <span class="comment">// input data, 8bits</span>
00205         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00206 <span class="preprocessor">    #endif</span>
00207 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00208 <span class="preprocessor">#else</span>
00209 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00210     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00211     data = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR));
00212     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00213 <span class="preprocessor">#endif</span>
00214 <span class="preprocessor"></span>    <span class="keywordflow">return</span> data;
00215 }
00216 
00217 <span class="keywordtype">void</span> lcdDataWrite(u08 data) 
00218 {
00219 <span class="comment">// write a data byte to the display</span>
00220 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00221 <span class="preprocessor"></span>    lcdBusyWait();                          <span class="comment">// wait until LCD not busy</span>
00222     sbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "data"</span>
00223     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "write"</span>
00224 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00225 <span class="preprocessor"></span>        <span class="comment">// 4 bit write</span>
00226         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00227         outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); <span class="comment">// set data I/O lines to output (4bit)</span>
00228         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&amp;0xF0) );  <span class="comment">// output data, high 4 bits</span>
00229         LCD_DELAY;                              <span class="comment">// wait</span>
00230         LCD_DELAY;                              <span class="comment">// wait</span>
00231         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00232         LCD_DELAY;                              <span class="comment">// wait</span>
00233         LCD_DELAY;                              <span class="comment">// wait</span>
00234         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00235         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&lt;&lt;4) );    <span class="comment">// output data, low 4 bits</span>
00236         LCD_DELAY;                              <span class="comment">// wait</span>
00237         LCD_DELAY;                              <span class="comment">// wait</span>
00238         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00239 <span class="preprocessor">    #else</span>
00240 <span class="preprocessor"></span>        <span class="comment">// 8 bit write</span>
00241         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00242         outb(LCD_DATA_DDR, 0xFF);           <span class="comment">// set data I/O lines to output (8bit)</span>
00243         outb(LCD_DATA_POUT, data);          <span class="comment">// output data, 8bits</span>
00244         LCD_DELAY;                              <span class="comment">// wait</span>
00245         LCD_DELAY;                              <span class="comment">// wait</span>
00246         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00247 <span class="preprocessor">    #endif</span>
00248 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00249 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00250 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00251         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00252 <span class="preprocessor">    #else</span>
00253 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00254         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00255 <span class="preprocessor">    #endif</span>
00256 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00257 <span class="preprocessor"></span>    <span class="comment">// memory bus write</span>
00258     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00259     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00260     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_DATA_ADDR)) = data;
00261     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00262 <span class="preprocessor">#endif</span>
00263 <span class="preprocessor"></span>}
00264 
00265 u08 lcdDataRead(<span class="keywordtype">void</span>)
00266 {
00267 <span class="comment">// read a data byte from the display</span>
00268     <span class="keyword">register</span> u08 data;
00269 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00270 <span class="preprocessor"></span>    lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00271 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00272 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00273         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00274 <span class="preprocessor">    #else</span>
00275 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00276         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00277 <span class="preprocessor">    #endif</span>
00278 <span class="preprocessor"></span>    sbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "data"</span>
00279     sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "read"</span>
00280 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00281 <span class="preprocessor"></span>        <span class="comment">// 4 bit read</span>
00282         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00283         LCD_DELAY;                              <span class="comment">// wait</span>
00284         LCD_DELAY;                              <span class="comment">// wait</span>
00285         data = inb(LCD_DATA_PIN)&amp;0xF0;  <span class="comment">// input data, high 4 bits</span>
00286         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00287         LCD_DELAY;                              <span class="comment">// wait</span>
00288         LCD_DELAY;                              <span class="comment">// wait</span>
00289         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00290         LCD_DELAY;                              <span class="comment">// wait</span>
00291         LCD_DELAY;                              <span class="comment">// wait</span>
00292         data |= inb(LCD_DATA_PIN)&gt;&gt;4;           <span class="comment">// input data, low 4 bits</span>
00293         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00294 <span class="preprocessor">    #else</span>
00295 <span class="preprocessor"></span>        <span class="comment">// 8 bit read</span>
00296         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00297         LCD_DELAY;                              <span class="comment">// wait</span>
00298         LCD_DELAY;                              <span class="comment">// wait</span>
00299         data = inb(LCD_DATA_PIN);           <span class="comment">// input data, 8bits</span>
00300         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00301 <span class="preprocessor">    #endif</span>
00302 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00303 <span class="preprocessor">#else</span>
00304 <span class="preprocessor"></span>    <span class="comment">// memory bus read</span>
00305     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00306     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00307     data = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_DATA_ADDR));
00308     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00309 <span class="preprocessor">#endif</span>
00310 <span class="preprocessor"></span>    <span class="keywordflow">return</span> data;
00311 }
00312 
00313 
00314 
00315 <span class="comment">/*************************************************************/</span>
00316 <span class="comment">/********************* PUBLIC FUNCTIONS **********************/</span>
00317 <span class="comment">/*************************************************************/</span>
00318 
00319 <span class="keywordtype">void</span> lcdInit()
00320 {
00321     <span class="comment">// initialize hardware</span>
00322     lcdInitHW();
00323     <span class="comment">// LCD function set</span>
00324     lcdControlWrite(LCD_FUNCTION_DEFAULT);
00325     <span class="comment">// clear LCD</span>
00326     lcdControlWrite(1&lt;&lt;LCD_CLR);
00327     delay(60000);   <span class="comment">// wait 60ms</span>
00328     <span class="comment">// set entry mode</span>
00329     lcdControlWrite(1&lt;&lt;LCD_ENTRY_MODE | 1&lt;&lt;LCD_ENTRY_INC);
00330     <span class="comment">// set display to on</span>
00331     <span class="comment">//lcdControlWrite(1&lt;&lt;LCD_ON_CTRL | 1&lt;&lt;LCD_ON_DISPLAY | 1&lt;&lt;LCD_ON_BLINK);</span>
00332     lcdControlWrite(1&lt;&lt;LCD_ON_CTRL | 1&lt;&lt;LCD_ON_DISPLAY );
00333     <span class="comment">// move cursor to home</span>
00334     lcdControlWrite(1&lt;&lt;LCD_HOME);
00335     <span class="comment">// set data address to 0</span>
00336     lcdControlWrite(1&lt;&lt;LCD_DDRAM | 0x00);
00337 
00338     <span class="comment">// load the first 8 custom characters</span>
00339     lcdLoadCustomChar((u08*)LcdCustomChar,0,0);
00340     lcdLoadCustomChar((u08*)LcdCustomChar,1,1);
00341     lcdLoadCustomChar((u08*)LcdCustomChar,2,2);
00342     lcdLoadCustomChar((u08*)LcdCustomChar,3,3);
00343     lcdLoadCustomChar((u08*)LcdCustomChar,4,4);
00344     lcdLoadCustomChar((u08*)LcdCustomChar,5,5);
00345     lcdLoadCustomChar((u08*)LcdCustomChar,6,6);
00346     lcdLoadCustomChar((u08*)LcdCustomChar,7,7);
00347 }
00348 
00349 <span class="keywordtype">void</span> lcdHome(<span class="keywordtype">void</span>)
00350 {
00351     <span class="comment">// move cursor to home</span>
00352     lcdControlWrite(1&lt;&lt;LCD_HOME);
00353 }
00354 
00355 <span class="keywordtype">void</span> lcdClear(<span class="keywordtype">void</span>)
00356 {
00357     <span class="comment">// clear LCD</span>
00358     lcdControlWrite(1&lt;&lt;LCD_CLR);
00359 }
00360 
00361 <span class="keywordtype">void</span> lcdGotoXY(u08 x, u08 y)
00362 {
00363     <span class="keyword">register</span> u08 DDRAMAddr;
00364 
00365     <span class="comment">// remap lines into proper order</span>
00366     <span class="keywordflow">switch</span>(y)
00367     {
00368     <span class="keywordflow">case</span> 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; <span class="keywordflow">break</span>;
00369     <span class="keywordflow">case</span> 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; <span class="keywordflow">break</span>;
00370     <span class="keywordflow">case</span> 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; <span class="keywordflow">break</span>;
00371     <span class="keywordflow">case</span> 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; <span class="keywordflow">break</span>;
00372     <span class="keywordflow">default</span>: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
00373     }
00374 
00375     <span class="comment">// set data address</span>
00376     lcdControlWrite(1&lt;&lt;LCD_DDRAM | DDRAMAddr);
00377 }
00378 
00379 <span class="keywordtype">void</span> lcdLoadCustomChar(u08* lcdCustomCharArray, u08 romCharNum, u08 lcdCharNum)
00380 {
00381     <span class="keyword">register</span> u08 i;
00382     u08 saveDDRAMAddr;
00383 
00384     <span class="comment">// backup the current cursor position</span>
00385     saveDDRAMAddr = lcdControlRead() &amp; 0x7F;
00386 
00387     <span class="comment">// multiply the character index by 8</span>
00388     lcdCharNum = (lcdCharNum&lt;&lt;3);   <span class="comment">// each character occupies 8 bytes</span>
00389     romCharNum = (romCharNum&lt;&lt;3);   <span class="comment">// each character occupies 8 bytes</span>
00390 
00391     <span class="comment">// copy the 8 bytes into CG (character generator) RAM</span>
00392     <span class="keywordflow">for</span>(i=0; i&lt;8; i++)
00393     {
00394         <span class="comment">// set CG RAM address</span>
00395         lcdControlWrite((1&lt;&lt;LCD_CGRAM) | (lcdCharNum+i));
00396         <span class="comment">// write character data</span>
00397         lcdDataWrite( PRG_RDB(lcdCustomCharArray+romCharNum+i) );
00398     }
00399 
00400     <span class="comment">// restore the previous cursor position</span>
00401     lcdControlWrite(1&lt;&lt;LCD_DDRAM | saveDDRAMAddr);
00402 
00403 }
00404 
00405 <span class="keywordtype">void</span> lcdPrintData(<span class="keywordtype">char</span>* data, u08 nBytes)
00406 {
00407     <span class="keyword">register</span> u08 i;
00408 
00409     <span class="comment">// check to make sure we have a good pointer</span>
00410     <span class="keywordflow">if</span> (!data) <span class="keywordflow">return</span>;
00411 
00412     <span class="comment">// print data</span>
00413     <span class="keywordflow">for</span>(i=0; i&lt;nBytes; i++)
00414     {
00415         lcdDataWrite(data[i]);
00416     }
00417 }
00418 
00419 <span class="keywordtype">void</span> lcdProgressBar(u16 progress, u16 maxprogress, u08 length)
00420 {
00421     u08 i;
00422     u32 pixelprogress;
00423     u08 c;
00424 
00425     <span class="comment">// draw a progress bar displaying (progress / maxprogress)</span>
00426     <span class="comment">// starting from the current cursor position</span>
00427     <span class="comment">// with a total length of "length" characters</span>
00428     <span class="comment">// ***note, LCD chars 0-5 must be programmed as the bar characters</span>
00429     <span class="comment">// char 0 = empty ... char 5 = full</span>
00430 
00431     <span class="comment">// total pixel length of bargraph equals length*PROGRESSPIXELS_PER_CHAR;</span>
00432     <span class="comment">// pixel length of bar itself is</span>
00433     pixelprogress = ((progress*(length*PROGRESSPIXELS_PER_CHAR))/maxprogress);
00434     
00435     <span class="comment">// print exactly "length" characters</span>
00436     <span class="keywordflow">for</span>(i=0; i&lt;length; i++)
00437     {
00438         <span class="comment">// check if this is a full block, or partial or empty</span>
00439         <span class="comment">// (u16) cast is needed to avoid sign comparison warning</span>
00440         <span class="keywordflow">if</span>( ((i*(u16)PROGRESSPIXELS_PER_CHAR)+5) &gt; pixelprogress )
00441         {
00442             <span class="comment">// this is a partial or empty block</span>
00443             <span class="keywordflow">if</span>( ((i*(u16)PROGRESSPIXELS_PER_CHAR)) &gt; pixelprogress )
00444             {
00445                 <span class="comment">// this is an empty block</span>
00446                 <span class="comment">// use space character?</span>
00447                 c = 0;
00448             }
00449             <span class="keywordflow">else</span>
00450             {
00451                 <span class="comment">// this is a partial block</span>
00452                 c = pixelprogress % PROGRESSPIXELS_PER_CHAR;
00453             }
00454         }
00455         <span class="keywordflow">else</span>
00456         {
00457             <span class="comment">// this is a full block</span>
00458             c = 5;
00459         }
00460         
00461         <span class="comment">// write character to display</span>
00462         lcdDataWrite(c);
00463     }
00464 
00465 }
00466 
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
