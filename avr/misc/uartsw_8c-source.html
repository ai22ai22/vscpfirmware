<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uartsw.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>uartsw.c</h1><a href="uartsw_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*! \file uartsw.c \brief Software Interrupt-driven UART function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uartsw.c'</span>
00005 <span class="comment">// Title        : Software Interrupt-driven UART function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002-2003</span>
00007 <span class="comment">// Created      : 7/20/2002</span>
00008 <span class="comment">// Revised      : 6/03/2003</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="uartsw_8h.html">uartsw.h</a>"</span>
00025 
00026 <span class="comment">// Program ROM constants</span>
00027 
00028 <span class="comment">// Global variables</span>
00029 
00030 <span class="comment">// uartsw transmit status and data variables</span>
00031 <span class="keyword">volatile</span> u08 UartswTxBusy;
00032 <span class="keyword">volatile</span> u16 UartswBaudRateDiv;
00033 <span class="keyword">volatile</span> u08 UartswTxData;
00034 <span class="keyword">volatile</span> u08 UartswTxBitNum;
00035 
00036 <span class="comment">// receive buffer</span>
<a name="l00037"></a><a class="code" href="uartsw_8c.html#a4">00037</a> cBuffer <a class="code" href="uartsw_8c.html#a4">uartswRxBuffer</a>;               <span class="comment">///&lt; uartsw receive buffer</span>
00038 <span class="comment"></span><span class="comment">// automatically allocate space in ram for each buffer</span>
00039 <span class="keyword">static</span> <span class="keywordtype">char</span> uartswRxData[UARTSW_RX_BUFFER_SIZE];
00040 <span class="comment">// uartsw receive status and data variables</span>
00041 <span class="keyword">volatile</span> u08 UartswRxStartBit;
00042 <span class="keyword">volatile</span> u08 UartswRxData;
00043 <span class="keyword">volatile</span> u08 UartswRxBitNum;
00044 
00045 
00046 <span class="comment">// functions</span>
00047 <span class="comment"></span>
00048 <span class="comment">//! enable and initialize the software uart</span>
<a name="l00049"></a><a class="code" href="uartsw_8c.html#a9">00049</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a9">uartswInit</a>(<span class="keywordtype">void</span>)
00050 {
00051     <span class="comment">// initialize the buffers</span>
00052     <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>();
00053     <span class="comment">// initialize the ports</span>
00054     sbi(DDRD, 5);
00055     cbi(DDRD, 6);
00056     cbi(PORTD, 6);
00057     <span class="comment">// initialize baud rate</span>
00058     uartswSetBaudRate(9600);
00059     <span class="comment">// set timer prescaler</span>
00060     <a class="code" href="timer_8c.html#a11">timer1SetPrescaler</a>(TIMER_CLK_DIV1);
00061     <span class="comment">// attach TxBit service routine to OC1A</span>
00062     <a class="code" href="timer_8c.html#a12">timerAttach</a>(TIMER1OUTCOMPAREA_INT, uartswTxBitService);
00063     <span class="comment">// attach RxStart service routine to ICP</span>
00064     <a class="code" href="timer_8c.html#a12">timerAttach</a>(TIMER1INPUTCAPTURE_INT, uartswRxBitService);
00065     <span class="comment">// attach RxBit service routine to OC1B</span>
00066     <a class="code" href="timer_8c.html#a12">timerAttach</a>(TIMER1OUTCOMPAREB_INT, uartswRxBitService);
00067     <span class="comment">// enable OC1A interrupt</span>
00068     sbi(TIMSK, OCIE1A);
00069     <span class="comment">// enable ICP interrupt</span>
00070     sbi(TIMSK, TICIE1);
00071     <span class="comment">// trigger on rising edge</span>
00072     sbi(TCCR1B, ICES1);
00073     <span class="comment">// turn on interrupts</span>
00074     sei();
00075 }
00076 <span class="comment"></span>
00077 <span class="comment">//! create and initialize the uart buffers</span>
<a name="l00078"></a><a class="code" href="uartsw_8c.html#a10">00078</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>(<span class="keywordtype">void</span>)
00079 {
00080     <span class="comment">// initialize the UART receive buffer</span>
00081     <a class="code" href="buffer_8c.html#a0">bufferInit</a>(&amp;uartswRxBuffer, uartswRxData, UARTSW_RX_BUFFER_SIZE);
00082 }
00083 <span class="comment"></span>
00084 <span class="comment">//! turns off software UART</span>
<a name="l00085"></a><a class="code" href="uartsw_8c.html#a11">00085</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a11">uartswOff</a>(<span class="keywordtype">void</span>)
00086 {
00087     <span class="comment">// disable interrupts</span>
00088     cbi(TIMSK, OCIE1A);
00089     cbi(TIMSK, OCIE1B);
00090     cbi(TIMSK, TICIE1);
00091     <span class="comment">// detach the service routines</span>
00092     <a class="code" href="timer_8c.html#a13">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00093     <a class="code" href="timer_8c.html#a13">timerDetach</a>(TIMER1OUTCOMPAREB_INT);
00094     <a class="code" href="timer_8c.html#a13">timerDetach</a>(TIMER1INPUTCAPTURE_INT);
00095 }
00096 
00097 <span class="keywordtype">void</span> uartswSetBaudRate(u32 baudrate)
00098 {
00099     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00100     UartswBaudRateDiv = (u16)((F_CPU+(baudrate/2L))/(baudrate*1L));
00101 }
00102 <span class="comment"></span>
00103 <span class="comment">//! returns the receive buffer structure </span>
<a name="l00104"></a><a class="code" href="uartsw_8c.html#a13">00104</a> <span class="comment"></span>cBuffer* <a class="code" href="uartsw_8c.html#a13">uartswGetRxBuffer</a>(<span class="keywordtype">void</span>)
00105 {
00106     <span class="comment">// return rx buffer pointer</span>
00107     <span class="keywordflow">return</span> &amp;<a class="code" href="uartsw_8c.html#a4">uartswRxBuffer</a>;
00108 }
00109 
00110 <span class="keywordtype">void</span> uartswSendByte(u08 data)
00111 {
00112     <span class="comment">// wait until uart is ready</span>
00113     <span class="keywordflow">while</span>(UartswTxBusy);
00114     <span class="comment">// set busy flag</span>
00115     UartswTxBusy = TRUE;
00116     <span class="comment">// save data</span>
00117     UartswTxData = data;
00118     <span class="comment">// set number of bits (+1 for stop bit)</span>
00119     UartswTxBitNum = 9;
00120     
00121     <span class="comment">// set the start bit</span>
00122     sbi(PORTD, PD5);
00123     <span class="comment">// schedule the next bit</span>
00124     outw(OCR1A, inw(TCNT1) + UartswBaudRateDiv);
00125 }
00126 <span class="comment"></span>
00127 <span class="comment">//! gets a byte (if available) from the uart receive buffer</span>
<a name="l00128"></a><a class="code" href="uartsw_8c.html#a15">00128</a> <span class="comment"></span>u08 <a class="code" href="uartsw_8c.html#a15">uartswReceiveByte</a>(u08* rxData)
00129 {
00130     <span class="comment">// make sure we have a receive buffer</span>
00131     <span class="keywordflow">if</span>(<a class="code" href="uartsw_8c.html#a4">uartswRxBuffer</a>.size)
00132     {
00133         <span class="comment">// make sure we have data</span>
00134         <span class="keywordflow">if</span>(<a class="code" href="uartsw_8c.html#a4">uartswRxBuffer</a>.datalength)
00135         {
00136             <span class="comment">// get byte from beginning of buffer</span>
00137             *rxData = <a class="code" href="buffer_8c.html#a1">bufferGetFromFront</a>(&amp;uartswRxBuffer);
00138             <span class="keywordflow">return</span> TRUE;
00139         }
00140         <span class="keywordflow">else</span>
00141         {
00142             <span class="comment">// no data</span>
00143             <span class="keywordflow">return</span> FALSE;
00144         }
00145     }
00146     <span class="keywordflow">else</span>
00147     {
00148         <span class="comment">// no buffer</span>
00149         <span class="keywordflow">return</span> FALSE;
00150     }
00151 }
00152 
00153 <span class="keywordtype">void</span> uartswTxBitService(<span class="keywordtype">void</span>)
00154 {
00155     <span class="keywordflow">if</span>(UartswTxBitNum)
00156     {
00157         <span class="comment">// there are bits still waiting to be transmitted</span>
00158         <span class="keywordflow">if</span>(UartswTxBitNum &gt; 1)
00159         {
00160             <span class="comment">// transmit data bits (inverted, LSB first)</span>
00161             <span class="keywordflow">if</span>( !(UartswTxData &amp; 0x01) )
00162                 sbi(PORTD, PD5);
00163             <span class="keywordflow">else</span>
00164                 cbi(PORTD, PD5);
00165             <span class="comment">// shift bits down</span>
00166             UartswTxData = UartswTxData&gt;&gt;1;
00167         }
00168         <span class="keywordflow">else</span>
00169         {
00170             <span class="comment">// transmit stop bit</span>
00171             cbi(PORTD, PD5);
00172         }
00173         <span class="comment">// schedule the next bit</span>
00174         outw(OCR1A, inw(OCR1A) + UartswBaudRateDiv);
00175         <span class="comment">// count down</span>
00176         UartswTxBitNum--;
00177     }
00178     <span class="keywordflow">else</span>
00179     {
00180         <span class="comment">// transmission is done</span>
00181         <span class="comment">// clear busy flag</span>
00182         UartswTxBusy = FALSE;
00183     }
00184 }
00185 
00186 <span class="keywordtype">void</span> uartswRxBitService(<span class="keywordtype">void</span>)
00187 {
00188     <span class="comment">// this function runs on either:</span>
00189     <span class="comment">// - a rising edge interrupt</span>
00190     <span class="comment">// - OC1B</span>
00191     <span class="keywordflow">if</span>(!UartswRxStartBit)
00192     {
00193         <span class="comment">// this is a start bit</span>
00194         <span class="comment">// disable ICP interrupt</span>
00195         cbi(TIMSK, TICIE1);
00196         <span class="comment">// schedule data bit sampling 1.5 bit periods from now</span>
00197         outw(OCR1B, inw(TCNT1) + UartswBaudRateDiv + UartswBaudRateDiv/2);
00198         <span class="comment">// clear OC1B interrupt flag</span>
00199         sbi(TIFR, OCF1B);
00200         <span class="comment">// enable OC1B interrupt</span>
00201         sbi(TIMSK, OCIE1B);
00202         <span class="comment">// set start bit flag</span>
00203         UartswRxStartBit = TRUE;
00204         <span class="comment">// reset bit counter</span>
00205         UartswRxBitNum = 0;
00206         <span class="comment">// reset data</span>
00207         UartswRxData = 0;
00208     }
00209     <span class="keywordflow">else</span>
00210     {
00211         <span class="comment">// start bit has already been received</span>
00212         <span class="comment">// we're in the data bits</span>
00213         
00214         <span class="comment">// shift data byte to make room for new bit</span>
00215         UartswRxData = UartswRxData&gt;&gt;1;
00216 
00217         <span class="comment">// sample the data line</span>
00218         <span class="keywordflow">if</span>( !(inb(PIND) &amp; (1&lt;&lt;6)) )
00219         {
00220             <span class="comment">// serial line is low</span>
00221             <span class="comment">// record '1' bit (data inverted)</span>
00222             UartswRxData |= 0x80;
00223         }
00224 
00225         <span class="comment">// increment bit counter</span>
00226         UartswRxBitNum++;
00227         <span class="comment">// schedule next bit sample</span>
00228         outw(OCR1B, inw(OCR1B) + UartswBaudRateDiv);
00229 
00230         <span class="comment">// check if we have a full byte</span>
00231         <span class="keywordflow">if</span>(UartswRxBitNum &gt;= 8)
00232         {
00233             <span class="comment">// save data in receive buffer</span>
00234             <a class="code" href="buffer_8c.html#a4">bufferAddToEnd</a>(&amp;uartswRxBuffer, UartswRxData);
00235             <span class="comment">// disable OC1B interrupt</span>
00236             cbi(TIMSK, OCIE1B);
00237             <span class="comment">// clear ICP interrupt flag</span>
00238             sbi(TIFR, ICF1);
00239             <span class="comment">// enable ICP interrupt</span>
00240             sbi(TIMSK, TICIE1);
00241             <span class="comment">// clear start bit flag</span>
00242             UartswRxStartBit = FALSE;
00243         }
00244     }
00245 }
00246 
00247 <span class="comment">/*</span>
00248 <span class="comment">void uartswRxBitService(void)</span>
00249 <span class="comment">{</span>
00250 <span class="comment">    u16 thisBitTime;</span>
00251 <span class="comment">    u08 bitperiods;</span>
00252 <span class="comment">    u08 i;</span>
00253 <span class="comment"></span>
00254 <span class="comment">    // bit transition was detected</span>
00255 <span class="comment">    // record bit's edge time</span>
00256 <span class="comment">    thisBitTime = inw(ICR1);</span>
00257 <span class="comment"></span>
00258 <span class="comment">    cbi(PORTB, 0);</span>
00259 <span class="comment"></span>
00260 <span class="comment">    if(!UartswRxStartBit)</span>
00261 <span class="comment">    {</span>
00262 <span class="comment">        // this is a start bit</span>
00263 <span class="comment">        // switch to falling-edge trigger</span>
00264 <span class="comment">        cbi(TCCR1B, ICES1);</span>
00265 <span class="comment">        // record bit time</span>
00266 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00267 <span class="comment">        // set start bit flag</span>
00268 <span class="comment">        UartswRxStartBit = TRUE;</span>
00269 <span class="comment">        // reset bit counter</span>
00270 <span class="comment">        UartswRxBitNum = 0;</span>
00271 <span class="comment">        // reset data</span>
00272 <span class="comment">        UartswRxData = 0;</span>
00273 <span class="comment">    }</span>
00274 <span class="comment">    else</span>
00275 <span class="comment">    {</span>
00276 <span class="comment">        // start bit has already been received</span>
00277 <span class="comment">        // we're in the data bits</span>
00278 <span class="comment">        </span>
00279 <span class="comment">        // how many bit periods since last edge?</span>
00280 <span class="comment">        bitperiods = (thisBitTime - UartswRxBitTime + UartswBaudRateDiv/2)/UartswBaudRateDiv;</span>
00281 <span class="comment">        // set last edge time</span>
00282 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00283 <span class="comment"></span>
00284 <span class="comment">        if(bitperiods &gt; 10)</span>
00285 <span class="comment">        {</span>
00286 <span class="comment">            // switch to trigger on rising edge</span>
00287 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00288 <span class="comment">            // clear start bit flag</span>
00289 <span class="comment">            UartswRxStartBit = FALSE;</span>
00290 <span class="comment">        }</span>
00291 <span class="comment">        else</span>
00292 <span class="comment">        {</span>
00293 <span class="comment"></span>
00294 <span class="comment"></span>
00295 <span class="comment">        if( inb(TCCR1B) &amp; (1&lt;&lt;ICES1) )</span>
00296 <span class="comment">        {</span>
00297 <span class="comment">            // just triggered on a rising edge</span>
00298 <span class="comment">            // previous bits were zero</span>
00299 <span class="comment">            // shift in the data (data bits are inverted)</span>
00300 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00301 <span class="comment">            {</span>
00302 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00303 <span class="comment">                UartswRxData |= 0x01;</span>
00304 <span class="comment">            }</span>
00305 <span class="comment">            // switch to trigger on falling edge</span>
00306 <span class="comment">            cbi(TCCR1B, ICES1);</span>
00307 <span class="comment">        }</span>
00308 <span class="comment">        else</span>
00309 <span class="comment">        {</span>
00310 <span class="comment">            // just triggered on a falling edge</span>
00311 <span class="comment">            // previous bits were one</span>
00312 <span class="comment">            // shift in the data (data bits are inverted)</span>
00313 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00314 <span class="comment">            {</span>
00315 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00316 <span class="comment">            }</span>
00317 <span class="comment">            // switch to trigger on rising edge</span>
00318 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00319 <span class="comment">        }</span>
00320 <span class="comment">        </span>
00321 <span class="comment">        // increment bit counter</span>
00322 <span class="comment">        UartswRxBitNum += bitperiods;</span>
00323 <span class="comment">        </span>
00324 <span class="comment">        // check if we have a full byte + start bit</span>
00325 <span class="comment">        if(bitperiods &gt; 8)</span>
00326 <span class="comment">        {</span>
00327 <span class="comment">            // save data in receive buffer</span>
00328 <span class="comment">            bufferAddToEnd(&amp;uartswRxBuffer, UartswRxData);</span>
00329 <span class="comment">            // switch to trigger on rising edge</span>
00330 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00331 <span class="comment">            // clear start bit flag</span>
00332 <span class="comment">            UartswRxStartBit = FALSE;</span>
00333 <span class="comment">        }</span>
00334 <span class="comment">        }</span>
00335 <span class="comment">    }</span>
00336 <span class="comment"></span>
00337 <span class="comment">    // turn off debug LEDs</span>
00338 <span class="comment">    delay(10);</span>
00339 <span class="comment">    sbi(PORTB, 0);</span>
00340 <span class="comment">    sbi(PORTB, 1);</span>
00341 <span class="comment">}</span>
00342 <span class="comment">*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Sun Feb 22 19:12:31 2004 for Procyon AVRlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
