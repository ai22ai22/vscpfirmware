; ***************************************
; * Demo 16C84 Program by Edward Cardew *
; *        Edward_Cardew@aia.com        *
; * Program only for non commercial use *
; ***************************************


; *************************************** 
; * Uses 4bit LCD interface write only  *
; * Keypad via resistors to same 4bit   *
; * RS232 Output "Bit Bang" via RB_3    *
; * Piezzo for the music on pin RA_0    *
; * RC5 on the fly decode via RB0_Int   *
; ***************************************



; Notes:
;       PIC16C84 Running at 4MHz
;       RC5 "extended" 10TAAAAACCCCCC
;       RC5 "normal"   11TAAAAACCCCCC
;               T = Toggle
;               A = Address
;               C = Command


;       RC5 decoding algorithm:
;
;       0 transmitted as 10 = 2 T
;       1 transmitted as 01 = 2 T
;
;       Known   T       Add
;
;       1       2       1
;       1       3       00
;       1       4       01
;       0       2       0
;       0       3       1
;       0       4       Err





; Blah blah
;OK, I'll try to explain,
;
;RC5 code is transmitted using Manchester code:
;0 is transmitted as 10 and 1 is transmitted 01.
;It is possible to decode this by just detecting the slope (this generates
;the interrupt).
;Knowing that the first transmitted bits are 11 (0101) and using the timer
;(restarted at each interrupt), it is possible to decode RC5 using the
;intervals between same slopes. Until recently first code could not decode
;the extended codes used in newer remote controls (starting with 10) but now
;that works.
;
;A transmission from the remote consists of
;2 start bits
;1 toggle bit (changes after each key)
;5 bit address (currently not used)
;6 bit command
;
;The table explains the algorithm used.
;
;The bits that are already known.
;The time that has elapsed in T time units since the last interrupt (normal
;values are 2,3 and 4).
;One Manchester encoded bit takes 2T (i.e. 10 or 01) to transmit.
;And the bits to add to the known bits (the decoding as such).
;
;When the transmission ends, the timer runs out and generates an interrupt
;indicating a new code.
;
;The soft as is will display a constantly changing message on the screen and
;decode RC5 command codes at the same time.
;
;The LCD has following connections:
;A3 -> Enable
;A2 -> RS
;B4 -> D4
;B3 -> D3
;B2 -> D2
;B1 -> D1
;The LCD is a 2x16 but any one will work. Tie W/R to ground.
;
;Piezzo speaker connected to A0
;
;RS232 output goes via B3 straight to PC (if it likes 0/5V)
;
;InfraRed receiver connects to B0 / Int
;
;4 Keys connect B4 to B7 to ground via resistor (Yes the same lines as LCD,
;600 ohm resistors prevent damage)
;
;Many more things to follow on other PIC ports ...    ;-)
;
;
;The code does contain a subroutine to read keys, all the code works but may
;not be used in the "main program"
;Many more code snips are there as well such as bin->hex, byte->LCD,
;byte->RS232 etc, ...
;
;The project will eventually do RS232 both ways, detect a low battery, use
;I2C (with clock and large EEPROM), etc ...
;
;When the project is finished I'll draw a circuit shematic.



; ***** Assembler Directives *****        



        LIST    P=PIC16C84

        INCLUDE "P16C84.INC"



                __FUSES _XT_OSC & _PWRTE_ON & _WDT_OFF & _CP_OFF



; ***** Variables Definitions *****



RAMbase         equ     12



        cblock  RAMbase
                large_count
                small_count
                flags
                temp
                LCD_Count
                Key_Press
                RS232_Chr
                Table_Temp
                W_Temp
                S_Temp
                T_Temp
                Old_T_Temp
                RC5_Bit_Count
                RC5_Command
                temp_2
        endc



; ***** Definitions *****

#define RS              PORTA,3                 ; LCD R/S Line 0=ctrl 1=data
#define E               PORTA,2                 ; LCD Enable Line
#define PIEP            PORTA,0                 ; Piezzo Tweeter
#define LCD_Mode        flags,0                 ; 0=Control, 1=Data
#define Last_RC5_Bit    flags,1                 ; Last RC5 bit received
#define RC5_2nd_Bit     flags,2                 ; Add 2 RC5 bits
#define RC5_2nd_Value   flags,3                 ; 2nd RC5 bit received
#define RC5_Bit         flags,4                 ; 1st RC5 bit received
#define SEL_BANK_0      bcf     STATUS,RP0      ; Select Bank 0
#define SEL_BANK_1      bsf     STATUS,RP0      ; Select Bank 1
#define RS232_TX        PORTB,3                 ; RS232 Transmit
#define CARRY           STATUS,C
#define ZERO            STATUS,Z


; ***** RESET *****

        org     0000h
Reset_Vector
        call    Beep                            ; Indicate Reset was OK
        call    Init_LCD                        ; Initialise LCD
        call    Init_RC5                        ; Initialise RC5
        goto    Main_Start                      ; Skip Interrupt Routines

; ***** INTERRUPT *****

Interrupt_Vector
        if (Interrupt_Vector != 0x004 )
                ERROR   "Warning Interrupts must start at address 0x004"
        endif

Push    movwf   W_Temp                          ; Save W
        swapf   STATUS,W
        movwf   S_Temp                          ; Save STATUS
        SEL_BANK_0
Disable_Int
        bcf     INTCON,GIE                      ; Disable all Interrupts
        btfsc   INTCON,GIE                      ; Are Interrupts disabled ?
        goto    Disable_Int                     ; NO, try again

        btfsc   INTCON,INTF                     ; Skip PORTB0/Interrupt?
        goto    RB0_Int                         ; NO, goto RB0

        btfsc   INTCON,T0IF                     ; Skip Timer Overflow Interrupt ?
        goto    Timer_Int                       ; NO, goto Timer Interrupt

Pop     swapf   S_Temp,W
        movwf   STATUS                          ; Return STATUS
        swapf   W_Temp,F
        swapf   W_Temp,W                        ; Return W
        retfie                                  ; Return setting GIE

; ***** RB0/INT RC5 Interrupt *****

RB0_Int
        bsf     PIEP
        bcf     INTCON,T0IE                     ; Disable further Timer0 Interrupts
        bcf     INTCON,T0IF                     ; Clear Overflow Flag

        movf    TMR0,W                          ; Get Timer Value        
        movwf   T_Temp                          ; And rescue

        movlw   b'00000011'                     ; W takes 1:16
        clrf    TMR0
        SEL_BANK_1
        iorwf   OPTION_REG,F                    ; 1:16
        SEL_BANK_0

        bcf     RC5_2nd_Bit

; ***** First Bit ??? ******

        movf    RC5_Bit_Count,F
        btfsc   ZERO
        goto    RC5_Add_1

; ***** Decide which window contains T_Temp [ <> 8C <> CF <> ] 

        movlw   h'8C'
        subwf   T_Temp,W                        ; Carry will be cleared if T_Temp < 8C ie 2T
        btfss   CARRY                           ; Skip if >= 8C
        goto    Timer_is_2T

; must be >= 8C

        movlw   h'CF'                           ; Idem with CF
        subwf   T_Temp,W
        btfss   CARRY
        goto    Timer_is_3T

Timer_is_4T
        btfss   Last_RC5_Bit                    ; Was last bit "1" ?
        goto    RC5_Rx_Error                    ; No, was "0", error!
        goto    RC5_Add_01                      ; Last bit was "1", add "01"

Timer_is_2T
        btfss   Last_RC5_Bit                    ; Was last bit "1" ?
        goto    RC5_Add_0                       ; No, was "0", add "0"
        goto    RC5_Add_1                       ; No, was "1", add "1"

Timer_is_3T
        btfss   Last_RC5_Bit                    ; Was last bit "1" ?
        goto    RC5_Add_1                       ; No, was "0", add "1"
        goto    RC5_Add_00                      ; Last bit was "1", add "00"

; ***** If Two Bits must be added, the first one is always a 0

RC5_Add_01
        bsf     RC5_2nd_Value
        goto    RC5_Add_0X

RC5_Add_00
        bcf     RC5_2nd_Value

RC5_Add_0X
        bsf     RC5_2nd_Bit

RC5_Add_0
        bcf     RC5_Bit
        goto    RC5_Add_Bit

RC5_Add_1
        bsf     RC5_Bit

RC5_Add_Bit
        bcf     PIEP

        btfss   RC5_Bit                         ; Save bit for future
        goto    RC5_was_0                       ;
        bsf     Last_RC5_Bit                    ;
        goto    RC5_Test_End                    ;

RC5_was_0                                       ;
        bcf     Last_RC5_Bit                    ;

RC5_Test_End                                    ; Bit saved.
        incf    RC5_Bit_Count,F                 ; Increment Bit Count

        movlw   d'2'                            ; Test if RC5 bit extended (bit 2)
        subwf   RC5_Bit_Count,W
        btfsc   ZERO                            ; If extended bit then
        goto    RC5_Command_Rotate              ; add extended bit to Command

        movlw   d'9'                            ; Test Bit Count for >= 9
        subwf   RC5_Bit_Count,W                 ; Carry will be set if >= 9
        btfss   CARRY                           ; Skip if >= 9
        goto    RC5_Add_Bit_End

RC5_Command_Rotate
        rlf     RC5_Command                     ; RC5 Command Section
        bcf     RC5_Command,0
        btfsc   RC5_Bit                         ; Skip next if 0
        bsf     RC5_Command,0

RC5_Add_Bit_End
        btfss   RC5_2nd_Bit                     ; Add two bits ?
        goto    RC5_Int_End                     ; No, End Interrupt
        bcf     RC5_2nd_Bit                     ; Two bits, now one bit!
        btfsc   RC5_2nd_Value                   ; Second bit is 0 ?
        goto    RC5_Add_1                       ; No, add a 1
        goto    RC5_Add_0                       ; Yes, add a 0

RC5_Rx_Error

RC5_Int_End
        bsf     INTCON,T0IE                     ; Enable Timer0 Interrupts
        bcf     INTCON,INTF                     ; Clear Interrupt PortB Flag
        goto    Pop                             ; Quit via POP

Timer_Int                                       ; RC5 Time of the Truth
        bcf     INTCON,T0IE                     ; Disable further Timer0 Interrupts
        bcf     INTCON,T0IF                     ; Clear Overflow

        movlw   d'13'                           ; Test Bit Count = 13
        subwf   RC5_Bit_Count,W                 ; Zero will be set if Count = 13
        btfss   ZERO                            ; Skip if = 13, will need to add a 0
        goto    No_Zero_Needed
        incf    RC5_Bit_Count,F                 ; Increment Bit Count
        rlf     RC5_Command                     ; RC5 Command Section
        bcf     RC5_Command,0

No_Zero_Needed
        movlw   b'01000000'                     ; Do some cosmetics:
        xorwf   RC5_Command,F                   ; Put extended above normal commands

; RC5 Gimmicks
        bcf     LCD_Mode                        ; Control
        movlw   b'10000000'                     ; Goto Pos 1
        call    Send_LCD
        bsf     LCD_Mode                        ; Text
        movf    RC5_Bit_Count,W                 ; Get No of bits
        call    HEX2LCD                         ; And display it
        movlw   #" "
        call    Send_LCD

;       movlw   d'14'                           ; Test Bit Count = 14
;       subwf   RC5_Bit_Count,W                 ; Zero will be set if Count = 14
;       btfss   ZERO                            ; Skip if = 14, do normal
;       goto    RC5_was_Err                     ; Error display

        movf    RC5_Command,W                   ; Get Command
        call    HEX2LCD                         ; And display it
        goto    RC5_Timer_Reset

RC5_was_Err
        movlw   #"E"
        call    Send_LCD
        movlw   #"r"
        call    Send_LCD

; Reset RC5 variables

RC5_Timer_Reset
        bsf     Last_RC5_Bit
        clrf    RC5_Bit_Count
        clrf    RC5_Command

        goto    Pop                             ; Quit via POP



; *************************
; ***** Main Program ******
; *************************

Main_Start
        call    LCD_Graph               ; Define LCD Graphics

        call    Beep

        bcf     LCD_Mode                ; LCD Control Mode
        movlw   b'11000000'             ; Position on begining Row 2
        call    Send_LCD                ; Do it!

        call    Text_1                  ; Send Startup Text

main_loop
        SEL_BANK_1                      ; Prepare Ports for Keys
        bcf     OPTION_REG,NOT_RBPU     ; Turn on Pullup
        movlw   b'11110000'             ; Port B top Nibble Input
        iorwf   TRISB,1                 ; Set port B<4..7> to input
        SEL_BANK_0

        movf    PORTB,0
        movwf   Key_Press
        swapf   Key_Press,0     ; Get Port B and swap
        andlw   b'00001111'
        addlw   b'00110000'
        movwf   Key_Press

        bcf     LCD_Mode        ; Control
        movlw   b'10001111'     ; Goto Pos 16
        call    Send_LCD
        bsf     LCD_Mode        ; Text
        movlw   0
        call    Send_LCD
        call    Long_Wait
       
        bcf     LCD_Mode        ; Control
        movlw   b'10001111'     ; Goto Pos 16
        call    Send_LCD
        bsf     LCD_Mode        ; Text
        movlw   1
        call    Send_LCD
        call    Long_Wait
        
        bcf     LCD_Mode        ; Control
        movlw   b'10001111'     ; Goto Pos 16
        call    Send_LCD

        bsf     LCD_Mode        ; Text
        movlw   2
        call    Send_LCD
        call    Long_Wait
        
        bcf     LCD_Mode        ; Control
        movlw   b'10001111'     ; Goto Pos 16
        call    Send_LCD
        bsf     LCD_Mode        ; Text
        movlw   3
        call    Send_LCD
        call    Long_Wait

        goto    main_loop

DUMP
        movlw   d'30'
        movwf   LCD_Count
DUMP_L
        movf    LCD_Count,W
        movwf   FSR
        movf    INDF,W
        call    HEX2RS232
        incf    LCD_Count,F
        movf    LCD_Count,W
        sublw   d'45'
        btfsc   ZERO
        goto    ELP
        goto    DUMP_L

ELP     goto    ELP


; ***********************
; ***** Subroutines *****
; ***********************

; ***** Initialise RC5 *****

Init_RC5

        bsf     Last_RC5_Bit
        clrf    RC5_Bit_Count
        clrf    RC5_Command

; ***** Set up Timer for RC5
        SEL_BANK_0
        bcf     INTCON,T0IE                     ; No Timer Interrupts
        clrwdt                                  ; Clear WDT
        SEL_BANK_1
        movlw   b'11010000'
        andwf   OPTION_REG,F                    ; Clear Timer Options

        SEL_BANK_1
        bcf     OPTION_REG,INTEDG               ; Interrupt on falling  edge (eg. SFH505)
;       bsf     OPTION_REG,INTEDG               ; Interrupt on rising  edge (eg. TDA3047)
        SEL_BANK_0

        bsf     INTCON,INTE                     ; Enable RB0/INT
        bsf     INTCON,GIE                      ; Enable Interrupts Global
        return

; ***** Send a HEX byte in W to LCD *****

HEX2LCD
        movwf   temp_2
        swapf   temp_2,W
        call    Nibble2ASCII
        call    Send_LCD
        movf    temp_2,W
        call    Nibble2ASCII
        call    Send_LCD
        return

; ***** Send a HEX byte in W to RS232 *****

HEX2RS232
        movwf   temp_2
        swapf   temp_2,0
        call    Nibble2ASCII
        call    Send_RS232
        movf    temp_2,0
        call    Nibble2ASCII
        call    Send_RS232
        movlw   #" "
        call    Send_RS232
        return

; ***** Convert Nibble to ASCII Hex Digit *****

Nibble2ASCII
        andlw   h'0F'
        addlw   h'F6'
        btfsc   CARRY
        addlw   h'07'
        addlw   h'3A'
        return

; ***** RS232 Send W via Port B3 *****

Send_RS232
        movwf   RS232_Chr
        SEL_BANK_1
        bcf     TRISB,3         ; Set port B3 to output
        SEL_BANK_0

        movlw   08h
        movwf   large_count     ; 8 Bits to send

        bsf     RS232_TX        ; Send Start Bit
        call    Wait_Bit

Send_RS232_Loop
        btfsc   RS232_Chr,0
        goto    RS232_TX_1
        goto    RS232_TX_0

RS232_TX_1
        bcf     RS232_TX
        goto    RS232_Cont

RS232_TX_0
        bsf     RS232_TX
        goto    RS232_Cont

RS232_Cont
        call    Wait_Bit
        rrf     RS232_Chr,1
        decfsz  large_count,1
        goto    Send_RS232_Loop

        bcf     RS232_TX
        call    Wait_Bit

        return


; ***** Define LCD Graphics ******

LCD_Graph
        bcf     LCD_Mode        ; Control Mode
        
        movlw   b'01000000'     ; CGRAM set to 0
        call    Send_LCD

        bsf     LCD_Mode        ; Data Mode

        clrf    LCD_Count
LCD_Graph_L
        movf    LCD_Count,0
        call    GraphDef
        call    Send_LCD
        incf    LCD_Count,1
        movf    LCD_Count,0
        sublw   d'32'
        btfsc   ZERO
        return
        goto    LCD_Graph_L


        call    GraphDef
        call    Send_LCD
        decfsz  large_count,1
        goto    LCD_Graph_L
        return






; ***** Send some Text *****

Text_1
        clrf    LCD_Count
        bsf     LCD_Mode        ; Text Mode
Text_1_L
        movf    LCD_Count,0
        call    Message
        call    Send_LCD

        incf    LCD_Count,1
        movf    LCD_Count,0
        sublw   d'16'
        btfsc   ZERO
        return
        goto    Text_1_L




; ***** Send Data to LCD *****
; ***** Data is in W register

Wait_Send_LCD
        movwf   temp
        call    Wait_2ms
        movf    temp,W
Send_LCD
        movwf   temp            ; Save W
        call    Init_Port_LCD   ; Initialise Ports for LCD
        bcf     RS              ; Set to Control Mode
        btfsc   LCD_Mode        ; Skip Data Mode if LCD_Mode = 0
        bsf     RS
        movf    temp,W
        call    Toggle_E
        swapf   temp,W    
        call    Toggle_E
        bcf     RS
        call    Wait_60us
        return

; ***** Initialize LCD *****

Init_LCD
        call    Wait_2ms        ; Let Voltages Settle
        bcf     LCD_Mode        ; LCD Control Mode
        call    Init_Port_LCD   ; Initialise Ports
        clrf    PORTA              ; Port  A low
        bcf     RS
        movlw   b'00110000'     ; Set 8 bit interface
        call    Wait_Toggle_E
        
        movlw   b'00110000'     ; Set 8 bit interface
        call    Wait_Toggle_E

        movlw   b'00110000'     ; Set 8 bit interface
        call    Wait_Toggle_E

        movlw   b'00100000'     ; Set 4 bit interface
        call    Wait_Toggle_E

        movlw   b'00101000'     ; 4 bit  2 line  5x7
        call    Wait_Send_LCD

        movlw   b'00001000'     ; Display all off
        call    Wait_Send_LCD
        
        movlw   b'00000001'     ; Clear Display (Takes Time)
        call    Wait_Send_LCD

        movlw   b'00000110'     ; Cursor increment  no Shift
        call    Wait_Send_LCD

        movlw   b'00001100'     ; Disp On  Cursor Off  Blink On
        call    Wait_Send_LCD

        movlw   b'00101000'     ; 4 bit  2 line  5x7
        call    Wait_Send_LCD

        return

; ***** Initialise Ports for LCD *****

Init_Port_LCD
        SEL_BANK_1              ; Prepare Ports for LCD
;        movlw   b'00001111'     ; Port B top Nibble Output
;        andwf   TRISB,1         ; Set port B<4..7> to output
; ????? WHY DOES ABOVE TWO NOT WORK ?????
        bcf     TRISB,4
        bcf     TRISB,5
        bcf     TRISB,6
        bcf     TRISB,7
        bcf     TRISA,2         ; Set Port A,2 (E) to output
        bcf     TRISA,3         ; Set Port A,3 (RS) to output
        SEL_BANK_0
        return

; ***** Latch Data into LCD *****
Wait_Toggle_E
        movwf   temp
        call    Wait_2ms
        call    Wait_2ms
        call    Wait_2ms
        call    Wait_2ms
        movf    temp,W
Toggle_E
        andlw   b'11110000'     ; Do not disturb other ports
        movwf   PORTB
        bsf     E
        bcf     E
        return

; ***** Long Wait *****

Long_Wait
        movlw   d'150'                          ; No of Cycles
        movwf   large_count
Long_Wait_Loop
        call    Wait_2ms
        decfsz  large_count,1
        goto    Long_Wait_Loop
        return

; ***** Beep ! *****

Beep
        SEL_BANK_1
        bcf     TRISA,0         ; Set port A0 to output
        SEL_BANK_0

        movlw   d'50'           ; No of Cycles
        movwf   large_count
Beep_Loop
        bcf     PIEP
        call    Wait_2ms
        bsf     PIEP
        call    Wait_2ms
        decfsz  large_count,1
        goto    Beep_Loop
        return

; ***** Wait 60 usec *****

Wait_60us
        movlw   d'20'
        movwf   small_count
W60u_Loop
        decfsz  small_count,1   ; 1
        goto W60u_Loop          ; 2
        return

; ***** Wait 196 usec *****

Wait_Bit
        movlw   d'65'
        movwf   small_count
W196u_Loop
        decfsz  small_count,1   ; 1
        goto W196u_Loop         ; 2
        return

; ***** Wait 2 msec *****

Wait_2ms
        movlw   d'200'          ; 200 x 10us = 2000us = 2ms
        movwf   small_count
W1m_Loop
        nop                     ; 1
        nop                     ; 2
        nop                     ; 3
        nop                     ; 4
        nop                     ; 5
        nop                     ; 6
        nop                     ; 7
        decfsz  small_count,1   ; +1
        goto W1m_Loop           ; +2 = 10 cycles
        return



; ***** TABLES ***** TABLES ***** TABLES ***** 
        
        org     h'0300'

Message 
        movwf   Table_Temp
        movlw   h'03'
        movwf   PCLATH
        movf    Table_Temp,W
        addwf   PCL,F
        dt      "This is a Test !"
        
GraphDef
        movwf   Table_Temp
        movlw   h'03'
        movwf   PCLATH
        movf    Table_Temp,W
        addwf   PCL,F
        retlw   b'00000000'
        retlw   b'00001100'
        retlw   b'00000100'
        retlw   b'00000100'
        retlw   b'00000100'
        retlw   b'00000110'
        retlw   b'00000000'
        retlw   0

        retlw   b'00000000'
        retlw   b'00000110'
        retlw   b'00000010'
        retlw   b'00000100'
        retlw   b'00001000'
        retlw   b'00001100'
        retlw   b'00000000'
        retlw   0
        
        retlw   b'00000000'
        retlw   b'00000000'
        retlw   b'00000001'
        retlw   b'00011111'
        retlw   b'00010000'
        retlw   b'00000000'
        retlw   b'00000000'
        retlw   0
        
        retlw   b'00000000'
        retlw   b'00000000'
        retlw   b'00011000'
        retlw   b'00010101'
        retlw   b'00000011'
        retlw   b'00000000'
        retlw   b'00000000'
        retlw   0

; ***** Reset 16C84 *****

        org     03FFh
        goto    Reset_Vector
;
        END

