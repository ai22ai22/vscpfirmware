	init();                             // Initialize Microcontroller	
	
	// Check VSCP persistent storage and
	// restore if needed
	if ( !vscp_check_pstorage() ) {
		
		// Spoiled or not initialized - reinitialize
		init_app_eeprom();	

	}

	vscp_init();						// Initialize the VSCP functionality

	while ( 1 ) {                     	// Loop Forever	
		
		ClrWdt();

		if ( ( vscp_initbtncnt > 100 ) && ( VSCP_STATE_INIT != vscp_node_state ) ) {
			// Init button pressed
			vscp_nickname = VSCP_ADDRESS_FREE;
			writeEEPROM( VSCP_EEPROM_NICKNAME, VSCP_ADDRESS_FREE );
			vscp_init();
		}

		// Check for any valid CAN message
		vscp_imsg.flags = 0;
		vscp_getEvent();

		// do a meaurement if needed
		if ( measurement_clock > 1000 ) {
			
			measurement_clock = 0;
			seconds++;
			
			if ( VSCP_STATE_ACTIVE == vscp_node_state  ) {
				
				for ( i=0; i<8; i++ ) {
					
					// Get control register for this relay
					ctrlreg = readEEPROM( VSCP_EEPROM_END + REG_RELAY_CONTROL0 + i );
					
					// If not enabled check next
					if( !( ctrlreg & RELAY_CONTROLBIT_ENABLED ) ) continue;
										
					if ( relay_protection_timer[ i ] ) {
						
						relay_protection_timer[ i ]--;
						
						// Check if its time to act on protection time
						if ( !relay_protection_timer[ i ] && 
							( readEEPROM( VSCP_EEPROM_END + REG_RELAY_CONTROL0 + i ) & RELAY_CONTROLBIT_PROTECTION ) ) {
	
							// Yes - its time to protect this relay
							doActionOff( 0, ( 1 << i ) );
							
							// Should alarm be sent?
							if( ctrlreg & RELAY_CONTROLBIT_ALARM ) {
								SendInformationEvent( i, VSCP_CLASS1_ALARM, VSCP_TYPE_ALARM_ALARM );
							}
							
						}	
					}
					
					// Handle pulsed relays
					if( relay_pulse_flags & ( 1 << i ) ) {
						
						if ( relay_pulse_timer[ i ] ) {
							
							relay_pulse_timer[ i ]--;
							
							// If zero its time for state change
							if ( !relay_pulse_timer[ i ] ) {
								
								switch ( i ) {
									
									case 0:
										if ( PORTCbits.RC7 ) {
											PORTCbits.RC7 = 0;
											bOn=FALSE;
										}
										else {
											PORTCbits.RC7 = 1;
											bOn=TRUE;
										}
										break;
										
									case 1:
										if ( PORTAbits.RA5 ) { 
											PORTAbits.RA5 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA5 = 1;
											bOn=TRUE;
										}
										break;
									
									case 2:
										if ( PORTAbits.RA4 ) {
											PORTAbits.RA4 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA4 = 1;
											bOn=TRUE;
										}
										break;
									
									case 3:
										if ( PORTAbits.RA3 ) {
											PORTAbits.RA3 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA3 = 1;
											bOn=TRUE;
										}
										break;
									
									case 4:
										if ( PORTAbits.RA2 ) {
											PORTAbits.RA2 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA2 = 1;
											bOn=TRUE;
										}
										break;
									
									case 5:
										if ( PORTAbits.RA1 ) {
											PORTAbits.RA1 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA1 = 1;
											bOn=TRUE;
										}
										break;				
									
									case 6:
										if ( PORTAbits.RA0 ) {
											PORTAbits.RA0 = 0;
											bOn=FALSE;
										}
										else {
											PORTAbits.RA0 = 1;
											bOn=TRUE;
										}
										break;
									
									case 7:
										if ( PORTCbits.RC5 ) {
											PORTCbits.RC5 = 0;
											bOn=FALSE;
										}
										else {
											PORTCbits.RC5 = 1;
											bOn=TRUE;
										}
										break;
								}
								
								// Reload timer
								relay_pulse_timer[ i ] = readEEPROM( VSCP_EEPROM_END + REG_RELAY_PULSE_TIME_MSB0 + 2 * i ) * 256 +
															readEEPROM( VSCP_EEPROM_END + REG_RELAY_PULSE_TIME_LSB0 + 2 * i );
							
								if ( bOn ) {	
			
									if ( ctrlreg & RELAY_CONTROLBIT_ONEVENT ) {
										SendInformationEvent( i, VSCP_CLASS1_INFORMATION, VSCP_TYPE_INFORMATION_ON );
									}
			
									if( ctrlreg & RELAY_CONTROLBIT_STARTEVENT ) {
										SendInformationEvent( i, VSCP_CLASS1_INFORMATION, VSCP_TYPE_INFORMATION_START );
									}
			
								}
								else {
		
									if( ctrlreg & RELAY_CONTROLBIT_OFFEVENT ) {
										SendInformationEvent( i, VSCP_CLASS1_INFORMATION, VSCP_TYPE_INFORMATION_OFF );
									}
		
									if( ctrlreg & RELAY_CONTROLBIT_STOPEVENT ) {
										SendInformationEvent( i, VSCP_CLASS1_INFORMATION, VSCP_TYPE_INFORMATION_STOP );
									}
								}
															
							} // State change
							
						} // Something to count down	
																	
					} // Pulse bit
					
				} // for all relays
				
			} // Active

			if ( seconds > 59 ) {
			
				seconds = 0;
				minutes++;
				
				if ( minutes > 59 ) {
					minutes = 0;
					hours++;
				}
				
				if ( hours > 23 ) hours = 0;
				
			}				
		}

		switch ( vscp_node_state ) {

			case VSCP_STATE_STARTUP:			// Cold/warm reset

				// Get nickname from EEPROM
				if ( VSCP_ADDRESS_FREE == vscp_nickname ) {
					// new on segment need a nickname
					vscp_node_state = VSCP_STATE_INIT; 	
				}
				else {
					// been here before - go on
					vscp_node_state = VSCP_STATE_ACTIVE;
					vscp_active();
				}
				break;

			case VSCP_STATE_INIT:			// Assigning nickname
				vscp_probe();
				break;

			case VSCP_STATE_PREACTIVE:		// Waiting for host initialisation
				vscp_rcv_preactive();					
				break;

			case VSCP_STATE_ACTIVE:			// The normal state
				
				if ( vscp_imsg.flags & VSCP_VALID_MSG ) {	// incoming message?
					
					// Yes, incoming message
					if ( VSCP_CLASS1_PROTOCOL == vscp_imsg.class ) {
						
						switch( vscp_imsg.type ) {

							case VSCP_TYPE_PROTOCOL_SEGCTRL_HEARTBEAT:
								vscp_rcv_heartbeat();
								break;

							case VSCP_TYPE_PROTOCOL_NEW_NODE_ONLINE:
								vscp_rcv_new_node_online();
								break;
							
							case VSCP_TYPE_PROTOCOL_SET_NICKNAME:
								vscp_rcv_set_nickname();
								break;
							
							case VSCP_TYPE_PROTOCOL_DROP_NICKNAME:
								vscp_rcv_drop_nickname();
								break;

							case VSCP_TYPE_PROTOCOL_READ_REGISTER:
								if ( ( 2 == ( vscp_imsg.flags & 0x0f ) ) && 
										( vscp_nickname == vscp_imsg.data[ 0 ] ) ) {

									if ( vscp_imsg.data[ 1 ] < 0x80 )  {
										// Read application specific register
										read_app_register( vscp_imsg.data[ 1 ] );
									}
									else {
										// Read VSCP register
										vscp_rcv_readreg();
									}
								}
								break;

							case VSCP_TYPE_PROTOCOL_WRITE_REGISTER:
								if ( ( 3 == ( vscp_imsg.flags & 0x0f ) ) && 
										( vscp_nickname == vscp_imsg.data[ 0 ] ) ) {
									if ( vscp_imsg.data[ 1 ] < 0x80 ) {
										// Write application specific register
										write_app_register( vscp_imsg.data[ 1 ], vscp_imsg.data[ 2 ] );
									}
									else {
										// Read VSCP register
										vscp_rcv_writereg();
									}
								}
								break;
								
							case VSCP_TYPE_PROTOCOL_ENTER_BOOT_LOADER:
								if ( ( vscp_nickname == vscp_imsg.data[ 0 ] ) &&
										( 1 == vscp_imsg.data[ 1 ] ) &&
										( readEEPROM( VSCP_EEPROM_REG_GUID + 0 ) == vscp_imsg.data[ 2 ] ) &&
										( readEEPROM( VSCP_EEPROM_REG_GUID + 3 ) == vscp_imsg.data[ 3 ] ) &&
										( readEEPROM( VSCP_EEPROM_REG_GUID + 5 ) == vscp_imsg.data[ 4 ] ) &&
										( readEEPROM( VSCP_EEPROM_REG_GUID + 7 ) == vscp_imsg.data[ 5 ] ) &&
										( ( vscp_page_select >> 8 ) == vscp_imsg.data[ 6 ] ) &&
										( ( vscp_page_select & 0xff ) == vscp_imsg.data[ 7 ] ) ) {											
									// OK, We should enter boot loader mode
									// 	First, activate bootloader mode
									writeEEPROM(VSCP_EEPROM_BOOTLOADER_FLAG, VSCP_BOOT_FLAG );
									//_asm goto _startup reset _endasm
									_asm reset _endasm
								}
								break;
								
							case VSCP_TYPE_PROTOCOL_GET_MATRIX_INFO:
								sendDMatrixInfo();
								break;	

							default:
								break;
						}							
					}
					
					// Decision Matrix
					doDM();	
					
				}
				break;

			case VSCP_STATE_ERROR:			// Everything is *very* *very* bad.
				vscp_error();
				break;

			default:					// Should not be here...
				vscp_node_state =VSCP_STATE_STARTUP;
				break;

		} 

		doWork();

	} // while